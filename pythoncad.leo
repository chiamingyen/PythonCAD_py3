<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954" a="E"><vh>Startup</vh>
<v t="amd_yen.20130426011410.8753" a="E"><vh>@settings</vh>
<v t="amd_yen.20130426011410.8754"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd_yen.20130426011410.8755"><vh>@string initial_split_orientation = vertical</vh></v>
</v>
</v>
<v t="1.20130426141258.2394" a="E"><vh>PythonCAD 程式碼</vh>
<v t="amd_yen.20130426011410.8908" a="E"><vh>參考資料</vh>
<v t="amd_yen.20130426011410.8909"><vh>Pyeuclid</vh></v>
<v t="amd_yen.20130426011410.8910"><vh>@edit refs/simgeo.py</vh></v>
<v t="amd_yen.20130426011410.8911"><vh>@edit refs/test_simgeo.py</vh></v>
<v t="amd_yen.20130426011410.8912"><vh>@url Pythonwildmagic</vh></v>
</v>
<v t="1.20130426141258.2396"><vh>@file customevent.py</vh></v>
<v t="1.20130426141258.2470"><vh>@file pythoncad_qt.py</vh></v>
<v t="1.20130426141258.2473"><vh>@file test_sympy.py</vh></v>
<v t="1.20130426141258.2475"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.2476" a="E"><vh>@path Generic</vh>
<v t="1.20130426141258.2477"><vh>@file application.py</vh></v>
<v t="1.20130426141258.2498"><vh>@file application_test.py</vh></v>
<v t="1.20130426141258.2510" a="O"><vh>@file test_kernel.py</vh>
<v t="1.20130426141258.2511"><vh>&lt;&lt;declarations&gt;&gt; (test_kernel)</vh></v>
<v t="1.20130426141258.2512"><vh>printId</vh></v>
<v t="1.20130426141258.2513"><vh>testSinglePoint</vh></v>
<v t="1.20130426141258.2514"><vh>testMultiPoints</vh></v>
<v t="1.20130426141258.2515"><vh>testMultiSegments</vh></v>
<v t="1.20130426141258.2516"><vh>testSingleSegment</vh></v>
<v t="1.20130426141258.2517"><vh>testGetLayerEnt</vh></v>
<v t="1.20130426141258.2518"><vh>testPerformanceInCreation</vh></v>
<v t="1.20130426141258.2519"><vh>createSegment</vh></v>
<v t="1.20130426141258.2520"><vh>CreateModifieEntity</vh></v>
<v t="1.20130426141258.2521"><vh>deleteTable</vh></v>
<v t="1.20130426141258.2522"><vh>testPointDb</vh></v>
<v t="1.20130426141258.2523"><vh>testPointDb1</vh></v>
<v t="1.20130426141258.2524"><vh>TestcPickleSql</vh></v>
<v t="1.20130426141258.2525"><vh>getAllSegment</vh></v>
<v t="1.20130426141258.2526"><vh>test</vh></v>
<v t="1.20130426141258.2527" a="E"><vh>class ioKernel</vh>
<v t="1.20130426141258.2528"><vh>__init__</vh></v>
<v t="1.20130426141258.2529"><vh>printError</vh></v>
<v t="1.20130426141258.2530"><vh>mainLoop</vh></v>
<v t="1.20130426141258.2531"><vh>help</vh></v>
<v t="1.20130426141258.2532"><vh>newSegment</vh></v>
<v t="1.20130426141258.2533"><vh>getDrawingEntity</vh></v>
<v t="1.20130426141258.2534"><vh>reDo</vh></v>
<v t="1.20130426141258.2535"><vh>unDo</vh></v>
<v t="1.20130426141258.2536"><vh>delete</vh></v>
<v t="1.20130426141258.2537"><vh>hideEntity</vh></v>
<v t="1.20130426141258.2538"><vh>unHideEntity</vh></v>
<v t="1.20130426141258.2539"><vh>endApplication</vh></v>
<v t="1.20130426141258.2540"><vh>release</vh></v>
<v t="1.20130426141258.2541"><vh>getLayers</vh></v>
<v t="1.20130426141258.2542"><vh>addLayer</vh></v>
<v t="1.20130426141258.2543"><vh>setCurrentLayer</vh></v>
<v t="1.20130426141258.2544"><vh>getCurrentLayerName</vh></v>
<v t="1.20130426141258.2545"><vh>importExt</vh></v>
<v t="1.20130426141258.2546"><vh>deleteLayer</vh></v>
<v t="1.20130426141258.2547"><vh>newArc</vh></v>
<v t="1.20130426141258.2548"><vh>getEntType</vh></v>
</v>
<v t="1.20130426141258.2549"><vh>printEntity</vh></v>
<v t="1.20130426141258.2550"><vh>printTree</vh></v>
<v t="1.20130426141258.2551" a="E"><vh>class textApplication</vh>
<v t="1.20130426141258.2552"><vh>__init__</vh></v>
<v t="1.20130426141258.2553"><vh>mainLoop</vh></v>
<v t="1.20130426141258.2554"><vh>printHelp</vh></v>
<v t="1.20130426141258.2555"><vh>getEnts</vh></v>
<v t="1.20130426141258.2556"><vh>printEntity</vh></v>
<v t="1.20130426141258.2557"><vh>newDoc</vh></v>
<v t="1.20130426141258.2558"><vh>createStyle</vh></v>
<v t="1.20130426141258.2559"><vh>getActiveDoc</vh></v>
<v t="1.20130426141258.2560"><vh>setActiveDoc</vh></v>
<v t="1.20130426141258.2561"><vh>showDocuments</vh></v>
<v t="1.20130426141258.2562"><vh>closeFile</vh></v>
<v t="1.20130426141258.2563"><vh>openFile</vh></v>
<v t="1.20130426141258.2564"><vh>endApplication</vh></v>
<v t="1.20130426141258.2565"><vh>performCommand</vh></v>
<v t="1.20130426141258.2566"><vh>featureTest</vh></v>
<v t="1.20130426141258.2567"><vh>testGeoChamfer</vh></v>
<v t="1.20130426141258.2568"><vh>testChamferCommand</vh></v>
<v t="1.20130426141258.2569"><vh>easyTest</vh></v>
<v t="1.20130426141258.2570"><vh>performCommandRandomly</vh></v>
<v t="1.20130426141258.2571"><vh>getRandomPoint</vh></v>
<v t="1.20130426141258.2572"><vh>inputInt</vh></v>
<v t="1.20130426141258.2573"><vh>inputFloat</vh></v>
<v t="1.20130426141258.2574"><vh>imputPoint</vh></v>
<v t="1.20130426141258.2575"><vh>outputMsg</vh></v>
<v t="1.20130426141258.2576"><vh>inputMsg</vh></v>
</v>
</v>
<v t="1.20130426141258.2577"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.2578" a="E"><vh>@path Kernel</vh>
<v t="1.20130426141258.2579"><vh>@file binarytree.py</vh></v>
<v t="1.20130426141258.2595"><vh>@file composedentity.py</vh></v>
<v t="1.20130426141258.2603"
expanded="1.20130426141258.2605,"><vh>@file document.py</vh></v>
<v t="1.20130426141258.2652"><vh>@file entity.py</vh></v>
<v t="1.20130426141258.2662"><vh>@file exception.py</vh></v>
<v t="1.20130426141258.2724"><vh>@file initsetting.py</vh></v>
<v t="1.20130426141258.2727"><vh>@file layer.py</vh></v>
<v t="1.20130426141258.2734"><vh>@file layertree.py</vh></v>
<v t="1.20130426141258.2757"><vh>@file pycadevent.py</vh></v>
<v t="1.20130426141258.2764"><vh>@file pycadtransaction.py</vh></v>
<v t="1.20130426141258.2769"><vh>@file settings.py</vh></v>
<v t="1.20130426141258.2778"><vh>@file unitparser.py</vh></v>
<v t="1.20130426141258.2784"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.2785"><vh>@path Command</vh>
<v t="1.20130426141258.2786"><vh>@@file arccommand.py</vh>
<v t="1.20130426141258.2787"><vh>&lt;&lt;declarations&gt;&gt; (arccommand)</vh></v>
<v t="1.20130426141258.2788"><vh>class ArcCommand</vh>
<v t="1.20130426141258.2789"><vh>__init__</vh></v>
<v t="1.20130426141258.2790"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2791"><vh>@@file basecommand.py</vh>
<v t="1.20130426141258.2792"><vh>&lt;&lt;declarations&gt;&gt; (basecommand)</vh></v>
<v t="1.20130426141258.2793"><vh>class BaseCommand</vh>
<v t="1.20130426141258.2794"><vh>__init__</vh></v>
<v t="1.20130426141258.2795"><vh>__iter__</vh></v>
<v t="1.20130426141258.2796"><vh>__setitem__</vh></v>
<v t="1.20130426141258.2797"><vh>resetToDefault</vh></v>
<v t="1.20130426141258.2798"><vh>applyDefault</vh></v>
<v t="1.20130426141258.2799"><vh>reset</vh></v>
<v t="1.20130426141258.2800"><vh>valueIndex</vh></v>
<v t="1.20130426141258.2801"><vh>__next__</vh></v>
<v t="1.20130426141258.2802"><vh>activeException</vh></v>
<v t="1.20130426141258.2803"><vh>activeMessage</vh></v>
<v t="1.20130426141258.2804"><vh>performDefaultValue</vh></v>
<v t="1.20130426141258.2805"><vh>activeDefaultValue</vh></v>
<v t="1.20130426141258.2806"><vh>getActiveDefaultValue</vh></v>
<v t="1.20130426141258.2807"><vh>previus</vh></v>
<v t="1.20130426141258.2808"><vh>keys</vh></v>
<v t="1.20130426141258.2809"><vh>lenght</vh></v>
<v t="1.20130426141258.2810"><vh>applyCommand</vh></v>
<v t="1.20130426141258.2811"><vh>translateCmdValue</vh></v>
<v t="1.20130426141258.2812"><vh>getIdsString</vh></v>
<v t="1.20130426141258.2813"><vh>convertToBool</vh></v>
<v t="1.20130426141258.2814"><vh>convertToInt</vh></v>
<v t="1.20130426141258.2815"><vh>convertToFloat</vh></v>
<v t="1.20130426141258.2816"><vh>convertToAngle</vh></v>
</v>
</v>
<v t="1.20130426141258.2817"><vh>@@file bisectorcommand.py</vh>
<v t="1.20130426141258.2818"><vh>&lt;&lt;declarations&gt;&gt; (bisectorcommand)</vh></v>
<v t="1.20130426141258.2819"><vh>class BisectorCommand</vh>
<v t="1.20130426141258.2820"><vh>__init__</vh></v>
<v t="1.20130426141258.2821"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2822"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2823"><vh>@@file ccirclecommand.py</vh>
<v t="1.20130426141258.2824"><vh>&lt;&lt;declarations&gt;&gt; (ccirclecommand)</vh></v>
<v t="1.20130426141258.2825"><vh>class CCircleCommand</vh>
<v t="1.20130426141258.2826"><vh>__init__</vh></v>
<v t="1.20130426141258.2827"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2828"><vh>@@file chamfercommand.py</vh>
<v t="1.20130426141258.2829"><vh>&lt;&lt;declarations&gt;&gt; (chamfercommand)</vh></v>
<v t="1.20130426141258.2830"><vh>class ChamferCommand</vh>
<v t="1.20130426141258.2831"><vh>__init__</vh></v>
<v t="1.20130426141258.2832"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2833"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2834"><vh>@@file circlecommand.py</vh>
<v t="1.20130426141258.2835"><vh>&lt;&lt;declarations&gt;&gt; (circlecommand)</vh></v>
<v t="1.20130426141258.2836"><vh>class CircleCommand</vh>
<v t="1.20130426141258.2837"><vh>__init__</vh></v>
<v t="1.20130426141258.2838"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2839"><vh>@@file clinecommand.py</vh>
<v t="1.20130426141258.2840"><vh>&lt;&lt;declarations&gt;&gt; (clinecommand)</vh></v>
<v t="1.20130426141258.2841"><vh>class CLineCommand</vh>
<v t="1.20130426141258.2842"><vh>__init__</vh></v>
<v t="1.20130426141258.2843"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2844"><vh>@@file copycommand.py</vh>
<v t="1.20130426141258.2845"><vh>&lt;&lt;declarations&gt;&gt; (copycommand)</vh></v>
<v t="1.20130426141258.2846"><vh>class CopyCommand</vh>
<v t="1.20130426141258.2847"><vh>__init__</vh></v>
<v t="1.20130426141258.2848"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2849"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2850"><vh>@@file deletecommand.py</vh>
<v t="1.20130426141258.2851"><vh>&lt;&lt;declarations&gt;&gt; (deletecommand)</vh></v>
<v t="1.20130426141258.2852"><vh>class DeleteCommand</vh>
<v t="1.20130426141258.2853"><vh>__init__</vh></v>
<v t="1.20130426141258.2854"><vh>applyDefault</vh></v>
<v t="1.20130426141258.2855"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2856"><vh>@@file dimensioncommand.py</vh>
<v t="1.20130426141258.2857"><vh>&lt;&lt;declarations&gt;&gt; (dimensioncommand)</vh></v>
<v t="1.20130426141258.2858"><vh>class DimensionCommand</vh>
<v t="1.20130426141258.2859"><vh>__init__</vh></v>
<v t="1.20130426141258.2860"><vh>getAngle</vh></v>
<v t="1.20130426141258.2861"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2862"><vh>@@file ellipsecommand.py</vh>
<v t="1.20130426141258.2863"><vh>&lt;&lt;declarations&gt;&gt; (ellipsecommand)</vh></v>
<v t="1.20130426141258.2864"><vh>class EllipseCommand</vh>
<v t="1.20130426141258.2865"><vh>__init__</vh></v>
<v t="1.20130426141258.2866"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2867"><vh>@@file filletcommand.py</vh>
<v t="1.20130426141258.2868"><vh>&lt;&lt;declarations&gt;&gt; (filletcommand)</vh></v>
<v t="1.20130426141258.2869"><vh>class FilletCommand</vh>
<v t="1.20130426141258.2870"><vh>__init__</vh></v>
<v t="1.20130426141258.2871"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2872"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2873"><vh>@@file mirrorcommand.py</vh>
<v t="1.20130426141258.2874"><vh>&lt;&lt;declarations&gt;&gt; (mirrorcommand)</vh></v>
<v t="1.20130426141258.2875"><vh>class MirrorCommand</vh>
<v t="1.20130426141258.2876"><vh>__init__</vh></v>
<v t="1.20130426141258.2877"><vh>performMirror</vh></v>
<v t="1.20130426141258.2878"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2879"><vh>@@file movecommand.py</vh>
<v t="1.20130426141258.2880"><vh>&lt;&lt;declarations&gt;&gt; (movecommand)</vh></v>
<v t="1.20130426141258.2881"><vh>class MoveCommand</vh>
<v t="1.20130426141258.2882"><vh>__init__</vh></v>
<v t="1.20130426141258.2883"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2884"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2885"><vh>@@file pointcommand.py</vh>
<v t="1.20130426141258.2886"><vh>&lt;&lt;declarations&gt;&gt; (pointcommand)</vh></v>
<v t="1.20130426141258.2887"><vh>class PointCommand</vh>
<v t="1.20130426141258.2888"><vh>__init__</vh></v>
<v t="1.20130426141258.2889"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2890"><vh>@@file polygoncommand.py</vh>
<v t="1.20130426141258.2891"><vh>&lt;&lt;declarations&gt;&gt; (polygoncommand)</vh></v>
<v t="1.20130426141258.2892"><vh>class PolygonCommand</vh>
<v t="1.20130426141258.2893"><vh>__init__</vh></v>
<v t="1.20130426141258.2894"><vh>side</vh></v>
<v t="1.20130426141258.2895"><vh>side</vh></v>
<v t="1.20130426141258.2896"><vh>updateSide</vh></v>
<v t="1.20130426141258.2897"><vh>external</vh></v>
<v t="1.20130426141258.2898"><vh>external</vh></v>
<v t="1.20130426141258.2899"><vh>externalPick</vh></v>
<v t="1.20130426141258.2900"><vh>externalPick</vh></v>
<v t="1.20130426141258.2901"><vh>center</vh></v>
<v t="1.20130426141258.2902"><vh>center</vh></v>
<v t="1.20130426141258.2903"><vh>getCoord</vh></v>
<v t="1.20130426141258.2904"><vh>CalculatePoint</vh></v>
<v t="1.20130426141258.2905"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2906"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2907"><vh>@@file polylinecommand.py</vh>
<v t="1.20130426141258.2908"><vh>&lt;&lt;declarations&gt;&gt; (polylinecommand)</vh></v>
<v t="1.20130426141258.2909"><vh>class PolylineCommand</vh>
<v t="1.20130426141258.2910"><vh>__init__</vh></v>
<v t="1.20130426141258.2911"><vh>__setitem__</vh></v>
<v t="1.20130426141258.2912"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2913"><vh>@@file propertycommand.py</vh>
<v t="1.20130426141258.2914"><vh>&lt;&lt;declarations&gt;&gt; (propertycommand)</vh></v>
<v t="1.20130426141258.2915"><vh>class PropertyCommand</vh>
<v t="1.20130426141258.2916"><vh>__init__</vh></v>
<v t="1.20130426141258.2917"><vh>changeProp</vh></v>
<v t="1.20130426141258.2918"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2919"><vh>@@file rectanglecommand.py</vh>
<v t="1.20130426141258.2920"><vh>&lt;&lt;declarations&gt;&gt; (rectanglecommand)</vh></v>
<v t="1.20130426141258.2921"><vh>class RectangleCommand</vh>
<v t="1.20130426141258.2922"><vh>__init__</vh></v>
<v t="1.20130426141258.2923"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2924"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2925"><vh>@@file rotatecommand.py</vh>
<v t="1.20130426141258.2926"><vh>&lt;&lt;declarations&gt;&gt; (rotatecommand)</vh></v>
<v t="1.20130426141258.2927"><vh>class RotateCommand</vh>
<v t="1.20130426141258.2928"><vh>__init__</vh></v>
<v t="1.20130426141258.2929"><vh>performRotation</vh></v>
<v t="1.20130426141258.2930"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2931"><vh>@@file segmentcommand.py</vh>
<v t="1.20130426141258.2932"><vh>&lt;&lt;declarations&gt;&gt; (segmentcommand)</vh></v>
<v t="1.20130426141258.2933"><vh>class SegmentCommand</vh>
<v t="1.20130426141258.2934"><vh>__init__</vh></v>
<v t="1.20130426141258.2935"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2936"><vh>@@file textcommand.py</vh>
<v t="1.20130426141258.2937"><vh>&lt;&lt;declarations&gt;&gt; (textcommand)</vh></v>
<v t="1.20130426141258.2938"><vh>class TextCommand</vh>
<v t="1.20130426141258.2939"><vh>__init__</vh></v>
<v t="1.20130426141258.2940"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2941"><vh>@@file trimcommand.py</vh>
<v t="1.20130426141258.2942"><vh>&lt;&lt;declarations&gt;&gt; (trimcommand)</vh></v>
<v t="1.20130426141258.2943"><vh>class TrimCommand</vh>
<v t="1.20130426141258.2944"><vh>__init__</vh></v>
<v t="1.20130426141258.2945"><vh>performTrim</vh></v>
<v t="1.20130426141258.2946"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2947"><vh>@@file __init__.py</vh>
<v t="1.20130426141258.2948"><vh>&lt;&lt;declarations&gt;&gt; (__init__)</vh></v>
</v>
</v>
<v t="1.20130426141258.2949" a="E"><vh>@path Db</vh>
<v t="1.20130426141258.2950"><vh>@file basedb.py</vh></v>
<v t="1.20130426141258.2964"><vh>@file entitydb.py</vh></v>
<v t="1.20130426141258.2990"><vh>@file pycadobject.py</vh></v>
<v t="1.20130426141258.3013"><vh>@file relationdb.py</vh></v>
<v t="1.20130426141258.3025"><vh>@file undodb.py</vh></v>
<v t="1.20130426141258.3040"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3041" a="E"><vh>@path ExternalFormat</vh>
<v t="1.20130426141258.3042"><vh>@file externalformat.py</vh></v>
<v t="1.20130426141258.3049"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.3050" a="E"><vh>@path Dxf</vh>
<v t="1.20130426141258.3051"
expanded="1.20130426141258.3066,"><vh>@file dxf.py</vh></v>
<v t="1.20130426141258.3086"><vh>@file __init__.py</vh></v>
</v>
</v>
<v t="1.20130426141258.3087" a="E"><vh>@path GeoComposedEntity</vh>
<v t="1.20130426141258.3088"><vh>@file bisector.py</vh></v>
<v t="1.20130426141258.3100"><vh>@file chamfer.py</vh></v>
<v t="1.20130426141258.3115"><vh>@file fillet.py</vh></v>
<v t="1.20130426141258.3132"><vh>@file objoint.py</vh></v>
<v t="1.20130426141258.3151"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3152" a="E"><vh>@path GeoEntity</vh>
<v t="1.20130426141258.3153"><vh>@file arc.py</vh></v>
<v t="1.20130426141258.3187"><vh>@file ccircle.py</vh></v>
<v t="1.20130426141258.3209"><vh>@file cline.py</vh></v>
<v t="1.20130426141258.3230"><vh>@file dimension.py</vh></v>
<v t="1.20130426141258.3249"
expanded="1.20130426141258.3251,"><vh>@file ellipse.py</vh></v>
<v t="1.20130426141258.3270"><vh>@file entityutil.py</vh></v>
<v t="1.20130426141258.3273"><vh>@file geometricalentity.py</vh></v>
<v t="1.20130426141258.3293"><vh>@file hatch.py</vh></v>
<v t="1.20130426141258.3323"><vh>@file nurbs.py</vh></v>
<v t="1.20130426141258.3334"><vh>@file point.py</vh></v>
<v t="1.20130426141258.3361"><vh>@file polyline.py</vh></v>
<v t="1.20130426141258.3378"><vh>@file segment.py</vh></v>
<v t="1.20130426141258.3405"><vh>@file style.py</vh></v>
<v t="1.20130426141258.3408"><vh>@file text.py</vh></v>
<v t="1.20130426141258.3426"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3427" a="E"><vh>@path GeoUtil</vh>
<v t="1.20130426141258.3428"><vh>@file geolib.py</vh></v>
<v t="1.20130426141258.3447"><vh>@file intersection.py</vh></v>
<v t="1.20130426141258.3460"><vh>@file rotate.py</vh></v>
<v t="1.20130426141258.3476"><vh>@file tangent.py</vh></v>
<v t="1.20130426141258.3488"><vh>@file tolerance.py</vh></v>
<v t="1.20130426141258.3498"><vh>@file util.py</vh></v>
<v t="1.20130426141258.3518"><vh>@file __init__.py</vh></v>
</v>
</v>
</v>
<v t="1.20130426141258.3519" a="E"><vh>@path Interface</vh>
<v t="1.20130426141258.3520" a="E"><vh>@file cadinitsetting.py</vh></v>
<v t="1.20130426141258.3522"
expanded="1.20130426141258.3524,"><vh>@file cadscene.py</vh></v>
<v t="1.20130426141258.3560"><vh>@file cadview.py</vh></v>
<v t="1.20130426141258.3573"
expanded="1.20130426141258.3575,1.20130426141258.3648,"><vh>@file cadwindow.py</vh></v>
<v t="1.20130426141258.3652" a="E"><vh>@file cadwindow_rc.py</vh></v>
<v t="1.20130426141258.3656" a="E"><vh>@file idocument.py</vh></v>
<v t="1.20130426141258.3678"><vh>@file pycadapp.py</vh></v>
<v t="1.20130426141258.3689"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.3690" a="E"><vh>@path CmdIntf</vh>
<v t="1.20130426141258.3691" a="E"
expanded="1.20130426141258.3693,"><vh>@file cmdaction.py</vh></v>
<v t="1.20130426141258.3699" a="E"
expanded="1.20130426141258.3700,"><vh>@file cmdcategory.py</vh></v>
<v t="1.20130426141258.3705"><vh>@file cmdintf.py</vh></v>
<v t="1.20130426141258.3723"><vh>@file cmdlinedock.py</vh></v>
<v t="1.20130426141258.3738"><vh>@file functionhandler.py</vh></v>
<v t="1.20130426141258.3747"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3748"><vh>@path Command</vh>
<v t="1.20130426141258.3749"><vh>@file distance2point.py</vh></v>
<v t="1.20130426141258.3754"><vh>@file icommand.py</vh></v>
<v t="1.20130426141258.3791"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3792"><vh>@path Dialogs</vh>
<v t="1.20130426141258.3793"><vh>@file dataModel.py</vh></v>
<v t="1.20130426141258.3813"><vh>@file preferences.py</vh></v>
<v t="1.20130426141258.3819"><vh>@file property.py</vh></v>
<v t="1.20130426141258.3832"><vh>@file Ui_preferences.py</vh></v>
<v t="1.20130426141258.3837"><vh>@file Ui_property.py</vh></v>
<v t="1.20130426141258.3842"><vh>@file __init__.py</vh></v>
<v t="1.20130426141258.3843" a="E"><vh>@path Widget</vh>
<v t="1.20130426141258.3844"><vh>@file widgets.py</vh></v>
<v t="1.20130426141258.3862"><vh>@file __init__.py</vh></v>
</v>
</v>
<v t="1.20130426141258.3863" a="E"><vh>@path DrawingHelper</vh>
<v t="1.20130426141258.3864"><vh>@file evaluator.py</vh></v>
<v t="1.20130426141258.3871"><vh>@file polarguides.py</vh></v>
<v t="1.20130426141258.3896"><vh>@file snap.py</vh></v>
<v t="1.20130426141258.3919"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.3920" a="E"><vh>@path Entity</vh>
<v t="1.20130426141258.3921"><vh>@file actionhandler.py</vh></v>
<v t="1.20130426141258.3991"><vh>@file arc.py</vh></v>
<v t="1.20130426141258.3997"><vh>@file arrowitem.py</vh></v>
<v t="1.20130426141258.4003"><vh>@file base.py</vh></v>
<v t="1.20130426141258.4025"><vh>@file dimension.py</vh></v>
<v t="1.20130426141258.4034"><vh>@file dinamicentryobject.py</vh></v>
<v t="1.20130426141258.4043"><vh>@file ellipse.py</vh></v>
<v t="1.20130426141258.4049"><vh>@file point.py</vh></v>
<v t="1.20130426141258.4056"><vh>@file polyline.py</vh></v>
<v t="1.20130426141258.4063"><vh>@file segment.py</vh></v>
<v t="1.20130426141258.4069"><vh>@file text.py</vh></v>
<v t="1.20130426141258.4075"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.4076" a="E"><vh>@path LayerIntf</vh>
<v t="1.20130426141258.4077"><vh>@file layerdock.py</vh></v>
<v t="1.20130426141258.4083"><vh>@file layertreeobject.py</vh></v>
<v t="1.20130426141258.4105"><vh>@file __init__.py</vh></v>
</v>
<v t="1.20130426141258.4106" a="E"><vh>@path Preview</vh>
<v t="1.20130426141258.4107"><vh>@file arc.py</vh></v>
<v t="1.20130426141258.4115"><vh>@file base.py</vh></v>
<v t="1.20130426141258.4127"><vh>@file ellipse.py</vh></v>
<v t="1.20130426141258.4140"><vh>@file factory.py</vh></v>
<v t="1.20130426141258.4143"><vh>@file point.py</vh></v>
<v t="1.20130426141258.4150"><vh>@file polygon.py</vh></v>
<v t="1.20130426141258.4163"><vh>@file polyline.py</vh></v>
<v t="1.20130426141258.4170"><vh>@file rectangle.py</vh></v>
<v t="1.20130426141258.4177"><vh>@file segment.py</vh></v>
<v t="1.20130426141258.4184"><vh>@file __init__.py</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="1.20130426141258.2394">這是 PythonCAD 的程式碼, 利用 PyQt 作為 GUI, SQLite 作為資料庫檔案, 內建簡單的 2D 繪圖核心, 若在實際應用上需要增進繪圖速度, 則可將部份核心程式碼改用 C 或 C++ 編寫.</t>
<t tx="1.20130426141258.2476"></t>
<t tx="1.20130426141258.2510">@first #!/usr/bin/env python
@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__=='__main__':
    ta=textApplication()
    #ta.getRandomPoint()
    #ta.mainLoop()
    ta.featureTest()
    #io=ioKernel()
    #io.mainLoop()
    print("bye")
</t>
<t tx="1.20130426141258.2511">import sys
import os
import platform

import sqlite3 as sqlite

    
# This is needed for me to use unpickle objects
#sys.path.append(os.path.join(os.getcwd(), 'Generic', 'Interface'))    
    
from random                             import random
from Kernel.document            import *
from application         import  Application
from Kernel.GeoEntity.point        import Point
from Kernel.GeoEntity.style        import Style
from Kernel.GeoComposedEntity.chamfer   import Chamfer
</t>
<t tx="1.20130426141258.2512">def printId(kernel,obj):
    """
        print the id of the obj
    """
    print("Save Entity: %s"%str(type(obj)))
</t>
<t tx="1.20130426141258.2513">def testSinglePoint(kernel):
    """
        test single point operation
    """
    startTime=time.clock()
    print("Create a single point")
    basePoint=Point(10,1)
    print("singlePoint ",type(basePoint))
    kernel.saveEntity(basePoint)
    endTime=time.clock()-startTime
    print("Time for saving  a single point   %ss"%str(endTime))   
</t>
<t tx="1.20130426141258.2514">def testMultiPoints(kernel,nPoint)    :
    """
        test the point operatoin
    """
    startTime=time.clock()
    kernel.startMassiveCreation()
    for i in range(nPoint):
        basePoint=Point(10,i)
        kernel.saveEntity(basePoint)
    kernel.performCommit()
    endTime=time.clock()-startTime
    print("Create n: %s entity in : %ss"%(str(nPoint ),str(endTime)))
</t>
<t tx="1.20130426141258.2515">def testMultiSegments(kernel,nSegments):
    """
        create a single segment
    """    
    startTime=time.clock()
    kernel.startMassiveCreation()
    for i in range(nSegments):
        _p1=Point(10,i)
        _p2=Point(10,i)
        _s=Segment(_p1,_p2)
        kernel.saveEntity(_s)
    kernel.performCommit()
    endTime=time.clock()-startTime
    print("Create n: %s entity in : %ss"%(str(nSegments ),str(endTime)))
</t>
<t tx="1.20130426141258.2516">def testSingleSegment(kernel):
    """
        create a single segment
    """    
    _p1=Point(10,10)
    _p2=Point(10,20)
    _s=Segment(_p1,_p2)
    kernel.saveEntity(_s)
</t>
<t tx="1.20130426141258.2517">def testGetLayerEnt(kernel):
    """
        get layer dictionary of all the id child
    """
    startTime=time.clock()
    ids=kernel.getLayerChild('ROOT')
    nids=len(ids)
    endTime=time.clock()-startTime
    print("Get n: %s layer entity in : %ss"%(str(nids ),str(endTime)))
</t>
<t tx="1.20130426141258.2518">def testPerformanceInCreation(kr):
    print("Points:")
    testMultiPoints(kr,1)
    #testMultiPoints(kr,10)
    #testMultiPoints(kr,100)
    #testMultiPoints(kr,1000)
    #testMultiPoints(kr,10000)
    #testMultiPoints(kr,100000)
    print("Segments:")
    testMultiSegments(kr,1)
    #testMultiSegments(kr,10)
    #testMultiSegments(kr,100)
    #testMultiSegments(kr,1000)
    #testMultiSegments(kr,10000)
    #testMultiSegments(kr,100000)
    testGetLayerEnt(kr)
</t>
<t tx="1.20130426141258.2519">def createSegment(kernel):
    """
        create a single segment
    """    
    _p1=Point(10,10)
    _p2=Point(10,20)
    _s=Segment(_p1,_p2)
    return kernel.saveEntity(_s)
</t>
<t tx="1.20130426141258.2520">def CreateModifieEntity(kr):
    """
        test for create and modifie an entity
    """
    ent=createSegment(kr)
    celement={'POINT_1':Point(100,100), 'POINT_2':Point(200,200)}
    ent.setConstructionElement(celement)
    kr.saveEntity(ent)
</t>
<t tx="1.20130426141258.2521">def deleteTable(tableName):
    """
    delete the table name 
    """
    #import sqlite3 as sql
    # sqlite + R*Tree module
    from pysqlite2 import dbapi2 as sql

    dbPath='pythoncad.pdr' 
    dbConnection = sql.connect(dbPath)
    statment="drop table pycadrel"
    _cursor = dbConnection.cursor()
    _rows = _cursor.execute(statment)
    dbConnection.commit()
    dbConnection.close()
</t>
<t tx="1.20130426141258.2522">def testPointDb(nLoop):
    """
    Test point creation 
    """
    #import sqlite3 as sql
    # sqlite + R*Tree module
    from pysqlite2 import dbapi2 as sql
    import pickle as pickle
    
    dbConnection = sql.connect(":memory:")
    cursor=dbConnection.cursor()
    _sqlCreation="""CREATE TABLE pycadent(
                    pycad_id INTEGER PRIMARY KEY,
                    pycad_entity_id INTEGER,
                    pycad_object_type TEXT,
                    pycad_object_definition TEXT,
                    pycad_style_id INTEGER,
                    pycad_security_id INTEGER,
                    pycad_undo_id INTEGER,
                    pycad_entity_state TEXT,
                    pycad_date NUMERIC,
                    pycad_visible INTEGER,
                    pycad_undo_visible INTEGER,
                    pycad_locked INTEGER,
                    pycad_bbox_xmin REAL,
                    pycad_bbox_ymin REAL,
                    pycad_bbox_xmax REAL,
                    pycad_bbox_ymax REAL)"""
    cursor.execute(_sqlCreation)
    dic=[(x, y) for x in range(20) for y in range(1)]
    dbConnection.commit()
    startTime=time.clock()
    for i in range(nLoop):
        dumpDic=pickle.dumps(dic)
        sql="""insert into pycadent (pycad_entity_id,pycad_object_definition) values(1,"%s")"""%str(dumpDic)
        cursor.execute(sql)
    dbConnection.commit()
    endTime=time.clock()-startTime
    everage=endTime/nLoop
    print("End time for nLoop %s in %s everage %s "%(str(nLoop), str(endTime), str(everage)))
</t>
<t tx="1.20130426141258.2523">def testPointDb1(nLoop):
    """
    Test point creation 
    """
    #import sqlite3 as sql
    # sqlite + R*Tree module
    from pysqlite2 import dbapi2 as sql
    import pickle as pickle
    
    dbConnection = sql.connect(":memory:")
    cursor=dbConnection.cursor()
    _sqlCreation="""CREATE TABLE pycadent(
                    pycad_X REAL,
                    pycad_Y REAL)"""
    cursor.execute(_sqlCreation)
    dbConnection.commit()    
    dic=[(x,y) for x in range(20) for y in range(1)]
    startTime=time.clock()
    for i in range(nLoop):
        for x,y in dic:
            _sql="""INSERT INTO pycadent (pycad_X,pycad_Y) 
                VALUES (%s,%s)"""%(str(x),str(y))
            cursor.execute(_sql)
    dbConnection.commit()   
    endTime=time.clock()-startTime
    everage=endTime/nLoop
    print("End time for nLoop %s in %s everage %s "%(str(nLoop), str(endTime), str(everage)))
</t>
<t tx="1.20130426141258.2524">def TestcPickleSql():
    for i in [10,100, 1000, 1000, 10000, 100000]:
        print("&gt;&gt;print Test with %s entitys"%str(i))
        testPointDb(i)
        testPointDb1(i)
</t>
<t tx="1.20130426141258.2525">def getAllSegment(kr):
    """
        get all the segments
    """
    print("&gt;&gt;Looking for segment")
    ent=kr.getEntityFromType('SEGMENT')
    for e in ent:
        print("e &gt;&gt;&gt;&gt;", e.eType)
</t>
<t tx="1.20130426141258.2526">def test():
    print("&gt;&gt;Create pycad object")
    kr=PyCadDbKernel()
    #CreateModifieEntity(kr)
    #print "Add creation event"
    #kr.saveEntityEvent+=printId
    redo(kr)
    getAllSegment(kr)
</t>
<t tx="1.20130426141258.2527">class ioKernel(object):
    """
        This class provide a simple interface for using 
        PythonCad Kernel
    """
    @others
</t>
<t tx="1.20130426141258.2528">def __init__(self):
    startTime=time.clock()
    self.__kr=PyCadDbKernel()
    endTime=time.clock()-startTime    
    print("Inizialize kernel object in : %s"%str(endTime))
    self.__command={}
    #Basic Command
    self.__command['H']=self.help
    self.__command['Esc']=self.endApplication
    self.__command['Import']=self.importExt
    self.__command['SetCurrentLayer']=self.setCurrentLayer
    #Creatio Command
    self.__command['NewSegment']=self.newSegment
    self.__command['NewArc']=self.newArc
    self.__command['AddLayer']=self.addLayer
    #Delete Command
    self.__command['Delete']=self.delete
    self.__command['DeleteLayer']=self.deleteLayer
    #Get Command
    self.__command['GetCurrentLayer']=self.getCurrentLayerName
    self.__command['GetEntType']=self.getEntType
    self.__command['GetLayers']=self.getLayers
    self.__command['GetDrwEnt']=self.getDrawingEntity
    #Edit Command
    self.__command['UnDo']=self.unDo
    self.__command['ReDo']=self.reDo
    #WorkFlow Command
    self.__command['Relese']=self.release
    #View Command
    self.__command['Hide']=self.hideEntity
    self.__command['UnHide']=self.unHideEntity
    self.__kr.handledError=self.printError
</t>
<t tx="1.20130426141258.2529">def printError(self, **args):
    """
        print the error/warning caming from the kernel
    """    
    if 'error' in args:
        if args['error']=='DxfReport':
            print("dxfReport") #todo : improve this sistem
        elif args['error']=='DxfUnsupportedFormat':
            print("DxfUnsupportedFormat") #todo : improve this sistem
</t>
<t tx="1.20130426141258.2530">def mainLoop(self):
    """
        mainLoop operation
    """
    while 1:
        imputstr=input("Insert a command (H for Help)&gt;&gt; :")
        if imputstr in self.__command:
            self.__command[imputstr]()
        else:
            print("Wrong Command !!")
</t>
<t tx="1.20130426141258.2531">def help(self):
    """
        print the help
    """
    print("*"*10)
    print("PyCadIOInterface Help")
    kmd=list(self.__command.keys())
    kmd.sort()
    for s in kmd:
        print("command :" , s)
    print("*"*10)   
</t>
<t tx="1.20130426141258.2532">def newSegment(self):
    """
        create a new segment
    """
    try:
        val=(input("--&gt;Get First Point x,y :"))
        p1=Point(val[0], val[1])
        val=(input("--&gt;Get Second Point x,y :"))
        p2=Point(val[0], val[1])
        _s=Segment(p1,p2)
        self.__kr.saveEntity(_s)
    except:
        print("----&gt;Error on point creation !!")
</t>
<t tx="1.20130426141258.2533">def getDrawingEntity(self):        
    """
        get all the drawing entity
    """
    print("--&lt;&lt; Looking for All entitys")
    startTime=time.clock()
    ents=self.__kr.getAllDrawingEntity()
    endTime=time.clock()-startTime       
    printEntity(ents)
    print("Exec query get %s ent in %s s"%(str(len(ents)), str(endTime)))
    print("********************************")
</t>
<t tx="1.20130426141258.2534">def reDo(self):
    """
        perform the redo command
    """
    try:
        print("--&gt;&gt;Perform Redo")
        self.__kr.reDo()  
    except UndoDb:
        print("----&lt;&lt;Err&gt;&gt;No more redo to performe")
</t>
<t tx="1.20130426141258.2535">def unDo(self):
    """
        perform the undo command
    """
    try:
        print("--&gt;&gt;Perform unDo")
        self.__kr.unDo()  
    except UndoDb:
        print("----&lt;&lt;Err&gt;&gt;No more unDo to performe")
</t>
<t tx="1.20130426141258.2536">def delete(self):
    """
        Delete the entity
    """
    try:
        val=(input("--&gt;Write entityId :"))
        self.__kr.deleteEntity(val)
    except:
        print("----&lt;&lt;Err&gt;&gt;Enable to delete the entity")
</t>
<t tx="1.20130426141258.2537">def hideEntity(self):
    """
        hide an entity
    """
    entId=input("--&gt;Insert the id to hide :")
    try:
        self.__kr.hideEntity(entityId=entId)
    except:
        print("----&lt;&lt;Err&gt;&gt;On Hide the id : %s "%entId)
</t>
<t tx="1.20130426141258.2538">def unHideEntity(self):
    """
        unhide an entity
    """
    entId=input("--&gt;Insert the id to Unhide :")
    try:
        self.__kr.unHideEntity(entityId=entId)
    except:
        print("----&lt;&lt;Err&gt;&gt;On unHide the id : %s "%entId)
</t>
<t tx="1.20130426141258.2539">def endApplication(self):
    """
        close the application
    """
    sys.exit(0)
</t>
<t tx="1.20130426141258.2540">def release(self):
    """
        release the current drawing
    """
    self.__kr.release()
</t>
<t tx="1.20130426141258.2541">def getLayers(self):
    """
        get all layer
    """
    try:
        print("&gt;&gt;** Layer Tree ****")
        layersTree=self.__kr.getLayerTree().getLayerTree()
        printTree(layersTree, 1)
        print("&lt;&lt;** Layer Tree ****")
    except:
        print("----&lt;&lt;Err&gt;&gt;On getLayers ")
</t>
<t tx="1.20130426141258.2542">def addLayer(self):
    """
        add a new layer
    """
    layerName=input("--&gt;Insert LayerName :")
    try:
        activeLayer=self.__kr.getLayerTree().getActiveLater()
        newLayer=Layer(layerName)
        dbLayer=self.__kr.saveEntity(newLayer)
        self.__kr.getLayerTree().insert(dbLayer,activeLayer)
        
    except:
        print("----&lt;&lt;Err&gt;&gt;Unable to create the layer : %s "%layerName)
</t>
<t tx="1.20130426141258.2543">def setCurrentLayer(self):
    """
        set the current layer
    """
    LayerName=input("--&gt;Layer Id :")
    try:
        self.__kr.getLayerTree().setActiveLayer(LayerName)
    except:
        print("----&lt;&lt;Err&gt;&gt;Unable to create the layer : %s "%LayerName)
</t>
<t tx="1.20130426141258.2544">def getCurrentLayerName(self):
    """
        get the current layer name
    """
    try:
        activeLayer=self.__kr.getLayerTree().getActiveLater()
        ce=self.__kr.getLayerTree()._getLayerConstructionElement(activeLayer)
        print("Layer Name", ce.name)
    except:
        print("----&lt;&lt;Err&gt;&gt;unable to get the current layer name ")
</t>
<t tx="1.20130426141258.2545">def importExt(self):
    """
        import an external file into pythoncad
    """
    fileName=input("--&gt;insert The file name to import :")
    try:
        self.__kr.importExternalFormat(fileName)
    except:
        print("----&lt;&lt;Err&gt;&gt; importExt the  : %s we get en error "%fileName)
</t>
<t tx="1.20130426141258.2546">def deleteLayer(self):
    """
        Delete the layer
    """
    layerId=input("--&gt;insert The id layer to delete :")
    try:
        self.__kr.getLayerTree().delete(layerId)
    except:
        print("----&lt;&lt;Err&gt;&gt; deleteLayer id : %s we get en error "%layerId)
</t>
<t tx="1.20130426141258.2547">def newArc(self):
    """
        Create a new arc
    """ 
    radius=input("--&gt;Insert the radius :")
    val=input("--&gt;insert The center position x,y:")
    xy=val.split(',')
    if len(xy)==2:
        center=Point(xy[0], xy[1])
    else:
        print("Errore valore incorretto inserire un valore 10,20 in questo formato")
        return
        
    start_angle=input("--&gt;insert startAngle [Empty in case of circle]:")
    if start_angle:
        end_angle=input("--&gt;insert The end Angle :")
    else:
        start_angle=end_angle=0
    arc=Arc(center, float(radius), float(start_angle), float(end_angle))
    self.__kr.saveEntity(arc)
</t>
<t tx="1.20130426141258.2548">def getEntType(self):
    """
        get all the entity from a specifie type
    """
    type=input("--&gt;Witch Type ? :")
    if not type:
        type="ALL"
    startTime=time.clock()
    ents=self.__kr.getEntityFromType(type)
    endTime=time.clock()-startTime       
    printEntity(ents)
    print("Exec query get %s ent in %s s"%(str(len(ents)), str(endTime)))
    print("********************************")
</t>
<t tx="1.20130426141258.2549">def printEntity(ents):
    """
        print a query result
    """
    i=0
    for e in ents:
        print("----&lt;&lt; Entity Type %s id %s "%(str(e.eType),str(e.getId())))
        if i &gt; 100:
            print("There are more then 100 entitys in the select so i stop printing")
            break
        i+=1
</t>
<t tx="1.20130426141258.2550">def printTree(cls, indent):
    """
        print the tree structure
    """  
    if cls:
        for l in cls:
            parent, childs=cls[l]
            print('.'*indent + 'Layer Id: %s Name : %s'%(str(l) , str(parent.name)))
            printTree(childs, indent+1)
</t>
<t tx="1.20130426141258.2551">class textApplication(object):
    @others
</t>
<t tx="1.20130426141258.2552">def __init__(self):
    self.__command={}
    self.__applicationCommand={}
    # Application Command
    self.__applicationCommand['Open']=self.openFile
    self.__applicationCommand['Close']=self.closeFile
    self.__applicationCommand['New']=self.newDoc
    self.__applicationCommand['Documents']=self.showDocuments
    self.__applicationCommand['CreateStyle']=self.createStyle
    self.__applicationCommand['SetActive']=self.setActiveDoc
    self.__applicationCommand['GetActive']=self.getActiveDoc
    self.__applicationCommand['GetEnts']=self.getEnts
    self.__applicationCommand['Esc']=self.endApplication
    self.__applicationCommand['?']=self.printHelp
    self.__applicationCommand['Test']=self.featureTest
    self.__applicationCommand['ETest']=self.easyTest
    # Document Commandf
    self.__pyCadApplication=Application()
    for command in self.__pyCadApplication.getCommandList():
        self.__command[command]=self.performCommand
</t>
<t tx="1.20130426141258.2553">def mainLoop(self):
    """
        mainLoop operation
    """
    while 1:
        imputstr=self.inputMsg("Insert a command (? for Help)")
        try:
            if imputstr in self.__command:
                self.__command[imputstr](imputstr)
            elif imputstr in self.__applicationCommand:
                self.__applicationCommand[imputstr]()
            else:
                self.outputMsg("Wrong Command !!")
        except EntityMissing as err:
            self.outputMsg("Application Error %s "%str(err))
</t>
<t tx="1.20130426141258.2554">def printHelp(self):            
    """
        print the command list
    """
    self.outputMsg("*****************************Drawing")
    for commandName in self.__command:
        self.outputMsg("Comand : %s "%str(commandName))
    self.outputMsg("**************************Application Command")
    for commandName in self.__applicationCommand:
        self.outputMsg("Comand : %s "%str(commandName))
</t>
<t tx="1.20130426141258.2555">def getEnts(self):
    """
        get database entitys
    """
    try:
        type=self.inputMsg("Witch Type ?")
        if not type:
            type="ALL"
        startTime=time.clock()
        activeDoc=self.__pyCadApplication.ActiveDocument
        if activeDoc == None:
            self.outputMsg("No Object opened")
            return
            
        ents=activeDoc.getEntityFromType(type)
        endTime=time.clock()-startTime       
        self.printEntity(ents)
        self.outputMsg("Exec query get %s ent in %s s"%(str(len(ents)), str(endTime)))
        self.outputMsg("********************************")
    except:
        self.outputMsg("Unable To Perform the getEnts")   
</t>
<t tx="1.20130426141258.2556">def printEntity(self, ents):
    """
        print a query result
    """
    i=0
    for e in ents:
        self.outputMsg("Entity Type %s id %s "%(str(e.eType),str(e.getId())))
        if i &gt; 100:
            self.outputMsg("There are more then 100 entitys in the select so i stop printing")
            break
        i+=1
</t>
<t tx="1.20130426141258.2557">def newDoc(self):
    """
        create a new document
    """
    try:
        self.__pyCadApplication.newDocument(None)
    except (IOError, EmptyFile):
        self.outputMsg("Unable To open the file %s"%str(filePath))
</t>
<t tx="1.20130426141258.2558">def createStyle(self):        
    """
        create a new style object
    """
    styleName=self.inputMsg("Write style name")
    stl=Style(styleName)
    doc=self.__pyCadApplication.ActiveDocument
    doc.saveEntity(stl);
</t>
<t tx="1.20130426141258.2559">def getActiveDoc(self):            
    """
        print the active document
    """ 
    try:
        doc=self.__pyCadApplication.ActiveDocument
        self.outputMsg("Active Document is %s"%str(doc.dbPath))
    except:
        self.outputMsg("Unable To Perform the getActiveDoc") 
</t>
<t tx="1.20130426141258.2560">def setActiveDoc(self):
    """
        set the active docuement
    """
    try:
        lookIndex=self.inputMsg("Write the number of doc that you are looking for")
        i=0
        docs=self.__pyCadApplication.getDocuments()
        if len(docs)&lt;int(lookIndex):
            self.outputMsg("No such a document")
            return
        for key in docs:
            if i == int(lookIndex):
                self.__pyCadApplication.ActiveDocument=docs[key]
                return
            i+=1
        else:
            self.outputMsg("Document not found") 
    except:
        self.outputMsg("Unable To Perform the setActiveDoc") 
</t>
<t tx="1.20130426141258.2561">def showDocuments(self):
    """
        show The list of documents
    """
    try:
        self.outputMsg("Documents in the curret application")
        i=0
        for key in self.__pyCadApplication.getDocuments():
            self.outputMsg("%s File %s"%(str(i), str(key)))
            i+=1
        self.outputMsg("***********************************")
    except:
        self.outputMsg("Unable To Perform the GetDocuments")
</t>
<t tx="1.20130426141258.2562">def closeFile(self):
    """
        close the active Document
    """
    try:
        acDoc=self.__pyCadApplication.getActiveDocuemnt()
        self.__pyCadApplication.closeDocument(acDoc.dbFile)
    except:
        self.outputMsg("Unable To close the active document")
</t>
<t tx="1.20130426141258.2563">def openFile(self):
    """
        open a new document
    """
    try:
        filePath=self.inputMsg("File Path")
        self.__pyCadApplication.openDocument(filePath)
    except IOError:
        self.outputMsg("Unable To open the file %s"%str(filePath))
</t>
<t tx="1.20130426141258.2564">def endApplication(self):
    """
        close the application
    """
    self.outputMsg("Bye")
    sys.exit(0)
</t>
<t tx="1.20130426141258.2565">def performCommand(self,name):
    """
        Perform a Command
    """
    try:
        cmd_Key=str(name).upper()
        cObject=self.__pyCadApplication.getCommand(cmd_Key)
        for iv in cObject:
            exception,message=iv
            try:
                raise exception(None)
            except ExcPoint:
                cObject[iv]=self.imputPoint(message)                    
            except (ExcLenght, ExcAngle):
                cObject[iv]=self.inputFloat(message)
            except (ExText):
                cObject[iv]=self.inputMsg(message)
            except (ExEntity):
                cObject[iv]=self.inputInt(message)
            except:
                print("Bad error !!")
                raise 
        else:
            cObject.applyCommand()
    except PyCadWrongCommand:
        self.outputMsg("Wrong Command")
</t>
<t tx="1.20130426141258.2566">def featureTest(self):
    """
        this function make a basic test
    """
    self.outputMsg("Create a new document 1")
    doc1=self.__pyCadApplication.newDocument()
    self.outputMsg("Create a new document 2")
    doc2=self.__pyCadApplication.newDocument()
    self.outputMsg("Set Current p1")
    self.__pyCadApplication.ActiveDocument=doc1
    self.outputMsg("Create Point")
    self.performCommandRandomly("POINT")
    self.outputMsg("Create Segment")
    self.performCommandRandomly("SEGMENT")
    self.outputMsg("Create Arc")
    self.performCommandRandomly("ARC")
    self.__pyCadApplication.ActiveDocument=doc2
    self.outputMsg("Create Ellipse")
    self.performCommandRandomly("ELLIPSE")
    self.outputMsg("Create Polyline")
    self.performCommandRandomly("POLYLINE")
    self.outputMsg("Create ACLine")
    self.performCommandRandomly("ACLINE")
    
    self.outputMsg("Get Entitys for doc 1")
    self.__pyCadApplication.ActiveDocument=doc1
    activeDoc=self.__pyCadApplication.ActiveDocument
    ents=activeDoc.getEntityFromType("ALL")
    self.printEntity(ents)
    self.outputMsg("Get Entitys for doc 2")
    self.__pyCadApplication.ActiveDocument=doc2
    activeDoc=self.__pyCadApplication.ActiveDocument
    ents=activeDoc.getEntityFromType("ALL")
    self.printEntity(ents)
    # Working with styles
    self.outputMsg("Create NewStyle")
    stl=Style("NewStyle")
    self.outputMsg("Save in document")
    activeDoc.saveEntity(stl)
    activeDoc.setActiveStyle(name='NewStyle')
    self.outputMsg("Create Segment")
    self.performCommandRandomly("SEGMENT")
    self.outputMsg("Create Arc")
    self.performCommandRandomly("ARC")
    
    self.outputMsg("Create NewStyle1")
    stl1=Style("NewStyle1")
    self.__pyCadApplication.setApplicationStyle(stl1)
    stl11=self.__pyCadApplication.getApplicationStyle(name='NewStyle1')
    styleDic=stl11.getConstructionElements()
    styleDic[list(styleDic.keys())[0]].setStyleProp('entity_color',(255,215,000))
    self.__pyCadApplication.setApplicationStyle(stl11)
    activeDoc.saveEntity(stl11)
    self.outputMsg("Create Segment")
    self.performCommandRandomly("SEGMENT")
    self.outputMsg("Create Arc")
    self.performCommandRandomly("ARC")
    
    self.outputMsg("Create NewStyle2 ")
    stl1=Style("NewStyle2")
    stl12=activeDoc.saveEntity(stl1)
    styleDic=stl11.getConstructionElements()
    styleDic[list(styleDic.keys())[0]].setStyleProp('entity_color',(255,215,000))
    self.outputMsg("Update NewStyle2")
    activeDoc.saveEntity(stl12)
    self.outputMsg("Done")
    # Test  Geometrical chamfer ent
    self.GeotestChamfer()
    # Test Chamfer Command 
    self.testChamferCommand()
</t>
<t tx="1.20130426141258.2567">def testGeoChamfer(self):    
    self.outputMsg("Test Chamfer")
    p1=Point(0.0, 0.0)
    p2=Point(10.0, 0.0)
    p3=Point(0.0, 10.0)
    s1=Segment(p1, p2)
    s2=Segment(p1, p3)
    cmf=Chamfer(s1, s2, 2.0, 2.0)
    cl=cmf.getLength()
    self.outputMsg("Chamfer Lengh %s"%str(cl))
    s1, s2, s3=cmf.getReletedComponent()
    if s3:
        for p in s3.getEndpoints():
            x, y=p.getCoords()
            self.outputMsg("P1 Cords %s,%s"%(str(x), str(y)))
    else:
        self.outputMsg("Chamfer segment in None")
</t>
<t tx="1.20130426141258.2568">def testChamferCommand(self):
    """
        this function is usefoul for short test
        as soon it works copy the code into featureTest
    """
    newDoc=self.__pyCadApplication.newDocument()
    intPoint=Point(0.0, 0.0)
    
    s1=Segment(intPoint, Point(10.0, 0.0))
    s2=Segment(intPoint, Point(0.0, 10.0))
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
   
    cObject=self.__pyCadApplication.getCommand("CHAMFER")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=2
    cObject[keys[3]]=2
    cObject[keys[4]]=None
    cObject[keys[5]]=None
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2569">def easyTest(self):
    """
        this function is usefoul for short test
        as soon it works copy the code into featureTest
    """
    pass
    newDoc=self.__pyCadApplication.newDocument()
    intPoint=Point(2.0, 2.0)
    
    s1=Segment(intPoint, Point(10.0, 0.0))
    s2=Segment(intPoint, Point(0.0, 10.0))
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
   
    cObject=self.__pyCadApplication.getCommand("CHAMFER")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=2
    cObject[keys[3]]=2
    cObject[keys[4]]=None
    cObject[keys[5]]=None
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2570">def performCommandRandomly(self, commandName, andLoop=10):
    """
        set some random Value at the command imput
    """
    self.outputMsg("Start Command %s"%str(commandName))
    i=0
    cObject=self.__pyCadApplication.getCommand(commandName)
    for iv in cObject:
        exception,message=iv
        try:
            raise exception(None)
        except ExcPoint:
            self.outputMsg("Add Point")
            if i&gt;=andLoop:
                cObject[iv]=None
            else:
                cObject[iv]=self.getRandomPoint()
        except (ExcLenght, ExcAngle):
            self.outputMsg("Add Lengh/Angle")
            cObject[iv]=100
        except:
            self.outputMsg("Bad error !!")
            raise 
        i+=1
    else:
        self.outputMsg("Apply Command")
        cObject.applyCommand()
</t>
<t tx="1.20130426141258.2571">def getRandomPoint(self):
    """
        get e random point
    """
    x=random()*1000
    y=random()*1000
    #print("x is ", x, "y is ", y)
    return Point(x, y)
</t>
<t tx="1.20130426141258.2572">def inputInt(self, msg):   
    """
        return an int from user
    """        
    value=self.inputMsg(msg)
    if value:
        return int(value)
    return None
</t>
<t tx="1.20130426141258.2573">def inputFloat(self, msg):
    """
        return a float number
    """
    value=self.inputMsg(msg)
    if value:
        return float(value)
    return None
</t>
<t tx="1.20130426141258.2574">def imputPoint(self, msg):
    """
        ask at the user to imput a point 
    """
    msg=msg + " x,y "
    value=self.inputMsg(msg)
    if value:
        coords=value.split(',')
        x=float(coords[0])
        y=float(coords[1])
        return Point(x, y)
    return None
</t>
<t tx="1.20130426141258.2575">def outputMsg(self,msg):
    """
        print an output message
    """
    print("""&lt;PythonCad&gt; %s"""%(str(msg)))
</t>
<t tx="1.20130426141258.2576">def inputMsg(self,msg):
    """
        print and ask for a value
    """
    msg="""&lt;PythonCad&gt; %s &gt;&gt;&gt;"""%(str(msg))
    return input(msg)
</t>
<t tx="1.20130426141258.2578"></t>
<t tx="1.20130426141258.2785"></t>
<t tx="1.20130426141258.2786">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2787">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
from Kernel.GeoEntity.arc              import Arc
</t>
<t tx="1.20130426141258.2788">class ArcCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2789">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght, ExcAngle, ExcAngle]
    self.defaultValue=[None, 10, 0, math.pi*2]
    self.message=["Give Me the Center Point: ", 
                    "Give Me the Radius: ", 
                    "Give Me the Start Angle [Create a circle]: ", 
                    "Give Me the Span Angle: "]
</t>
<t tx="1.20130426141258.2790">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    self.applyDefault()
    arg={"ARC_0":self.value[0], 
            "ARC_1":self.value[1], 
            "ARC_2":self.value[2], 
            "ARC_3":self.value[3]
            }    
    arc=Arc(arg)
    self.document.saveEntity(arc)
</t>
<t tx="1.20130426141258.2791">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide basic command function
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2792">from Kernel.exception           import *
from Kernel.unitparser          import *
from Kernel.GeoEntity.point     import Point
</t>
<t tx="1.20130426141258.2793">class BaseCommand(object):
    """
        this class provide a base command
    """
    @others
</t>
<t tx="1.20130426141258.2794">def __init__(self, document):
    """
        kernel is a PyCadKernel object
    """
    self.exception=[]
    self.value=[]
    self.message=[]
    self.defaultValue=[]
    self.index=0
    self.document=document
    self.automaticApply=True
    self.autorestart=True
</t>
<t tx="1.20130426141258.2795">def __iter__(self):
    return self
</t>
<t tx="1.20130426141258.2796">def __setitem__(self, key, value):
    """
        set the value of the command
    """
    if not isinstance(value, tuple) or len(value)!=5:
        raise PyCadWrongImputData("BaseCommand : Wrong value provide a good tuple (point,entity,distance)")
    value=self.translateCmdValue(value)
    if value==None:
        raise PyCadWrongImputData("BaseCommand : Wrong imput parameter for the command")
    self.value.append(value)
</t>
<t tx="1.20130426141258.2797">def resetToDefault(self):
    """
        Reset the command to default value
    """
    self.value=[]
    for val in self.defaultValue:
        self.value.append(val)
</t>
<t tx="1.20130426141258.2798">def applyDefault(self):
    i=0
    for value in self.value:
        if self.value[i]==None:
            self.value[i]=self.defaultValue[i]
        i+=1
    for i in range(i,self.lenght):
        self.value.append(self.defaultValue[i])
</t>
<t tx="1.20130426141258.2799">def reset(self):
    """
        reset the command
    """
    self.index=0
    self.value=[]
</t>
<t tx="1.20130426141258.2800">@property
def valueIndex(self):
    """
        get the index of the insert value in the command
    """
    return len(self.value)
</t>
<t tx="1.20130426141258.2801">def __next__(self):
    """
        go on with the iteration
    """
    self.index+=1
    TotNIter=len(self.exception)
    if self.index&gt;=TotNIter:
        raise StopIteration
    return (self.exception[self.index],self.message[self.index])
</t>
<t tx="1.20130426141258.2802">def activeException(self):
    """
        Return the active exception
    """
    return self.exception[self.index]
</t>
<t tx="1.20130426141258.2803">@property
def activeMessage(self):
    """
        get Active message
    """
    if len(self.message)&gt;self.index:
        return self.message[self.index]
    else:
        return "Press enter to execute the command"
</t>
<t tx="1.20130426141258.2804">def performDefaultValue(self):
    """
        perform the default value
    """
    if self.activeDefaultValue()!=None:
        self.value.append(self.activeDefaultValue())
    else:
        raise NoDefaultValue("No default value is possible for the active command")
</t>
<t tx="1.20130426141258.2805">def activeDefaultValue(self):
    """
        Return the active default value
    """
    return self.defaultValue[self.index]
</t>
<t tx="1.20130426141258.2806">def getActiveDefaultValue(self):
    """
        get the default value for the active command input
    """
    if self.index&gt;=0 and self.index&lt;=len(self.defaultValue)-1:
        return self.defaultValue[self.index]
    else:
        return None
</t>
<t tx="1.20130426141258.2807">def previus(self):
    """
        came back with the iteration
    """
    self.index-=1
    if self.index&lt;0:
        self.index=0
    return (self.exception[self.index],self.message[self.index])
</t>
<t tx="1.20130426141258.2808">def keys(self):
    """
        return all the exception key
    """
    return self.exception
</t>
<t tx="1.20130426141258.2809">@property
def lenght(self):
    """
        get the number of command input value that the user have to provide
    """
    return len(self.exception)
</t>
<t tx="1.20130426141258.2810">def applyCommand(self):
    """
        this method here must be defined
    """
    pass
</t>
<t tx="1.20130426141258.2811">def translateCmdValue(self , value):
    """
        translate the imput value based on exception
    """
    point, entitys, distance, angle , text=value
    exitValue=None
    try:
        raise self.activeException()(None)
    except ExcPoint:
        exitValue=point
    except ExcEntity:
        if entitys:
            exitValue=str(entitys[0].ID)
    except ExcMultiEntity:
        exitValue=self.getIdsString(entitys)
    except ExcEntityPoint:
        if entitys:
            exitValue=(str(entitys[0].ID), point)
    except (ExcLenght):
        if distance:
            exitValue=self.convertToFloat(distance)
    except(ExcAngle):
        if angle:
            exitValue=convertAngle(angle)
        elif distance:
            exitValue=distance
        else:
            p0=Point(0.0, 0.0)
            x, y=point.getCoords()
            p1=Point(x, y)
            exitValue=Vector(p0, p1).absAng
    except(ExcInt):
        exitValue=self.convertToInt(distance)
    except(ExcText):
        exitValue=text
        if text==None:
            exitValue=""
    except(ExcBool):
        if text=="TRUE":
            exitValue=True
        else:
            exitValue=False
    except(ExcDicTuple):
        exitValue=text
    except:
        raise PyCadWrongImputData("BaseCommand : Wrong imput parameter for the command")
    finally: return exitValue
</t>
<t tx="1.20130426141258.2812">def getIdsString(self, selectedItems):
    """
        get the selected entity in terms of ids
    """
    text=None
    for ent in selectedItems:
        if not text:
            text=''
            text+=str(ent.ID)
        else:
            text+=","+str(ent.ID)
    return text
</t>
<t tx="1.20130426141258.2813">def convertToBool(self, msg):
    """
        return an int from user
    """
    if msg=="Yes":
        return True
    else:
        return False
</t>
<t tx="1.20130426141258.2814">def convertToInt(self, msg):
    """
        return an int from user
    """
    if msg:
        return int(convertLengh(msg))
    return None
</t>
<t tx="1.20130426141258.2815">def convertToFloat(self, msg):
    """
        return a float number
    """
    if msg:
        return convertLengh(msg)
    return None
</t>
<t tx="1.20130426141258.2816">def convertToAngle(self, msg):
    """
        convert the angle using sympy
    """
    if msg:
        p=convertAngle(msg)
        return p
    return None
</t>
<t tx="1.20130426141258.2817">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the bisector command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2818">from Kernel.exception                      import *
from Kernel.composedentity                 import ComposedEntity
from Kernel.Command.basecommand            import *
from Kernel.GeoComposedEntity.bisector     import Bisector
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoUtil.util                    import getIdPoint
</t>
<t tx="1.20130426141258.2819">class BisectorCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2820">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcLenght]
    self.defaultValue=[None, None, 100]
    self.message=[  "Select the First Segment: ", 
                    "Select the Second Segment: ", 
                    "Give me the Bisector Lengh: "]
</t>
<t tx="1.20130426141258.2821">def getEntsToSave(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2":p0, 
         "OBJECTJOINT_3":p1, 
         "OBJECTJOINT_5":self.value[2], 
         }

    cmf=Bisector(arg)
    bisectorSegment = cmf.getReletedComponent()
    objEnt.append(bisectorSegment)
    return objEnt
</t>
<t tx="1.20130426141258.2822">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of input parameters")
    for _ent in self.getEntsToSave():
        self.document.saveEntity(_ent)
</t>
<t tx="1.20130426141258.2823">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2824">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.ccircle          import CCircle
</t>
<t tx="1.20130426141258.2825">class CCircleCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2826">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght]
    self.defaultValue=[None, 10]
    self.message=["Give Me the center Point", "Give Me the radius"]
</t>
<t tx="1.20130426141258.2827">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={
         "CCIRCLE_0":self.value[0], 
         "CCIRCLE_1":self.value[1]
         }
    ccircle=CCircle(arg)
    self.document.saveEntity(ccircle)
</t>
<t tx="1.20130426141258.2828">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the champfer command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2829">from Kernel.exception                       import *
from Kernel.composedentity                  import ComposedEntity
from Kernel.Command.basecommand             import *
from Kernel.GeoComposedEntity.chamfer       import Chamfer
from Kernel.GeoEntity.segment               import Segment
from Kernel.GeoUtil.util                    import getIdPoint
</t>
<t tx="1.20130426141258.2830">class ChamferCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2831">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcText , 
                    ExcLenght, 
                    ExcLenght 
                    ]
    self.defaultValue=[None, None, "BOTH", 10, 10]
    self.message=[  "Select the First entity: ", 
                    "Select the Second entity: ", 
                    "Give me trim Mode (FIRST,SECOND,BOTH,NO_TRIM) [BOTH]: ", 
                    "Give me the first Chamfer Lenght: ", 
                    "Give me the second Chamfer Lenght: ", 
                    ]
</t>
<t tx="1.20130426141258.2832">def getEntsToSave(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
   
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2":p0, 
         "OBJECTJOINT_3":p1, 
         "OBJECTJOINT_4":self.value[2], 
         "OBJECTJOINT_5":self.value[3], 
         "OBJECTJOINT_6":self.value[4]
         }

    cmf=Chamfer(arg)
    seg1Mod, seg2Mod, chamferSegment = cmf.getReletedComponent()
    
    _cElements1, entityType=self.document._getCelements(seg1Mod)
    _cElements2, entityType=self.document._getCelements(seg2Mod)
   
    ent1.setConstructionElements(_cElements1)
    ent2.setConstructionElements(_cElements2)
    
    objEnt.append(ent1)
    objEnt.append(ent2)
    objEnt.append(chamferSegment)
    return objEnt
</t>
<t tx="1.20130426141258.2833">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=5:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2834">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2835">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
from Kernel.GeoEntity.arc              import Arc
</t>
<t tx="1.20130426141258.2836">class CircleCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2837">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght]
    self.defaultValue=[None, 10, 0, math.pi*2]
    self.message=["Give Me the center Point", 
                    "Give Me the radius"]
</t>
<t tx="1.20130426141258.2838">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    self.applyDefault()
    arg={"ARC_0":self.value[0], 
            "ARC_1":self.value[1], 
            "ARC_2":0, 
            "ARC_3":math.pi*2
            }    
    arc=Arc(arg)
    self.document.saveEntity(arc)
</t>
<t tx="1.20130426141258.2839">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2840">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.cline           import CLine
</t>
<t tx="1.20130426141258.2841">class CLineCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2842">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.message=["Give Me the first Point","Give Me the first Point"]
</t>
<t tx="1.20130426141258.2843">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={"CLINE_0":self.value[0],"CLINE_0":self.value[1] }
    cline=CLine(arg)
    self.document.saveEntity(cline)
</t>
<t tx="1.20130426141258.2844">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the move command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2845">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.arc           import Arc
</t>
<t tx="1.20130426141258.2846">class CopyCommand(BaseCommand):
    """
        this class rappresent the Move command
    """
    @others
</t>
<t tx="1.20130426141258.2847">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint,
                    ExcPoint]
    self.defaultValue=[None, None,None]
    self.message=[  "Select Entities to copy: ",
                    "Give me the Base Point: ",
                    "Give me the Destination Point: "]
</t>
<t tx="1.20130426141258.2848">def getEntsToSave(self):
    """
       get entity to save
    """
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.move(self.value[1], self.value[2])
        updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2849">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2850">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Trim command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2851">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity               import *
from Kernel.GeoUtil.intersection    import *
from Kernel.GeoUtil.util            import *
</t>
<t tx="1.20130426141258.2852">class DeleteCommand(BaseCommand):
    """
        this class rappresent the Trim command
    """
    @others
</t>
<t tx="1.20130426141258.2853">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity]
    self.message=["Select Entities to be Deleted: "]
</t>
<t tx="1.20130426141258.2854">def applyDefault(self):    
    """
        aver written to  avoid apply default in this command
    """
    return
</t>
<t tx="1.20130426141258.2855">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for id in str(self.value[0]).split(','):
            self.document.deleteEntity(id)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2856">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2857">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoUtil.geolib          import Vector
from Kernel.GeoEntity.dimension     import Dimension
</t>
<t tx="1.20130426141258.2858">class DimensionCommand(BaseCommand):
    """
        This class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2859">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint,ExcPoint,ExcPoint, ExcAngle]
    self.defaultValue=[None, None, None, 0]
    self.message=["Give Me The First Point: ",
                    "Give Me The Second Point: ",
                    "Give Me Dimesion Position: ", 
                    "Give Me The Orientation Angle"]   # what does it mean???
</t>
<t tx="1.20130426141258.2860">@property
def getAngle(self):
    """
        Calculate the angle based on the starting and ending point
    """
    v=Vector(self.value[0], self.value[1])
    return v.absAng
</t>
<t tx="1.20130426141258.2861">def applyCommand(self):
    if len(self.value)==3: #assing the angle
        self.value.append(self.getAngle)
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    dimArgs={"DIMENSION_1":self.value[0], 
                "DIMENSION_2":self.value[1], 
                "DIMENSION_3":self.value[2], 
                "DIMENSION_4":self.value[3]}
    dimension=Dimension(dimArgs)
    self.document.saveEntity(dimension)
</t>
<t tx="1.20130426141258.2862">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the ellipse command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2863">from Kernel.exception                   import *
from Kernel.Command.basecommand         import *
from Kernel.GeoEntity.ellipse          import Ellipse
</t>
<t tx="1.20130426141258.2864">class EllipseCommand(BaseCommand):
    """
        this class rappresent the ellips command
    """
    @others
</t>
<t tx="1.20130426141258.2865">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght, ExcLenght]
    self.defaultValue=[None, 100, 50]
    self.message=["Give Me the Center Point (We know input sequence is at the moment very odd, sorry.): ", "Give Me First Axis Lenght: ", "Give Me Second Axis Half Lenght: "]
</t>
<t tx="1.20130426141258.2866">def applyCommand(self):
    if len(self.value)&gt;3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={"ELLIPSE_0":self.value[0], "ELLIPSE_1":self.value[1], "ELLIPSE_2":self.value[2]}
    ellipse=Ellipse(arg)
    self.document.saveEntity(ellipse)
</t>
<t tx="1.20130426141258.2867">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the fillet command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2868">from Kernel.exception                      import *
from Kernel.composedentity                 import ComposedEntity
from Kernel.Command.basecommand            import *
from Kernel.GeoComposedEntity.fillet       import Fillet
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoUtil.util                   import getIdPoint
</t>
<t tx="1.20130426141258.2869">class FilletCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2870">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcText, 
                    ExcLenght]
    self.defaultValue=[None, None,"BOTH",10]
    self.message=[  "Select the First Entity: ", 
                    "Select the Second Entity: ", 
                    "Give me Trim Mode (FIRST,SECOND,BOTH,NO_TRIM) [BOTH]: ", 
                    "Give me the radius [10]: " 
                    ]
</t>
<t tx="1.20130426141258.2871">def getEntsToSave(self):
    """
        get the fillet segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2": p0, 
         "OBJECTJOINT_3": p1, 
         "OBJECTJOINT_4":self.value[2], 
         "OBJECTJOINT_5":self.value[3]
         }

    fillet=Fillet(arg)
    seg1Mod, seg2Mod, filletArc = fillet.getReletedComponent()
    
    _cElements1, entityType=self.document._getCelements(seg1Mod)
    _cElements2, entityType=self.document._getCelements(seg2Mod)
   
    ent1.setConstructionElements(_cElements1)
    ent2.setConstructionElements(_cElements2)
    
    objEnt.append(ent1)
    objEnt.append(ent2)
    
    objEnt.append(filletArc)
    return objEnt
</t>
<t tx="1.20130426141258.2872">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2873">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the polyline command
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2874">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point            import Point
</t>
<t tx="1.20130426141258.2875">class MirrorCommand(BaseCommand):
    """
        This class rappresent the mirror command
    """
    @others
</t>
<t tx="1.20130426141258.2876">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcEntity, 
                    ExcText]
    self.defaultValue=[None, None, "C"]
    self.message=[  "Select the entity to mirror or give me a the keyword Text As: (10,20,30,...)", 
                    "Select the reference line ", 
                    "Move or Copy? [M]: "]
</t>
<t tx="1.20130426141258.2877">def performMirror(self):
    """
        perform the mirror of all the entity selected
    """
    move=True
    if self.value[2]:
        if self.value[2].upper()=='C':
            move=False
    mirrorRef=self.document.getEntity(self.value[1])
    geoMirrorRef=self.document.convertToGeometricalEntity(mirrorRef)
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.mirror(geoMirrorRef)
        if move:
            dbEnt.setConstructionElements(geoEnt.getConstructionElements())
            updEnts.append(dbEnt)
        else:
            updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2878">def applyCommand(self):
    """
        perform the write of the entity
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.performMirror():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2879">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the move command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2880">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.arc           import Arc
</t>
<t tx="1.20130426141258.2881">class MoveCommand(BaseCommand):
    """
        this class rappresent the Move command
    """
    @others
</t>
<t tx="1.20130426141258.2882">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint, 
                    ExcPoint]
    self.defaultValue=[None, None,None]
    self.message=[  "Select Entities to Move: ", 
                    "Give me the Base Point: ",
                    "Give me the Destination Point: "]
</t>
<t tx="1.20130426141258.2883">def getEntsToSave(self):
    """
       get entity to save
    """
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.move(self.value[1], self.value[2])
        dbEnt.setConstructionElements(geoEnt.getConstructionElements())
        updEnts.append(dbEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2884">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2885">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the point command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2886">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2887">class PointCommand(BaseCommand):
    """
        this class rappresent the point command
    """
    @others
</t>
<t tx="1.20130426141258.2888">def __init__(self, kernel):
    BaseCommand.__init__(self, kernel)
    self.exception=[ExcPoint]
    self.defaultValue=[None]
    self.message=["Give Me the Point Position: "]
</t>
<t tx="1.20130426141258.2889">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of input parameter")
    point=Point(self.value[0])
    self.document.saveEntity(point)
</t>
<t tx="1.20130426141258.2890">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Polygon command
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2891">import math
import array

from Kernel.exception                   import *
from Kernel.Command.basecommand         import *
from Kernel.GeoEntity.point             import Point
from Kernel.GeoEntity.segment           import Segment
</t>
<t tx="1.20130426141258.2892">class PolygonCommand(BaseCommand):
    """
        A specialized to for creating Polygons from Segments.
        The PolygonTool will create an uniformly sized polygon from Segment
        entities. The minimum number of sides is three, creating an equilateral
        triangle. There is no maximum number of sides, though realistically any
        polygon with more than 20 or so sides is unlikely to be drawn.
    """
    @others
</t>
<t tx="1.20130426141258.2893">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, 
                    ExcPoint, 
                    ExcInt, 
                    ExcText]
    self.defaultValue=[None, None,6,"I"]
    self.message=["Give Me the Polygon Center Point: ",
                    "Give Me a Point to Define Circumference: ", 
                    "Give Me The Number of Sides: ", 
                    "Inscribed or Circumscribed [I]: "]
    self.__xpts = array.array("d")
    self.__ypts = array.array("d")
    self.__increment=0.0 #default value
</t>
<t tx="1.20130426141258.2894">@property
def side(self):
    """
        Get the number of sides of the polygon to be created.
        A ValueError exception is raised if the side count has not been
        set with setSideCount()
    """
    if self.value[2] is None:
        raise ValueError("No side count defined.")
    return int(self.value[2])
</t>
<t tx="1.20130426141258.2895">@side.setter
def side(self, value):
    self.value[2]=value
</t>
<t tx="1.20130426141258.2896">def updateSide(self):
    """
        Set the number of sides of the polygon to create.
        Argument "count" should be an integer value greater than 2.
    """
    self.__increment = (math.pi*2)/float(self.side)
    for i in range(self.side):
        self.__xpts.insert(i, 0.0)
        self.__ypts.insert(i, 0.0)
</t>
<t tx="1.20130426141258.2897">@property
def external(self):
    """
        Test if the polygon will be created outside a circle.
        If the setExternal() method has been called, this method will
        return True. By default this method will return False.
    """
    return self.value[3]
</t>
<t tx="1.20130426141258.2898">@external.setter
def external(self, value):
    """
        Create the polygon on the outside of a reference circle.
        By default the polygon is drawing completely contained within a
        circle. Invoking this method will created the polygon so that all
        sides are outside the circle.
    """
    if value=="I":
        self.value[3] = True
    else:
        self.value[3] = False
</t>
<t tx="1.20130426141258.2899">@property  
def externalPick(self):
    """
        get user external pick
    """
    return self.value[1]
</t>
<t tx="1.20130426141258.2900">@externalPick.setter
def externalPick(self, value):
    """
        get user external pick
    """
    self.value[1]=value
</t>
<t tx="1.20130426141258.2901">@property
def center(self):
    """
        Retrieve the center of the polygon to be created.
    """
    if self.value[0] is None:
        raise ValueError("Center is undefined.")
    return self.value[0]
</t>
<t tx="1.20130426141258.2902">@center.setter
def center(self, p):
    """
        Define the center of the polygon.
        Arguments 'x' and 'y' should be float values.
    """
    if self.value[0] and p ==None:
        return
    if isinstance(p, Point):
        self.value[0] = p
    else:
        raise TypeError("p must be a of type Point")
</t>
<t tx="1.20130426141258.2903">def getCoord(self, i):
    """
        Get one of the coordinates of the polygon corners.
        Argument "i" should be an integer value such that:
        0 &lt;= i &lt;= number of polygon sides
    """
    _x = self.__xpts[i]
    _y = self.__ypts[i]
    return _x, _y
</t>
<t tx="1.20130426141258.2904">def CalculatePoint(self):
    """
        This method calculates the polygon
        points.
    """
    if self.value[3].upper()=="C":
        _offset = self.__increment/2.0
    elif self.value[3].upper()=="I":
        _offset = 0.0
    _cx, _cy = self.center.getCoords()
    _x, _y = self.externalPick.getCoords()
    _xsep = _x - _cx
    _ysep = _y - _cy
    _angle = math.atan2(_ysep, _xsep) + _offset
    _rad = math.hypot(_xsep, _ysep)/math.cos(_offset)
    _xp = self.__xpts
    _yp = self.__ypts
    for _i in range(self.side):
        _xp[_i] = _cx + (_rad * math.cos(_angle))
        _yp[_i] = _cy + (_rad * math.sin(_angle))
        _angle = _angle + self.__increment
    self.__xpts=_xp
    self.__ypts=_yp
</t>
<t tx="1.20130426141258.2905">def getEntsToSave(self):
    """
        return a list of segment
    """
    objEnt=[]
    self.CalculatePoint()
    if len(self.__xpts):
        # find starting point ...
        _p0 = Point(self.__xpts[0],self.__ypts[0])
        # make segments for all the points ...
        _p1 = _p0
        for _i in range(1, self.side):
            _x = self.__xpts[_i]
            _y = self.__ypts[_i]
            _pi = Point(_x, _y)
            segArg={"SEGMENT_0":_p1, "SEGMENT_1":_pi}
            objEnt.append(Segment(segArg))
            _p1 = _pi
        # now add closing segment ...
        segArg={"SEGMENT_0":_p1, "SEGMENT_1":_p0}
        objEnt.append(Segment(segArg))
    return  objEnt   
</t>
<t tx="1.20130426141258.2906">def applyCommand(self):
    """
        Create a Polygon from Segments and add it to the kernel.
    """
    self.updateSide()
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2907">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the polyline command
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2908">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.polyline         import Polyline
from Kernel.GeoEntity.point            import Point
</t>
<t tx="1.20130426141258.2909">class PolylineCommand(BaseCommand):
    """
        this class rappresent the polyline command
    """
    @others
</t>
<t tx="1.20130426141258.2910">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint]
    self.defaultValue=[None]
    self.message=["Give Me A Point: "]
    self.raiseStop=False
    self.automaticApply=False #In case of polyline we need to stop the automatic apply
</t>
<t tx="1.20130426141258.2911">def __setitem__(self, key, value):
    """
        overwrite the command to perform the stop operation
    """
    value=self.translateCmdValue(value)
    if isinstance(value, Point):
        self.value.append(value)
        self.exception.append(ExcPoint)
        self.message.append("Give Me A Point")
        self.defaultValue.append(None)
    else:
       self.raiseStop=True
</t>
<t tx="1.20130426141258.2912">def applyCommand(self):
    """
        perform the write of the entity
    """
    i=0
    args={}
    for k in self.value:
       args["POLYLINE_%s"%str(i)]=k
       i+=1
    pline=Polyline(args)
    self.document.saveEntity(pline)
</t>
<t tx="1.20130426141258.2913">@first #!/usr/bin/env python

#
# Copyright (c) 2011 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide a class for the property command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2914">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
</t>
<t tx="1.20130426141258.2915">class PropertyCommand(BaseCommand):
    """
        this class represents the property command
    """
    @others
</t>
<t tx="1.20130426141258.2916">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.autorestart=False
    self.exception=[ExcMultiEntity,ExcDicTuple]
    self.defaultValue=[None]
    self.message=["Select Entities: ", 
                    "Give me the property name and value :('color','green') ", 
                    ]
</t>
<t tx="1.20130426141258.2917">def changeProp(self, _id):    
    """
        change the property at the entity 
    """
    entity=self.document.getEntity(_id)
    style=entity.getInnerStyle()
    style.Derived()
    entity.resetProperty()
    for PropName,PropValue in list(self.value[1].get('property',{}).items()):
        entity.addPropertie(PropName,PropValue)
        #style.setStyleProp(stylePropName,stylePropValue)
    entity.style=self.document.saveEntity(style)   
    self.document.saveEntity(entity)
</t>
<t tx="1.20130426141258.2918">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of input parameter")
    try:
        self.document.startMassiveCreation()
        
        for _id in str(self.value[0]).split(','):
            self.changeProp(_id)
    except Exception as ex:
        raise ex
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2919">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Rectangle command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2920">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point            import Point
from Kernel.GeoEntity.segment          import Segment
</t>
<t tx="1.20130426141258.2921">class RectangleCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2922">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.defaultValue=[None, None]
    self.message=["Give Me the First Corner: ","Give Me the Second Corner: "]
</t>
<t tx="1.20130426141258.2923">def getEntsToSave(self):
    """
        get all the segment of the rectangle
    """
    objEnt=[]
    p1=self.value[0]
    p2=self.value[1]
    x1, y1=p1.getCoords()
    x2, y2=p2.getCoords()
    p3=Point(x1, y2)
    p4=Point(x2, y1)
    segArg={"SEGMENT_0":p1, "SEGMENT_1":p4}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p4, "SEGMENT_1":p2}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p2, "SEGMENT_1":p3}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p3, "SEGMENT_1":p1}
    objEnt.append(Segment(segArg))
    return objEnt
</t>
<t tx="1.20130426141258.2924">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2925">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the rotate command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2926">import math

from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2927">class RotateCommand(BaseCommand):
    """
        this class rappresent the rotate command
    """
    @others
</t>
<t tx="1.20130426141258.2928">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint, 
                    ExcAngle, 
                    ExcText]
    self.defaultValue=[None, None, math.pi/2, "M"]
    self.message=[  "Select Entities: ", 
                    "Give me the Rotation Center Point: ", 
                    "Give me the rotation angle [rad]: ", 
                    "Move or Copy? [M]: "]
</t>
<t tx="1.20130426141258.2929">def performRotation(self):
    """
        perform the mirror of all the entity selected
    """
    copy=True
    if self.value[3]:
        if self.value[3].upper()=='M':
            copy=False
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.rotate(self.value[1], self.value[2])
        if not copy:
            dbEnt.setConstructionElements(geoEnt.getConstructionElements())
            updEnts.append(dbEnt)
        else:
            updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2930">def applyCommand(self):
    """
        perform the write of the entity
    """
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.performRotation():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2931">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2932">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.segment       import Segment
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2933">class SegmentCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2934">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.message=["Give Me the First Point: ","Give Me The Second Point: "]
    self.defaultValue=[None, None]
</t>
<t tx="1.20130426141258.2935">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    segArg={"SEGMENT_0":self.value[0], "SEGMENT_1":self.value[1]}
    seg=Segment(segArg)
    self.document.saveEntity(seg)
</t>
<t tx="1.20130426141258.2936">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2937">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.text             import Text
</t>
<t tx="1.20130426141258.2938">class TextCommand(BaseCommand):
    """
        This class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2939">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcText, ExcAngle,ExcText ]
    self.defaultValue=[None, "Dummy Text", 0, "sw"]
    self.message=["Give Me the Insert Point: ",
                    "Type The Text String: ",
                    "Give Me The Rotation Angle [0]: ", 
                    "Give me a Point to Justify Text [sw]: "]
</t>
<t tx="1.20130426141258.2940">def applyCommand(self):
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    textArgs={"TEXT_0":self.value[0], "TEXT_1":self.value[1], "TEXT_2":self.value[2], "TEXT_3":self.value[3]}
    text=Text(textArgs)
    self.document.saveEntity(text)
</t>
<t tx="1.20130426141258.2941">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Trim command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2942">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity               import *
from Kernel.GeoEntity.segment       import Segment
from Kernel.GeoUtil.intersection    import *
from Kernel.GeoUtil.util            import *
</t>
<t tx="1.20130426141258.2943">class TrimCommand(BaseCommand):
    """
        this class represent the Trim command
    """
    @others
</t>
<t tx="1.20130426141258.2944">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint,  
                    ExcText]
    self.defaultValue=[None, None,"BOTH"]
    self.message=[  "Give me the First Entity: ", 
                    "Give me the Second Entity: ",
                    "Give me The Trim Mode (First,Second,Both)[Both]: "]
</t>
<t tx="1.20130426141258.2945">def performTrim(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    
    updEnts=[]
    geoEnt1=self.document.getEntity(id0)
    seg1=geoEnt1.toGeometricalEntity()
    geoEnt2=self.document.getEntity(id1)
    seg2=geoEnt2.toGeometricalEntity()
    intPoint=findSegmentExtendedIntersectionPoint(seg1, seg2)
    if len(intPoint)&lt;=0:
        raise PythopnCadWarning("No intersection Found") 
    
    def getNearestPoint(pointArray, referencePoint):              
        distance=None
        exitPoint=None
        for p in pointArray:
            if distance==None:
                distance=p.dist(referencePoint)
                exitPoint=p
                continue
            else:
                newDistance=p.dist(exitPoint)
                if newDistance&lt;distance:
                    distance=newDistance
                    exitPoint=p
        return exitPoint 
        
    def getSegmentCelements(obj, pickPoint, intersectionPoint):
        if isinstance(obj, Segment):
            geoEntTrim=None
            geoEntTrim=updateSegment(obj, pickPoint, intersectionPoint)
            _cElements, entityType=self.document._getCelements(geoEntTrim)
            return _cElements
        else:
            return None
        
    if self.value[2].upper()=='FIRST' or self.value[2].upper()=='F' or self.value[2].upper()=='BOTH' or self.value[2].upper()=='B':
        nearestIntersectionPoint=getNearestPoint(intPoint, p0)
        if nearestIntersectionPoint!=None:
            _cElements=getSegmentCelements(seg1, p0,nearestIntersectionPoint)
            if _cElements!= None:
                geoEnt1.setConstructionElements(_cElements)
                updEnts.append(geoEnt1)
        
    if self.value[2].upper()=='SECOND' or self.value[2].upper()=='S' or self.value[2].upper()=='BOTH' or self.value[2].upper()=='B':
        nearestIntersectionPoint=getNearestPoint(intPoint, p1)
        if nearestIntersectionPoint!=None:
            _cElements=getSegmentCelements(seg2, p1,nearestIntersectionPoint)
            if _cElements!= None:
                geoEnt2.setConstructionElements(_cElements)
                updEnts.append(geoEnt2)
    return updEnts
</t>
<t tx="1.20130426141258.2946">def applyCommand(self):
    """
        apply the trim command
    """
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    if len(self.value)==2:
        self.value.append("BOTH")   # TODO: MAKE A GLOBAL VARIABLE TO SET THIS VALUE
                                    # AS A SETTING VALUE
    try:
        self.document.startMassiveCreation()
        for _ent in self.performTrim():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2947">#
# Copyright (c) 2010 Matteo Boscolo
#

#
# this file is needed for Python's import mechanism
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2948">from Kernel.GeoEntity.arc               import Arc
from Kernel.GeoEntity.cline             import CLine
from Kernel.GeoEntity.ellipse           import Ellipse
from Kernel.GeoEntity.ccircle           import CCircle
from Kernel.GeoEntity.polyline          import Polyline
from Kernel.GeoEntity.segment           import Segment
from Kernel.GeoEntity.text              import Text
</t>
<t tx="1.20130426141258.2949"></t>
<t tx="1.20130426141258.3041"></t>
<t tx="1.20130426141258.3050"></t>
<t tx="1.20130426141258.3087"></t>
<t tx="1.20130426141258.3152"></t>
<t tx="1.20130426141258.3427"></t>
<t tx="1.20130426141258.3519"></t>
<t tx="1.20130426141258.3690"></t>
<t tx="1.20130426141258.3748"></t>
<t tx="1.20130426141258.3792"></t>
<t tx="1.20130426141258.3843"></t>
<t tx="1.20130426141258.3863"></t>
<t tx="1.20130426141258.3920"></t>
<t tx="1.20130426141258.4076"></t>
<t tx="1.20130426141258.4106"></t>
<t tx="amd_yen.20130426011410.8753"></t>
<t tx="amd_yen.20130426011410.8754">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd_yen.20130426011410.8755">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd_yen.20130426011410.8908"></t>
<t tx="amd_yen.20130426011410.8909">#!/usr/bin/env python
#
# 來源: https://code.google.com/p/pyeuclid/
# euclid graphics maths module
#
# Copyright (c) 2006 Alex Holkner
# Alex.Holkner@mail.google.com
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 2.1 of the License, or (at your
# option) any later version.
# 
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
# for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

'''euclid graphics maths module

Documentation and tests are included in the file "euclid.txt", or online
at http://code.google.com/p/pyeuclid
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id$'
__revision__ = '$Revision$'

import math
import operator
import types

# Some magic here.  If _use_slots is True, the classes will derive from
# object and will define a __slots__ class variable.  If _use_slots is
# False, classes will be old-style and will not define __slots__.
#
# _use_slots = True:   Memory efficient, probably faster in future versions
#                      of Python, "better".
# _use_slots = False:  Ordinary classes, much faster than slots in current
#                      versions of Python (2.4 and 2.5).
_use_slots = True

# If True, allows components of Vector2 and Vector3 to be set via swizzling;
# e.g.  v.xyz = (1, 2, 3).  This is much, much slower than the more verbose
# v.x = 1; v.y = 2; v.z = 3,  and slows down ordinary element setting as
# well.  Recommended setting is False.
_enable_swizzle_set = False

# Requires class to derive from object.
if _enable_swizzle_set:
    _use_slots = True

# Implement _use_slots magic.
class _EuclidMetaclass(type):
    def __new__(cls, name, bases, dct):
        if '__slots__' in dct:
            dct['__getstate__'] = cls._create_getstate(dct['__slots__'])
            dct['__setstate__'] = cls._create_setstate(dct['__slots__'])
        if _use_slots:
            return type.__new__(cls, name, bases + (object,), dct)
        else:
            if '__slots__' in dct:
                del dct['__slots__']
            return types.ClassType.__new__(types.ClassType, name, bases, dct)

    @classmethod
    def _create_getstate(cls, slots):
        def __getstate__(self):
            d = {}
            for slot in slots:
                d[slot] = getattr(self, slot)
            return d
        return __getstate__

    @classmethod
    def _create_setstate(cls, slots):
        def __setstate__(self, state):
            for name, value in state.items():
                setattr(self, name, value)
        return __setstate__

__metaclass__ = _EuclidMetaclass

class Vector2:
    __slots__ = ['x', 'y']
    __hash__ = None

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __copy__(self):
        return self.__class__(self.x, self.y)

    copy = __copy__

    def __repr__(self):
        return 'Vector2(%.2f, %.2f)' % (self.x, self.y)

    def __eq__(self, other):
        if isinstance(other, Vector2):
            return self.x == other.x and \
                   self.y == other.y
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return self.x == other[0] and \
                   self.y == other[1]

    def __ne__(self, other):
        return not self.__eq__(other)

    def __nonzero__(self):
        return self.x != 0 or self.y != 0

    def __len__(self):
        return 2

    def __getitem__(self, key):
        return (self.x, self.y)[key]

    def __setitem__(self, key, value):
        l = [self.x, self.y]
        l[key] = value
        self.x, self.y = l

    def __iter__(self):
        return iter((self.x, self.y))

    def __getattr__(self, name):
        try:
            return tuple([(self.x, self.y)['xy'.index(c)] \
                          for c in name])
        except ValueError:
            raise AttributeError, name

    if _enable_swizzle_set:
        # This has detrimental performance on ordinary setattr as well
        # if enabled
        def __setattr__(self, name, value):
            if len(name) == 1:
                object.__setattr__(self, name, value)
            else:
                try:
                    l = [self.x, self.y]
                    for c, v in map(None, name, value):
                        l['xy'.index(c)] = v
                    self.x, self.y = l
                except ValueError:
                    raise AttributeError, name

    def __add__(self, other):
        if isinstance(other, Vector2):
            # Vector + Vector -&gt; Vector
            # Vector + Point -&gt; Point
            # Point + Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector2
            else:
                _class = Point2
            return _class(self.x + other.x,
                          self.y + other.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(self.x + other[0],
                           self.y + other[1])
    __radd__ = __add__

    def __iadd__(self, other):
        if isinstance(other, Vector2):
            self.x += other.x
            self.y += other.y
        else:
            self.x += other[0]
            self.y += other[1]
        return self

    def __sub__(self, other):
        if isinstance(other, Vector2):
            # Vector - Vector -&gt; Vector
            # Vector - Point -&gt; Point
            # Point - Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector2
            else:
                _class = Point2
            return _class(self.x - other.x,
                          self.y - other.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(self.x - other[0],
                           self.y - other[1])

   
    def __rsub__(self, other):
        if isinstance(other, Vector2):
            return Vector2(other.x - self.x,
                           other.y - self.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(other.x - self[0],
                           other.y - self[1])

    def __mul__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(self.x * other,
                       self.y * other)

    __rmul__ = __mul__

    def __imul__(self, other):
        assert type(other) in (int, long, float)
        self.x *= other
        self.y *= other
        return self

    def __div__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.div(self.x, other),
                       operator.div(self.y, other))


    def __rdiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.div(other, self.x),
                       operator.div(other, self.y))

    def __floordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.floordiv(self.x, other),
                       operator.floordiv(self.y, other))


    def __rfloordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.floordiv(other, self.x),
                       operator.floordiv(other, self.y))

    def __truediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.truediv(self.x, other),
                       operator.truediv(self.y, other))


    def __rtruediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.truediv(other, self.x),
                       operator.truediv(other, self.y))
    
    def __neg__(self):
        return Vector2(-self.x,
                        -self.y)

    __pos__ = __copy__
    
    def __abs__(self):
        return math.sqrt(self.x ** 2 + \
                         self.y ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.x ** 2 + \
               self.y ** 2

    def normalize(self):
        d = self.magnitude()
        if d:
            self.x /= d
            self.y /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d:
            return Vector2(self.x / d, 
                           self.y / d)
        return self.copy()

    def dot(self, other):
        assert isinstance(other, Vector2)
        return self.x * other.x + \
               self.y * other.y

    def cross(self):
        return Vector2(self.y, -self.x)

    def reflect(self, normal):
        # assume normal is normalized
        assert isinstance(normal, Vector2)
        d = 2 * (self.x * normal.x + self.y * normal.y)
        return Vector2(self.x - d * normal.x,
                       self.y - d * normal.y)

    def angle(self, other):
        """Return the angle to the vector other"""
        return math.acos(self.dot(other) / (self.magnitude()*other.magnitude()))

    def project(self, other):
        """Return one vector projected on the vector other"""
        n = other.normalized()
        return self.dot(n)*n

class Vector3:
    __slots__ = ['x', 'y', 'z']
    __hash__ = None

    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z

    def __copy__(self):
        return self.__class__(self.x, self.y, self.z)

    copy = __copy__

    def __repr__(self):
        return 'Vector3(%.2f, %.2f, %.2f)' % (self.x,
                                              self.y,
                                              self.z)

    def __eq__(self, other):
        if isinstance(other, Vector3):
            return self.x == other.x and \
                   self.y == other.y and \
                   self.z == other.z
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return self.x == other[0] and \
                   self.y == other[1] and \
                   self.z == other[2]

    def __ne__(self, other):
        return not self.__eq__(other)

    def __nonzero__(self):
        return self.x != 0 or self.y != 0 or self.z != 0

    def __len__(self):
        return 3

    def __getitem__(self, key):
        return (self.x, self.y, self.z)[key]

    def __setitem__(self, key, value):
        l = [self.x, self.y, self.z]
        l[key] = value
        self.x, self.y, self.z = l

    def __iter__(self):
        return iter((self.x, self.y, self.z))

    def __getattr__(self, name):
        try:
            return tuple([(self.x, self.y, self.z)['xyz'.index(c)] \
                          for c in name])
        except ValueError:
            raise AttributeError, name

    if _enable_swizzle_set:
        # This has detrimental performance on ordinary setattr as well
        # if enabled
        def __setattr__(self, name, value):
            if len(name) == 1:
                object.__setattr__(self, name, value)
            else:
                try:
                    l = [self.x, self.y, self.z]
                    for c, v in map(None, name, value):
                        l['xyz'.index(c)] = v
                    self.x, self.y, self.z = l
                except ValueError:
                    raise AttributeError, name


    def __add__(self, other):
        if isinstance(other, Vector3):
            # Vector + Vector -&gt; Vector
            # Vector + Point -&gt; Point
            # Point + Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector3
            else:
                _class = Point3
            return _class(self.x + other.x,
                          self.y + other.y,
                          self.z + other.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(self.x + other[0],
                           self.y + other[1],
                           self.z + other[2])
    __radd__ = __add__

    def __iadd__(self, other):
        if isinstance(other, Vector3):
            self.x += other.x
            self.y += other.y
            self.z += other.z
        else:
            self.x += other[0]
            self.y += other[1]
            self.z += other[2]
        return self

    def __sub__(self, other):
        if isinstance(other, Vector3):
            # Vector - Vector -&gt; Vector
            # Vector - Point -&gt; Point
            # Point - Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector3
            else:
                _class = Point3
            return Vector3(self.x - other.x,
                           self.y - other.y,
                           self.z - other.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(self.x - other[0],
                           self.y - other[1],
                           self.z - other[2])

   
    def __rsub__(self, other):
        if isinstance(other, Vector3):
            return Vector3(other.x - self.x,
                           other.y - self.y,
                           other.z - self.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(other.x - self[0],
                           other.y - self[1],
                           other.z - self[2])

    def __mul__(self, other):
        if isinstance(other, Vector3):
            # TODO component-wise mul/div in-place and on Vector2; docs.
            if self.__class__ is Point3 or other.__class__ is Point3:
                _class = Point3
            else:
                _class = Vector3
            return _class(self.x * other.x,
                          self.y * other.y,
                          self.z * other.z)
        else: 
            assert type(other) in (int, long, float)
            return Vector3(self.x * other,
                           self.y * other,
                           self.z * other)

    __rmul__ = __mul__

    def __imul__(self, other):
        assert type(other) in (int, long, float)
        self.x *= other
        self.y *= other
        self.z *= other
        return self

    def __div__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.div(self.x, other),
                       operator.div(self.y, other),
                       operator.div(self.z, other))


    def __rdiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.div(other, self.x),
                       operator.div(other, self.y),
                       operator.div(other, self.z))

    def __floordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.floordiv(self.x, other),
                       operator.floordiv(self.y, other),
                       operator.floordiv(self.z, other))


    def __rfloordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.floordiv(other, self.x),
                       operator.floordiv(other, self.y),
                       operator.floordiv(other, self.z))

    def __truediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.truediv(self.x, other),
                       operator.truediv(self.y, other),
                       operator.truediv(self.z, other))


    def __rtruediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.truediv(other, self.x),
                       operator.truediv(other, self.y),
                       operator.truediv(other, self.z))
    
    def __neg__(self):
        return Vector3(-self.x,
                        -self.y,
                        -self.z)

    __pos__ = __copy__
    
    def __abs__(self):
        return math.sqrt(self.x ** 2 + \
                         self.y ** 2 + \
                         self.z ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.x ** 2 + \
               self.y ** 2 + \
               self.z ** 2

    def normalize(self):
        d = self.magnitude()
        if d:
            self.x /= d
            self.y /= d
            self.z /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d:
            return Vector3(self.x / d, 
                           self.y / d, 
                           self.z / d)
        return self.copy()

    def dot(self, other):
        assert isinstance(other, Vector3)
        return self.x * other.x + \
               self.y * other.y + \
               self.z * other.z

    def cross(self, other):
        assert isinstance(other, Vector3)
        return Vector3(self.y * other.z - self.z * other.y,
                       -self.x * other.z + self.z * other.x,
                       self.x * other.y - self.y * other.x)

    def reflect(self, normal):
        # assume normal is normalized
        assert isinstance(normal, Vector3)
        d = 2 * (self.x * normal.x + self.y * normal.y + self.z * normal.z)
        return Vector3(self.x - d * normal.x,
                       self.y - d * normal.y,
                       self.z - d * normal.z)

    def rotate_around(self, axis, theta):
        """Return the vector rotated around axis through angle theta. Right hand rule applies"""

        # Adapted from equations published by Glenn Murray.
        # http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
        x, y, z = self.x, self.y,self.z
        u, v, w = axis.x, axis.y, axis.z

        # Extracted common factors for simplicity and efficiency
        r2 = u**2 + v**2 + w**2
        r = math.sqrt(r2)
        ct = math.cos(theta)
        st = math.sin(theta) / r
        dt = (u*x + v*y + w*z) * (1 - ct) / r2
        return Vector3((u * dt + x * ct + (-w * y + v * z) * st),
                       (v * dt + y * ct + ( w * x - u * z) * st),
                       (w * dt + z * ct + (-v * x + u * y) * st))

    def angle(self, other):
        """Return the angle to the vector other"""
        return math.acos(self.dot(other) / (self.magnitude()*other.magnitude()))

    def project(self, other):
        """Return one vector projected on the vector other"""
        n = other.normalized()
        return self.dot(n)*n

# a b c 
# e f g 
# i j k 

class Matrix3:
    __slots__ = list('abcefgijk')

    def __init__(self):
        self.identity()

    def __copy__(self):
        M = Matrix3()
        M.a = self.a
        M.b = self.b
        M.c = self.c
        M.e = self.e 
        M.f = self.f
        M.g = self.g
        M.i = self.i
        M.j = self.j
        M.k = self.k
        return M

    copy = __copy__
    def __repr__(self):
        return ('Matrix3([% 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f])') \
                % (self.a, self.b, self.c,
                   self.e, self.f, self.g,
                   self.i, self.j, self.k)

    def __getitem__(self, key):
        return [self.a, self.e, self.i,
                self.b, self.f, self.j,
                self.c, self.g, self.k][key]

    def __setitem__(self, key, value):
        L = self[:]
        L[key] = value
        (self.a, self.e, self.i,
         self.b, self.f, self.j,
         self.c, self.g, self.k) = L

    def __mul__(self, other):
        if isinstance(other, Matrix3):
            # Caching repeatedly accessed attributes in local variables
            # apparently increases performance by 20%.  Attrib: Will McGugan.
            Aa = self.a
            Ab = self.b
            Ac = self.c
            Ae = self.e
            Af = self.f
            Ag = self.g
            Ai = self.i
            Aj = self.j
            Ak = self.k
            Ba = other.a
            Bb = other.b
            Bc = other.c
            Be = other.e
            Bf = other.f
            Bg = other.g
            Bi = other.i
            Bj = other.j
            Bk = other.k
            C = Matrix3()
            C.a = Aa * Ba + Ab * Be + Ac * Bi
            C.b = Aa * Bb + Ab * Bf + Ac * Bj
            C.c = Aa * Bc + Ab * Bg + Ac * Bk
            C.e = Ae * Ba + Af * Be + Ag * Bi
            C.f = Ae * Bb + Af * Bf + Ag * Bj
            C.g = Ae * Bc + Af * Bg + Ag * Bk
            C.i = Ai * Ba + Aj * Be + Ak * Bi
            C.j = Ai * Bb + Aj * Bf + Ak * Bj
            C.k = Ai * Bc + Aj * Bg + Ak * Bk
            return C
        elif isinstance(other, Point2):
            A = self
            B = other
            P = Point2(0, 0)
            P.x = A.a * B.x + A.b * B.y + A.c
            P.y = A.e * B.x + A.f * B.y + A.g
            return P
        elif isinstance(other, Vector2):
            A = self
            B = other
            V = Vector2(0, 0)
            V.x = A.a * B.x + A.b * B.y 
            V.y = A.e * B.x + A.f * B.y 
            return V
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Matrix3)
        # Cache attributes in local vars (see Matrix3.__mul__).
        Aa = self.a
        Ab = self.b
        Ac = self.c
        Ae = self.e
        Af = self.f
        Ag = self.g
        Ai = self.i
        Aj = self.j
        Ak = self.k
        Ba = other.a
        Bb = other.b
        Bc = other.c
        Be = other.e
        Bf = other.f
        Bg = other.g
        Bi = other.i
        Bj = other.j
        Bk = other.k
        self.a = Aa * Ba + Ab * Be + Ac * Bi
        self.b = Aa * Bb + Ab * Bf + Ac * Bj
        self.c = Aa * Bc + Ab * Bg + Ac * Bk
        self.e = Ae * Ba + Af * Be + Ag * Bi
        self.f = Ae * Bb + Af * Bf + Ag * Bj
        self.g = Ae * Bc + Af * Bg + Ag * Bk
        self.i = Ai * Ba + Aj * Be + Ak * Bi
        self.j = Ai * Bb + Aj * Bf + Ak * Bj
        self.k = Ai * Bc + Aj * Bg + Ak * Bk
        return self

    def identity(self):
        self.a = self.f = self.k = 1.
        self.b = self.c = self.e = self.g = self.i = self.j = 0
        return self

    def scale(self, x, y):
        self *= Matrix3.new_scale(x, y)
        return self

    def translate(self, x, y):
        self *= Matrix3.new_translate(x, y)
        return self 

    def rotate(self, angle):
        self *= Matrix3.new_rotate(angle)
        return self

    # Static constructors
    def new_identity(cls):
        self = cls()
        return self
    new_identity = classmethod(new_identity)

    def new_scale(cls, x, y):
        self = cls()
        self.a = x
        self.f = y
        return self
    new_scale = classmethod(new_scale)

    def new_translate(cls, x, y):
        self = cls()
        self.c = x
        self.g = y
        return self
    new_translate = classmethod(new_translate)

    def new_rotate(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.f = c
        self.b = -s
        self.e = s
        return self
    new_rotate = classmethod(new_rotate)

    def determinant(self):
        return (self.a*self.f*self.k 
                + self.b*self.g*self.i 
                + self.c*self.e*self.j 
                - self.a*self.g*self.j 
                - self.b*self.e*self.k 
                - self.c*self.f*self.i)

    def inverse(self):
        tmp = Matrix3()
        d = self.determinant()

        if abs(d) &lt; 0.001:
            # No inverse, return identity
            return tmp
        else:
            d = 1.0 / d

            tmp.a = d * (self.f*self.k - self.g*self.j)
            tmp.b = d * (self.c*self.j - self.b*self.k)
            tmp.c = d * (self.b*self.g - self.c*self.f)
            tmp.e = d * (self.g*self.i - self.e*self.k)
            tmp.f = d * (self.a*self.k - self.c*self.i)
            tmp.g = d * (self.c*self.e - self.a*self.g)
            tmp.i = d * (self.e*self.j - self.f*self.i)
            tmp.j = d * (self.b*self.i - self.a*self.j)
            tmp.k = d * (self.a*self.f - self.b*self.e)

            return tmp

# a b c d
# e f g h
# i j k l
# m n o p

class Matrix4:
    __slots__ = list('abcdefghijklmnop')

    def __init__(self):
        self.identity()

    def __copy__(self):
        M = Matrix4()
        M.a = self.a
        M.b = self.b
        M.c = self.c
        M.d = self.d
        M.e = self.e 
        M.f = self.f
        M.g = self.g
        M.h = self.h
        M.i = self.i
        M.j = self.j
        M.k = self.k
        M.l = self.l
        M.m = self.m
        M.n = self.n
        M.o = self.o
        M.p = self.p
        return M

    copy = __copy__


    def __repr__(self):
        return ('Matrix4([% 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f])') \
                % (self.a, self.b, self.c, self.d,
                   self.e, self.f, self.g, self.h,
                   self.i, self.j, self.k, self.l,
                   self.m, self.n, self.o, self.p)

    def __getitem__(self, key):
        return [self.a, self.e, self.i, self.m,
                self.b, self.f, self.j, self.n,
                self.c, self.g, self.k, self.o,
                self.d, self.h, self.l, self.p][key]

    def __setitem__(self, key, value):
        L = self[:]
        L[key] = value
        (self.a, self.e, self.i, self.m,
         self.b, self.f, self.j, self.n,
         self.c, self.g, self.k, self.o,
         self.d, self.h, self.l, self.p) = L

    def __mul__(self, other):
        if isinstance(other, Matrix4):
            # Cache attributes in local vars (see Matrix3.__mul__).
            Aa = self.a
            Ab = self.b
            Ac = self.c
            Ad = self.d
            Ae = self.e
            Af = self.f
            Ag = self.g
            Ah = self.h
            Ai = self.i
            Aj = self.j
            Ak = self.k
            Al = self.l
            Am = self.m
            An = self.n
            Ao = self.o
            Ap = self.p
            Ba = other.a
            Bb = other.b
            Bc = other.c
            Bd = other.d
            Be = other.e
            Bf = other.f
            Bg = other.g
            Bh = other.h
            Bi = other.i
            Bj = other.j
            Bk = other.k
            Bl = other.l
            Bm = other.m
            Bn = other.n
            Bo = other.o
            Bp = other.p
            C = Matrix4()
            C.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
            C.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
            C.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
            C.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
            C.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
            C.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
            C.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
            C.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
            C.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
            C.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
            C.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
            C.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
            C.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
            C.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
            C.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
            C.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
            return C
        elif isinstance(other, Point3):
            A = self
            B = other
            P = Point3(0, 0, 0)
            P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
            P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
            P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
            return P
        elif isinstance(other, Vector3):
            A = self
            B = other
            V = Vector3(0, 0, 0)
            V.x = A.a * B.x + A.b * B.y + A.c * B.z
            V.y = A.e * B.x + A.f * B.y + A.g * B.z
            V.z = A.i * B.x + A.j * B.y + A.k * B.z
            return V
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Matrix4)
        # Cache attributes in local vars (see Matrix3.__mul__).
        Aa = self.a
        Ab = self.b
        Ac = self.c
        Ad = self.d
        Ae = self.e
        Af = self.f
        Ag = self.g
        Ah = self.h
        Ai = self.i
        Aj = self.j
        Ak = self.k
        Al = self.l
        Am = self.m
        An = self.n
        Ao = self.o
        Ap = self.p
        Ba = other.a
        Bb = other.b
        Bc = other.c
        Bd = other.d
        Be = other.e
        Bf = other.f
        Bg = other.g
        Bh = other.h
        Bi = other.i
        Bj = other.j
        Bk = other.k
        Bl = other.l
        Bm = other.m
        Bn = other.n
        Bo = other.o
        Bp = other.p
        self.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
        self.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
        self.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
        self.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
        self.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
        self.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
        self.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
        self.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
        self.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
        self.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
        self.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
        self.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
        self.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
        self.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
        self.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
        self.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
        return self

    def transform(self, other):
        A = self
        B = other
        P = Point3(0, 0, 0)
        P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
        P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
        P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
        w =   A.m * B.x + A.n * B.y + A.o * B.z + A.p
        if w != 0:
            P.x /= w
            P.y /= w
            P.z /= w
        return P

    def identity(self):
        self.a = self.f = self.k = self.p = 1.
        self.b = self.c = self.d = self.e = self.g = self.h = \
        self.i = self.j = self.l = self.m = self.n = self.o = 0
        return self

    def scale(self, x, y, z):
        self *= Matrix4.new_scale(x, y, z)
        return self

    def translate(self, x, y, z):
        self *= Matrix4.new_translate(x, y, z)
        return self 

    def rotatex(self, angle):
        self *= Matrix4.new_rotatex(angle)
        return self

    def rotatey(self, angle):
        self *= Matrix4.new_rotatey(angle)
        return self

    def rotatez(self, angle):
        self *= Matrix4.new_rotatez(angle)
        return self

    def rotate_axis(self, angle, axis):
        self *= Matrix4.new_rotate_axis(angle, axis)
        return self

    def rotate_euler(self, heading, attitude, bank):
        self *= Matrix4.new_rotate_euler(heading, attitude, bank)
        return self

    def rotate_triple_axis(self, x, y, z):
        self *= Matrix4.new_rotate_triple_axis(x, y, z)
        return self

    def transpose(self):
        (self.a, self.e, self.i, self.m,
         self.b, self.f, self.j, self.n,
         self.c, self.g, self.k, self.o,
         self.d, self.h, self.l, self.p) = \
        (self.a, self.b, self.c, self.d,
         self.e, self.f, self.g, self.h,
         self.i, self.j, self.k, self.l,
         self.m, self.n, self.o, self.p)

    def transposed(self):
        M = self.copy()
        M.transpose()
        return M

    # Static constructors
    def new(cls, *values):
        M = cls()
        M[:] = values
        return M
    new = classmethod(new)

    def new_identity(cls):
        self = cls()
        return self
    new_identity = classmethod(new_identity)

    def new_scale(cls, x, y, z):
        self = cls()
        self.a = x
        self.f = y
        self.k = z
        return self
    new_scale = classmethod(new_scale)

    def new_translate(cls, x, y, z):
        self = cls()
        self.d = x
        self.h = y
        self.l = z
        return self
    new_translate = classmethod(new_translate)

    def new_rotatex(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.f = self.k = c
        self.g = -s
        self.j = s
        return self
    new_rotatex = classmethod(new_rotatex)

    def new_rotatey(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.k = c
        self.c = s
        self.i = -s
        return self    
    new_rotatey = classmethod(new_rotatey)
    
    def new_rotatez(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.f = c
        self.b = -s
        self.e = s
        return self
    new_rotatez = classmethod(new_rotatez)

    def new_rotate_axis(cls, angle, axis):
        assert(isinstance(axis, Vector3))
        vector = axis.normalized()
        x = vector.x
        y = vector.y
        z = vector.z

        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        c1 = 1. - c
        
        # from the glRotate man page
        self.a = x * x * c1 + c
        self.b = x * y * c1 - z * s
        self.c = x * z * c1 + y * s
        self.e = y * x * c1 + z * s
        self.f = y * y * c1 + c
        self.g = y * z * c1 - x * s
        self.i = x * z * c1 - y * s
        self.j = y * z * c1 + x * s
        self.k = z * z * c1 + c
        return self
    new_rotate_axis = classmethod(new_rotate_axis)

    def new_rotate_euler(cls, heading, attitude, bank):
        # from http://www.euclideanspace.com/
        ch = math.cos(heading)
        sh = math.sin(heading)
        ca = math.cos(attitude)
        sa = math.sin(attitude)
        cb = math.cos(bank)
        sb = math.sin(bank)

        self = cls()
        self.a = ch * ca
        self.b = sh * sb - ch * sa * cb
        self.c = ch * sa * sb + sh * cb
        self.e = sa
        self.f = ca * cb
        self.g = -ca * sb
        self.i = -sh * ca
        self.j = sh * sa * cb + ch * sb
        self.k = -sh * sa * sb + ch * cb
        return self
    new_rotate_euler = classmethod(new_rotate_euler)

    def new_rotate_triple_axis(cls, x, y, z):
      m = cls()
      
      m.a, m.b, m.c = x.x, y.x, z.x
      m.e, m.f, m.g = x.y, y.y, z.y
      m.i, m.j, m.k = x.z, y.z, z.z
      
      return m
    new_rotate_triple_axis = classmethod(new_rotate_triple_axis)

    def new_look_at(cls, eye, at, up):
      z = (eye - at).normalized()
      x = up.cross(z).normalized()
      y = z.cross(x)
      
      m = cls.new_rotate_triple_axis(x, y, z)
      m.d, m.h, m.l = eye.x, eye.y, eye.z
      return m
    new_look_at = classmethod(new_look_at)
    
    def new_perspective(cls, fov_y, aspect, near, far):
        # from the gluPerspective man page
        f = 1 / math.tan(fov_y / 2)
        self = cls()
        assert near != 0.0 and near != far
        self.a = f / aspect
        self.f = f
        self.k = (far + near) / (near - far)
        self.l = 2 * far * near / (near - far)
        self.o = -1
        self.p = 0
        return self
    new_perspective = classmethod(new_perspective)

    def determinant(self):
        return ((self.a * self.f - self.e * self.b)
              * (self.k * self.p - self.o * self.l)
              - (self.a * self.j - self.i * self.b)
              * (self.g * self.p - self.o * self.h)
              + (self.a * self.n - self.m * self.b)
              * (self.g * self.l - self.k * self.h)
              + (self.e * self.j - self.i * self.f)
              * (self.c * self.p - self.o * self.d)
              - (self.e * self.n - self.m * self.f)
              * (self.c * self.l - self.k * self.d)
              + (self.i * self.n - self.m * self.j)
              * (self.c * self.h - self.g * self.d))

    def inverse(self):
        tmp = Matrix4()
        d = self.determinant();

        if abs(d) &lt; 0.001:
            # No inverse, return identity
            return tmp
        else:
            d = 1.0 / d;

            tmp.a = d * (self.f * (self.k * self.p - self.o * self.l) + self.j * (self.o * self.h - self.g * self.p) + self.n * (self.g * self.l - self.k * self.h));
            tmp.e = d * (self.g * (self.i * self.p - self.m * self.l) + self.k * (self.m * self.h - self.e * self.p) + self.o * (self.e * self.l - self.i * self.h));
            tmp.i = d * (self.h * (self.i * self.n - self.m * self.j) + self.l * (self.m * self.f - self.e * self.n) + self.p * (self.e * self.j - self.i * self.f));
            tmp.m = d * (self.e * (self.n * self.k - self.j * self.o) + self.i * (self.f * self.o - self.n * self.g) + self.m * (self.j * self.g - self.f * self.k));
            
            tmp.b = d * (self.j * (self.c * self.p - self.o * self.d) + self.n * (self.k * self.d - self.c * self.l) + self.b * (self.o * self.l - self.k * self.p));
            tmp.f = d * (self.k * (self.a * self.p - self.m * self.d) + self.o * (self.i * self.d - self.a * self.l) + self.c * (self.m * self.l - self.i * self.p));
            tmp.j = d * (self.l * (self.a * self.n - self.m * self.b) + self.p * (self.i * self.b - self.a * self.j) + self.d * (self.m * self.j - self.i * self.n));
            tmp.n = d * (self.i * (self.n * self.c - self.b * self.o) + self.m * (self.b * self.k - self.j * self.c) + self.a * (self.j * self.o - self.n * self.k));
            
            tmp.c = d * (self.n * (self.c * self.h - self.g * self.d) + self.b * (self.g * self.p - self.o * self.h) + self.f * (self.o * self.d - self.c * self.p));
            tmp.g = d * (self.o * (self.a * self.h - self.e * self.d) + self.c * (self.e * self.p - self.m * self.h) + self.g * (self.m * self.d - self.a * self.p));
            tmp.k = d * (self.p * (self.a * self.f - self.e * self.b) + self.d * (self.e * self.n - self.m * self.f) + self.h * (self.m * self.b - self.a * self.n));
            tmp.o = d * (self.m * (self.f * self.c - self.b * self.g) + self.a * (self.n * self.g - self.f * self.o) + self.e * (self.b * self.o - self.n * self.c));
            
            tmp.d = d * (self.b * (self.k * self.h - self.g * self.l) + self.f * (self.c * self.l - self.k * self.d) + self.j * (self.g * self.d - self.c * self.h));
            tmp.h = d * (self.c * (self.i * self.h - self.e * self.l) + self.g * (self.a * self.l - self.i * self.d) + self.k * (self.e * self.d - self.a * self.h));
            tmp.l = d * (self.d * (self.i * self.f - self.e * self.j) + self.h * (self.a * self.j - self.i * self.b) + self.l * (self.e * self.b - self.a * self.f));
            tmp.p = d * (self.a * (self.f * self.k - self.j * self.g) + self.e * (self.j * self.c - self.b * self.k) + self.i * (self.b * self.g - self.f * self.c));

        return tmp;
        

class Quaternion:
    # All methods and naming conventions based off 
    # http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions

    # w is the real part, (x, y, z) are the imaginary parts
    __slots__ = ['w', 'x', 'y', 'z']

    def __init__(self, w=1, x=0, y=0, z=0):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    def __copy__(self):
        Q = Quaternion()
        Q.w = self.w
        Q.x = self.x
        Q.y = self.y
        Q.z = self.z
        return Q

    copy = __copy__

    def __repr__(self):
        return 'Quaternion(real=%.2f, imag=&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.w, self.x, self.y, self.z)

    def __mul__(self, other):
        if isinstance(other, Quaternion):
            Ax = self.x
            Ay = self.y
            Az = self.z
            Aw = self.w
            Bx = other.x
            By = other.y
            Bz = other.z
            Bw = other.w
            Q = Quaternion()
            Q.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
            Q.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
            Q.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
            Q.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
            return Q
        elif isinstance(other, Vector3):
            w = self.w
            x = self.x
            y = self.y
            z = self.z
            Vx = other.x
            Vy = other.y
            Vz = other.z
            ww = w * w
            w2 = w * 2
            wx2 = w2 * x
            wy2 = w2 * y
            wz2 = w2 * z
            xx = x * x
            x2 = x * 2
            xy2 = x2 * y
            xz2 = x2 * z
            yy = y * y
            yz2 = 2 * y * z
            zz = z * z
            return other.__class__(\
               ww * Vx + wy2 * Vz - wz2 * Vy + \
               xx * Vx + xy2 * Vy + xz2 * Vz - \
               zz * Vx - yy * Vx,
               xy2 * Vx + yy * Vy + yz2 * Vz + \
               wz2 * Vx - zz * Vy + ww * Vy - \
               wx2 * Vz - xx * Vy,
               xz2 * Vx + yz2 * Vy + \
               zz * Vz - wy2 * Vx - yy * Vz + \
               wx2 * Vy - xx * Vz + ww * Vz)
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Quaternion)
        Ax = self.x
        Ay = self.y
        Az = self.z
        Aw = self.w
        Bx = other.x
        By = other.y
        Bz = other.z
        Bw = other.w
        self.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
        self.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
        self.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
        self.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
        return self

    def __abs__(self):
        return math.sqrt(self.w ** 2 + \
                         self.x ** 2 + \
                         self.y ** 2 + \
                         self.z ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.w ** 2 + \
               self.x ** 2 + \
               self.y ** 2 + \
               self.z ** 2 

    def identity(self):
        self.w = 1
        self.x = 0
        self.y = 0
        self.z = 0
        return self

    def rotate_axis(self, angle, axis):
        self *= Quaternion.new_rotate_axis(angle, axis)
        return self

    def rotate_euler(self, heading, attitude, bank):
        self *= Quaternion.new_rotate_euler(heading, attitude, bank)
        return self

    def rotate_matrix(self, m):
        self *= Quaternion.new_rotate_matrix(m)
        return self

    def conjugated(self):
        Q = Quaternion()
        Q.w = self.w
        Q.x = -self.x
        Q.y = -self.y
        Q.z = -self.z
        return Q

    def normalize(self):
        d = self.magnitude()
        if d != 0:
            self.w /= d
            self.x /= d
            self.y /= d
            self.z /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d != 0:
            Q = Quaternion()
            Q.w = self.w / d
            Q.x = self.x / d
            Q.y = self.y / d
            Q.z = self.z / d
            return Q
        else:
            return self.copy()

    def get_angle_axis(self):
        if self.w &gt; 1:
            self = self.normalized()
        angle = 2 * math.acos(self.w)
        s = math.sqrt(1 - self.w ** 2)
        if s &lt; 0.001:
            return angle, Vector3(1, 0, 0)
        else:
            return angle, Vector3(self.x / s, self.y / s, self.z / s)

    def get_euler(self):
        t = self.x * self.y + self.z * self.w
        if t &gt; 0.4999:
            heading = 2 * math.atan2(self.x, self.w)
            attitude = math.pi / 2
            bank = 0
        elif t &lt; -0.4999:
            heading = -2 * math.atan2(self.x, self.w)
            attitude = -math.pi / 2
            bank = 0
        else:
            sqx = self.x ** 2
            sqy = self.y ** 2
            sqz = self.z ** 2
            heading = math.atan2(2 * self.y * self.w - 2 * self.x * self.z,
                                 1 - 2 * sqy - 2 * sqz)
            attitude = math.asin(2 * t)
            bank = math.atan2(2 * self.x * self.w - 2 * self.y * self.z,
                              1 - 2 * sqx - 2 * sqz)
        return heading, attitude, bank

    def get_matrix(self):
        xx = self.x ** 2
        xy = self.x * self.y
        xz = self.x * self.z
        xw = self.x * self.w
        yy = self.y ** 2
        yz = self.y * self.z
        yw = self.y * self.w
        zz = self.z ** 2
        zw = self.z * self.w
        M = Matrix4()
        M.a = 1 - 2 * (yy + zz)
        M.b = 2 * (xy - zw)
        M.c = 2 * (xz + yw)
        M.e = 2 * (xy + zw)
        M.f = 1 - 2 * (xx + zz)
        M.g = 2 * (yz - xw)
        M.i = 2 * (xz - yw)
        M.j = 2 * (yz + xw)
        M.k = 1 - 2 * (xx + yy)
        return M

    # Static constructors
    def new_identity(cls):
        return cls()
    new_identity = classmethod(new_identity)

    def new_rotate_axis(cls, angle, axis):
        assert(isinstance(axis, Vector3))
        axis = axis.normalized()
        s = math.sin(angle / 2)
        Q = cls()
        Q.w = math.cos(angle / 2)
        Q.x = axis.x * s
        Q.y = axis.y * s
        Q.z = axis.z * s
        return Q
    new_rotate_axis = classmethod(new_rotate_axis)

    def new_rotate_euler(cls, heading, attitude, bank):
        Q = cls()
        c1 = math.cos(heading / 2)
        s1 = math.sin(heading / 2)
        c2 = math.cos(attitude / 2)
        s2 = math.sin(attitude / 2)
        c3 = math.cos(bank / 2)
        s3 = math.sin(bank / 2)

        Q.w = c1 * c2 * c3 - s1 * s2 * s3
        Q.x = s1 * s2 * c3 + c1 * c2 * s3
        Q.y = s1 * c2 * c3 + c1 * s2 * s3
        Q.z = c1 * s2 * c3 - s1 * c2 * s3
        return Q
    new_rotate_euler = classmethod(new_rotate_euler)
    
    def new_rotate_matrix(cls, m):
      if m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] &gt; 0.00000001:
        t = m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          s*t,
          (m[1*4 + 2] - m[2*4 + 1])*s,
          (m[2*4 + 0] - m[0*4 + 2])*s,
          (m[0*4 + 1] - m[1*4 + 0])*s
          )
        
      elif m[0*4 + 0] &gt; m[1*4 + 1] and m[0*4 + 0] &gt; m[2*4 + 2]:
        t = m[0*4 + 0] - m[1*4 + 1] - m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[1*4 + 2] - m[2*4 + 1])*s,
          s*t,
          (m[0*4 + 1] + m[1*4 + 0])*s,
          (m[2*4 + 0] + m[0*4 + 2])*s
          )
        
      elif m[1*4 + 1] &gt; m[2*4 + 2]:
        t = -m[0*4 + 0] + m[1*4 + 1] - m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[2*4 + 0] - m[0*4 + 2])*s,
          (m[0*4 + 1] + m[1*4 + 0])*s,
          s*t,
          (m[1*4 + 2] + m[2*4 + 1])*s
          )
        
      else:
        t = -m[0*4 + 0] - m[1*4 + 1] + m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[0*4 + 1] - m[1*4 + 0])*s,
          (m[2*4 + 0] + m[0*4 + 2])*s,
          (m[1*4 + 2] + m[2*4 + 1])*s,
          s*t
          )
    new_rotate_matrix = classmethod(new_rotate_matrix)
    
    def new_interpolate(cls, q1, q2, t):
        assert isinstance(q1, Quaternion) and isinstance(q2, Quaternion)
        Q = cls()

        costheta = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z
        if costheta &lt; 0.:
            costheta = -costheta
            q1 = q1.conjugated()
        elif costheta &gt; 1:
            costheta = 1

        theta = math.acos(costheta)
        if abs(theta) &lt; 0.01:
            Q.w = q2.w
            Q.x = q2.x
            Q.y = q2.y
            Q.z = q2.z
            return Q

        sintheta = math.sqrt(1.0 - costheta * costheta)
        if abs(sintheta) &lt; 0.01:
            Q.w = (q1.w + q2.w) * 0.5
            Q.x = (q1.x + q2.x) * 0.5
            Q.y = (q1.y + q2.y) * 0.5
            Q.z = (q1.z + q2.z) * 0.5
            return Q

        ratio1 = math.sin((1 - t) * theta) / sintheta
        ratio2 = math.sin(t * theta) / sintheta

        Q.w = q1.w * ratio1 + q2.w * ratio2
        Q.x = q1.x * ratio1 + q2.x * ratio2
        Q.y = q1.y * ratio1 + q2.y * ratio2
        Q.z = q1.z * ratio1 + q2.z * ratio2
        return Q
    new_interpolate = classmethod(new_interpolate)

# Geometry
# Much maths thanks to Paul Bourke, http://astronomy.swin.edu.au/~pbourke
# ---------------------------------------------------------------------------

class Geometry:
    def _connect_unimplemented(self, other):
        raise AttributeError, 'Cannot connect %s to %s' % \
            (self.__class__, other.__class__)

    def _intersect_unimplemented(self, other):
        raise AttributeError, 'Cannot intersect %s and %s' % \
            (self.__class__, other.__class__)

    _intersect_point2 = _intersect_unimplemented
    _intersect_line2 = _intersect_unimplemented
    _intersect_circle = _intersect_unimplemented
    _connect_point2 = _connect_unimplemented
    _connect_line2 = _connect_unimplemented
    _connect_circle = _connect_unimplemented

    _intersect_point3 = _intersect_unimplemented
    _intersect_line3 = _intersect_unimplemented
    _intersect_sphere = _intersect_unimplemented
    _intersect_plane = _intersect_unimplemented
    _connect_point3 = _connect_unimplemented
    _connect_line3 = _connect_unimplemented
    _connect_sphere = _connect_unimplemented
    _connect_plane = _connect_unimplemented

    def intersect(self, other):
        raise NotImplementedError

    def connect(self, other):
        raise NotImplementedError

    def distance(self, other):
        c = self.connect(other)
        if c:
            return c.length
        return 0.0

def _intersect_point2_circle(P, C):
    return abs(P - C.c) &lt;= C.r
    
def _intersect_line2_line2(A, B):
    d = B.v.y * A.v.x - B.v.x * A.v.y
    if d == 0:
        return None

    dy = A.p.y - B.p.y
    dx = A.p.x - B.p.x
    ua = (B.v.x * dy - B.v.y * dx) / d
    if not A._u_in(ua):
        return None
    ub = (A.v.x * dy - A.v.y * dx) / d
    if not B._u_in(ub):
        return None

    return Point2(A.p.x + ua * A.v.x,
                  A.p.y + ua * A.v.y)

def _intersect_line2_circle(L, C):
    a = L.v.magnitude_squared()
    b = 2 * (L.v.x * (L.p.x - C.c.x) + \
             L.v.y * (L.p.y - C.c.y))
    c = C.c.magnitude_squared() + \
        L.p.magnitude_squared() - \
        2 * C.c.dot(L.p) - \
        C.r ** 2
    det = b ** 2 - 4 * a * c
    if det &lt; 0:
        return None
    sq = math.sqrt(det)
    u1 = (-b + sq) / (2 * a)
    u2 = (-b - sq) / (2 * a)
    if not L._u_in(u1):
        u1 = max(min(u1, 1.0), 0.0)
    if not L._u_in(u2):
        u2 = max(min(u2, 1.0), 0.0)

    # Tangent
    if u1 == u2:
        return Point2(L.p.x + u1 * L.v.x,
                      L.p.y + u1 * L.v.y)

    return LineSegment2(Point2(L.p.x + u1 * L.v.x,
                               L.p.y + u1 * L.v.y),
                        Point2(L.p.x + u2 * L.v.x,
                               L.p.y + u2 * L.v.y))

def _connect_point2_line2(P, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((P.x - L.p.x) * L.v.x + \
         (P.y - L.p.y) * L.v.y) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    return LineSegment2(P, 
                        Point2(L.p.x + u * L.v.x,
                               L.p.y + u * L.v.y))

def _connect_point2_circle(P, C):
    v = P - C.c
    v.normalize()
    v *= C.r
    return LineSegment2(P, Point2(C.c.x + v.x, C.c.y + v.y))

def _connect_line2_line2(A, B):
    d = B.v.y * A.v.x - B.v.x * A.v.y
    if d == 0:
        # Parallel, connect an endpoint with a line
        if isinstance(B, Ray2) or isinstance(B, LineSegment2):
            p1, p2 = _connect_point2_line2(B.p, A)
            return p2, p1
        # No endpoint (or endpoint is on A), possibly choose arbitrary point
        # on line.
        return _connect_point2_line2(A.p, B)

    dy = A.p.y - B.p.y
    dx = A.p.x - B.p.x
    ua = (B.v.x * dy - B.v.y * dx) / d
    if not A._u_in(ua):
        ua = max(min(ua, 1.0), 0.0)
    ub = (A.v.x * dy - A.v.y * dx) / d
    if not B._u_in(ub):
        ub = max(min(ub, 1.0), 0.0)

    return LineSegment2(Point2(A.p.x + ua * A.v.x, A.p.y + ua * A.v.y),
                        Point2(B.p.x + ub * B.v.x, B.p.y + ub * B.v.y))

def _connect_circle_line2(C, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((C.c.x - L.p.x) * L.v.x + (C.c.y - L.p.y) * L.v.y) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    point = Point2(L.p.x + u * L.v.x, L.p.y + u * L.v.y)
    v = (point - C.c)
    v.normalize()
    v *= C.r
    return LineSegment2(Point2(C.c.x + v.x, C.c.y + v.y), point)

def _connect_circle_circle(A, B):
    v = B.c - A.c
    d = v.magnitude()
    if A.r &gt;= B.r and d &lt; A.r:
        #centre B inside A
        s1,s2 = +1, +1
    elif B.r &gt; A.r and d &lt; B.r:
        #centre A inside B
        s1,s2 = -1, -1
    elif d &gt;= A.r and d &gt;= B.r:
        s1,s2 = +1, -1
    v.normalize()
    return LineSegment2(Point2(A.c.x + s1 * v.x * A.r, A.c.y + s1 * v.y * A.r),
                        Point2(B.c.x + s2 * v.x * B.r, B.c.y + s2 * v.y * B.r))


class Point2(Vector2, Geometry):
    def __repr__(self):
        return 'Point2(%.2f, %.2f)' % (self.x, self.y)

    def intersect(self, other):
        return other._intersect_point2(self)

    def _intersect_circle(self, other):
        return _intersect_point2_circle(self, other)

    def connect(self, other):
        return other._connect_point2(self)

    def _connect_point2(self, other):
        return LineSegment2(other, self)
    
    def _connect_line2(self, other):
        c = _connect_point2_line2(self, other)
        if c:
            return c._swap()

    def _connect_circle(self, other):
        c = _connect_point2_circle(self, other)
        if c:
            return c._swap()

class Line2(Geometry):
    __slots__ = ['p', 'v']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point2) and \
                   isinstance(args[1], Vector2) and \
                   type(args[2]) == float
            self.p = args[0].copy()
            self.v = args[1] * args[2] / abs(args[1])
        elif len(args) == 2:
            if isinstance(args[0], Point2) and isinstance(args[1], Point2):
                self.p = args[0].copy()
                self.v = args[1] - args[0]
            elif isinstance(args[0], Point2) and isinstance(args[1], Vector2):
                self.p = args[0].copy()
                self.v = args[1].copy()
            else:
                raise AttributeError, '%r' % (args,)
        elif len(args) == 1:
            if isinstance(args[0], Line2):
                self.p = args[0].p.copy()
                self.v = args[0].v.copy()
            else:
                raise AttributeError, '%r' % (args,)
        else:
            raise AttributeError, '%r' % (args,)
        
        if not self.v:
            raise AttributeError, 'Line has zero-length vector'

    def __copy__(self):
        return self.__class__(self.p, self.v)

    copy = __copy__

    def __repr__(self):
        return 'Line2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.v.x, self.v.y)

    p1 = property(lambda self: self.p)
    p2 = property(lambda self: Point2(self.p.x + self.v.x, 
                                      self.p.y + self.v.y))

    def _apply_transform(self, t):
        self.p = t * self.p
        self.v = t * self.v

    def _u_in(self, u):
        return True

    def intersect(self, other):
        return other._intersect_line2(self)

    def _intersect_line2(self, other):
        return _intersect_line2_line2(self, other)

    def _intersect_circle(self, other):
        return _intersect_line2_circle(self, other)

    def connect(self, other):
        return other._connect_line2(self)

    def _connect_point2(self, other):
        return _connect_point2_line2(other, self)

    def _connect_line2(self, other):
        return _connect_line2_line2(other, self)

    def _connect_circle(self, other):
        return _connect_circle_line2(other, self)

class Ray2(Line2):
    def __repr__(self):
        return 'Ray2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.v.x, self.v.y)

    def _u_in(self, u):
        return u &gt;= 0.0

class LineSegment2(Line2):
    def __repr__(self):
        return 'LineSegment2(&lt;%.2f, %.2f&gt; to &lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.x + self.v.x, self.p.y + self.v.y)

    def _u_in(self, u):
        return u &gt;= 0.0 and u &lt;= 1.0

    def __abs__(self):
        return abs(self.v)

    def magnitude_squared(self):
        return self.v.magnitude_squared()

    def _swap(self):
        # used by connect methods to switch order of points
        self.p = self.p2
        self.v *= -1
        return self

    length = property(lambda self: abs(self.v))

class Circle(Geometry):
    __slots__ = ['c', 'r']

    def __init__(self, center, radius):
        assert isinstance(center, Vector2) and type(radius) == float
        self.c = center.copy()
        self.r = radius

    def __copy__(self):
        return self.__class__(self.c, self.r)

    copy = __copy__

    def __repr__(self):
        return 'Circle(&lt;%.2f, %.2f&gt;, radius=%.2f)' % \
            (self.c.x, self.c.y, self.r)

    def _apply_transform(self, t):
        self.c = t * self.c

    def intersect(self, other):
        return other._intersect_circle(self)

    def _intersect_point2(self, other):
        return _intersect_point2_circle(other, self)

    def _intersect_line2(self, other):
        return _intersect_line2_circle(other, self)

    def connect(self, other):
        return other._connect_circle(self)

    def _connect_point2(self, other):
        return _connect_point2_circle(other, self)

    def _connect_line2(self, other):
        c = _connect_circle_line2(self, other)
        if c:
            return c._swap()

    def _connect_circle(self, other):
        return _connect_circle_circle(other, self)

# 3D Geometry
# -------------------------------------------------------------------------

def _connect_point3_line3(P, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((P.x - L.p.x) * L.v.x + \
         (P.y - L.p.y) * L.v.y + \
         (P.z - L.p.z) * L.v.z) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    return LineSegment3(P, Point3(L.p.x + u * L.v.x,
                                  L.p.y + u * L.v.y,
                                  L.p.z + u * L.v.z))

def _connect_point3_sphere(P, S):
    v = P - S.c
    v.normalize()
    v *= S.r
    return LineSegment3(P, Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z))

def _connect_point3_plane(p, plane):
    n = plane.n.normalized()
    d = p.dot(plane.n) - plane.k
    return LineSegment3(p, Point3(p.x - n.x * d, p.y - n.y * d, p.z - n.z * d))

def _connect_line3_line3(A, B):
    assert A.v and B.v
    p13 = A.p - B.p
    d1343 = p13.dot(B.v)
    d4321 = B.v.dot(A.v)
    d1321 = p13.dot(A.v)
    d4343 = B.v.magnitude_squared()
    denom = A.v.magnitude_squared() * d4343 - d4321 ** 2
    if denom == 0:
        # Parallel, connect an endpoint with a line
        if isinstance(B, Ray3) or isinstance(B, LineSegment3):
            return _connect_point3_line3(B.p, A)._swap()
        # No endpoint (or endpoint is on A), possibly choose arbitrary
        # point on line.
        return _connect_point3_line3(A.p, B)

    ua = (d1343 * d4321 - d1321 * d4343) / denom
    if not A._u_in(ua):
        ua = max(min(ua, 1.0), 0.0)
    ub = (d1343 + d4321 * ua) / d4343
    if not B._u_in(ub):
        ub = max(min(ub, 1.0), 0.0)
    return LineSegment3(Point3(A.p.x + ua * A.v.x,
                               A.p.y + ua * A.v.y,
                               A.p.z + ua * A.v.z),
                        Point3(B.p.x + ub * B.v.x,
                               B.p.y + ub * B.v.y,
                               B.p.z + ub * B.v.z))

def _connect_line3_plane(L, P):
    d = P.n.dot(L.v)
    if not d:
        # Parallel, choose an endpoint
        return _connect_point3_plane(L.p, P)
    u = (P.k - P.n.dot(L.p)) / d
    if not L._u_in(u):
        # intersects out of range, choose nearest endpoint
        u = max(min(u, 1.0), 0.0)
        return _connect_point3_plane(Point3(L.p.x + u * L.v.x,
                                            L.p.y + u * L.v.y,
                                            L.p.z + u * L.v.z), P)
    # Intersection
    return None

def _connect_sphere_line3(S, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((S.c.x - L.p.x) * L.v.x + \
         (S.c.y - L.p.y) * L.v.y + \
         (S.c.z - L.p.z) * L.v.z) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    point = Point3(L.p.x + u * L.v.x, L.p.y + u * L.v.y, L.p.z + u * L.v.z)
    v = (point - S.c)
    v.normalize()
    v *= S.r
    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
                        point)

def _connect_sphere_sphere(A, B):
    v = B.c - A.c
    d = v.magnitude()
    if A.r &gt;= B.r and d &lt; A.r:
        #centre B inside A
        s1,s2 = +1, +1
    elif B.r &gt; A.r and d &lt; B.r:
        #centre A inside B
        s1,s2 = -1, -1
    elif d &gt;= A.r and d &gt;= B.r:
        s1,s2 = +1, -1

    v.normalize()
    return LineSegment3(Point3(A.c.x + s1* v.x * A.r,
                               A.c.y + s1* v.y * A.r,
                               A.c.z + s1* v.z * A.r),
                        Point3(B.c.x + s2* v.x * B.r,
                               B.c.y + s2* v.y * B.r,
                               B.c.z + s2* v.z * B.r))

def _connect_sphere_plane(S, P):
    c = _connect_point3_plane(S.c, P)
    if not c:
        return None
    p2 = c.p2
    v = p2 - S.c
    v.normalize()
    v *= S.r
    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
                        p2)

def _connect_plane_plane(A, B):
    if A.n.cross(B.n):
        # Planes intersect
        return None
    else:
        # Planes are parallel, connect to arbitrary point
        return _connect_point3_plane(A._get_point(), B)

def _intersect_point3_sphere(P, S):
    return abs(P - S.c) &lt;= S.r
    
def _intersect_line3_sphere(L, S):
    a = L.v.magnitude_squared()
    b = 2 * (L.v.x * (L.p.x - S.c.x) + \
             L.v.y * (L.p.y - S.c.y) + \
             L.v.z * (L.p.z - S.c.z))
    c = S.c.magnitude_squared() + \
        L.p.magnitude_squared() - \
        2 * S.c.dot(L.p) - \
        S.r ** 2
    det = b ** 2 - 4 * a * c
    if det &lt; 0:
        return None
    sq = math.sqrt(det)
    u1 = (-b + sq) / (2 * a)
    u2 = (-b - sq) / (2 * a)
    if not L._u_in(u1):
        u1 = max(min(u1, 1.0), 0.0)
    if not L._u_in(u2):
        u2 = max(min(u2, 1.0), 0.0)
    return LineSegment3(Point3(L.p.x + u1 * L.v.x,
                               L.p.y + u1 * L.v.y,
                               L.p.z + u1 * L.v.z),
                        Point3(L.p.x + u2 * L.v.x,
                               L.p.y + u2 * L.v.y,
                               L.p.z + u2 * L.v.z))

def _intersect_line3_plane(L, P):
    d = P.n.dot(L.v)
    if not d:
        # Parallel
        return None
    u = (P.k - P.n.dot(L.p)) / d
    if not L._u_in(u):
        return None
    return Point3(L.p.x + u * L.v.x,
                  L.p.y + u * L.v.y,
                  L.p.z + u * L.v.z)

def _intersect_plane_plane(A, B):
    n1_m = A.n.magnitude_squared()
    n2_m = B.n.magnitude_squared()
    n1d2 = A.n.dot(B.n)
    det = n1_m * n2_m - n1d2 ** 2
    if det == 0:
        # Parallel
        return None
    c1 = (A.k * n2_m - B.k * n1d2) / det
    c2 = (B.k * n1_m - A.k * n1d2) / det
    return Line3(Point3(c1 * A.n.x + c2 * B.n.x,
                        c1 * A.n.y + c2 * B.n.y,
                        c1 * A.n.z + c2 * B.n.z), 
                 A.n.cross(B.n))

class Point3(Vector3, Geometry):
    def __repr__(self):
        return 'Point3(%.2f, %.2f, %.2f)' % (self.x, self.y, self.z)

    def intersect(self, other):
        return other._intersect_point3(self)

    def _intersect_sphere(self, other):
        return _intersect_point3_sphere(self, other)

    def connect(self, other):
        return other._connect_point3(self)

    def _connect_point3(self, other):
        if self != other:
            return LineSegment3(other, self)
        return None

    def _connect_line3(self, other):
        c = _connect_point3_line3(self, other)
        if c:
            return c._swap()
        
    def _connect_sphere(self, other):
        c = _connect_point3_sphere(self, other)
        if c:
            return c._swap()

    def _connect_plane(self, other):
        c = _connect_point3_plane(self, other)
        if c:
            return c._swap()

class Line3:
    __slots__ = ['p', 'v']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point3) and \
                   isinstance(args[1], Vector3) and \
                   type(args[2]) == float
            self.p = args[0].copy()
            self.v = args[1] * args[2] / abs(args[1])
        elif len(args) == 2:
            if isinstance(args[0], Point3) and isinstance(args[1], Point3):
                self.p = args[0].copy()
                self.v = args[1] - args[0]
            elif isinstance(args[0], Point3) and isinstance(args[1], Vector3):
                self.p = args[0].copy()
                self.v = args[1].copy()
            else:
                raise AttributeError, '%r' % (args,)
        elif len(args) == 1:
            if isinstance(args[0], Line3):
                self.p = args[0].p.copy()
                self.v = args[0].v.copy()
            else:
                raise AttributeError, '%r' % (args,)
        else:
            raise AttributeError, '%r' % (args,)
        
        # XXX This is annoying.
        #if not self.v:
        #    raise AttributeError, 'Line has zero-length vector'

    def __copy__(self):
        return self.__class__(self.p, self.v)

    copy = __copy__

    def __repr__(self):
        return 'Line3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)

    p1 = property(lambda self: self.p)
    p2 = property(lambda self: Point3(self.p.x + self.v.x, 
                                      self.p.y + self.v.y,
                                      self.p.z + self.v.z))

    def _apply_transform(self, t):
        self.p = t * self.p
        self.v = t * self.v

    def _u_in(self, u):
        return True

    def intersect(self, other):
        return other._intersect_line3(self)

    def _intersect_sphere(self, other):
        return _intersect_line3_sphere(self, other)

    def _intersect_plane(self, other):
        return _intersect_line3_plane(self, other)

    def connect(self, other):
        return other._connect_line3(self)

    def _connect_point3(self, other):
        return _connect_point3_line3(other, self)

    def _connect_line3(self, other):
        return _connect_line3_line3(other, self)

    def _connect_sphere(self, other):
        return _connect_sphere_line3(other, self)

    def _connect_plane(self, other):
        c = _connect_line3_plane(self, other)
        if c:
            return c

class Ray3(Line3):
    def __repr__(self):
        return 'Ray3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)

    def _u_in(self, u):
        return u &gt;= 0.0

class LineSegment3(Line3):
    def __repr__(self):
        return 'LineSegment3(&lt;%.2f, %.2f, %.2f&gt; to &lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z,
             self.p.x + self.v.x, self.p.y + self.v.y, self.p.z + self.v.z)

    def _u_in(self, u):
        return u &gt;= 0.0 and u &lt;= 1.0

    def __abs__(self):
        return abs(self.v)

    def magnitude_squared(self):
        return self.v.magnitude_squared()

    def _swap(self):
        # used by connect methods to switch order of points
        self.p = self.p2
        self.v *= -1
        return self

    length = property(lambda self: abs(self.v))

class Sphere:
    __slots__ = ['c', 'r']

    def __init__(self, center, radius):
        assert isinstance(center, Vector3) and type(radius) == float
        self.c = center.copy()
        self.r = radius

    def __copy__(self):
        return self.__class__(self.c, self.r)

    copy = __copy__

    def __repr__(self):
        return 'Sphere(&lt;%.2f, %.2f, %.2f&gt;, radius=%.2f)' % \
            (self.c.x, self.c.y, self.c.z, self.r)

    def _apply_transform(self, t):
        self.c = t * self.c

    def intersect(self, other):
        return other._intersect_sphere(self)

    def _intersect_point3(self, other):
        return _intersect_point3_sphere(other, self)

    def _intersect_line3(self, other):
        return _intersect_line3_sphere(other, self)

    def connect(self, other):
        return other._connect_sphere(self)

    def _connect_point3(self, other):
        return _connect_point3_sphere(other, self)

    def _connect_line3(self, other):
        c = _connect_sphere_line3(self, other)
        if c:
            return c._swap()

    def _connect_sphere(self, other):
        return _connect_sphere_sphere(other, self)

    def _connect_plane(self, other):
        c = _connect_sphere_plane(self, other)
        if c:
            return c

class Plane:
    # n.p = k, where n is normal, p is point on plane, k is constant scalar
    __slots__ = ['n', 'k']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point3) and \
                   isinstance(args[1], Point3) and \
                   isinstance(args[2], Point3)
            self.n = (args[1] - args[0]).cross(args[2] - args[0])
            self.n.normalize()
            self.k = self.n.dot(args[0])
        elif len(args) == 2:
            if isinstance(args[0], Point3) and isinstance(args[1], Vector3):
                self.n = args[1].normalized()
                self.k = self.n.dot(args[0])
            elif isinstance(args[0], Vector3) and type(args[1]) == float:
                self.n = args[0].normalized()
                self.k = args[1]
            else:
                raise AttributeError, '%r' % (args,)

        else:
            raise AttributeError, '%r' % (args,)
        
        if not self.n:
            raise AttributeError, 'Points on plane are colinear'

    def __copy__(self):
        return self.__class__(self.n, self.k)

    copy = __copy__

    def __repr__(self):
        return 'Plane(&lt;%.2f, %.2f, %.2f&gt;.p = %.2f)' % \
            (self.n.x, self.n.y, self.n.z, self.k)

    def _get_point(self):
        # Return an arbitrary point on the plane
        if self.n.z:
            return Point3(0., 0., self.k / self.n.z)
        elif self.n.y:
            return Point3(0., self.k / self.n.y, 0.)
        else:
            return Point3(self.k / self.n.x, 0., 0.)

    def _apply_transform(self, t):
        p = t * self._get_point()
        self.n = t * self.n
        self.k = self.n.dot(p)

    def intersect(self, other):
        return other._intersect_plane(self)

    def _intersect_line3(self, other):
        return _intersect_line3_plane(other, self)

    def _intersect_plane(self, other):
        return _intersect_plane_plane(self, other)

    def connect(self, other):
        return other._connect_plane(self)

    def _connect_point3(self, other):
        return _connect_point3_plane(other, self)

    def _connect_line3(self, other):
        return _connect_line3_plane(other, self)

    def _connect_sphere(self, other):
        return _connect_sphere_plane(other, self)

    def _connect_plane(self, other):
        return _connect_plane_plane(other, self)
</t>
<t tx="amd_yen.20130426011410.8912">https://github.com/vmlaker/pythonwildmagic

這是一個 http://www.geometrictools.com/ C++ 程式庫的 Python 3 介面套件.</t>
<t tx="ekr.20070615131954"></t>
</tnodes>
</leo_file>
