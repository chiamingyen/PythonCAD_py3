<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20170331152739.1"><vh>@settings</vh>
<v t="leo.20170331152739.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20170331152739.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20170331234345.1"><vh>準備改為 PyQt5</vh>
<v t="leo.20170402112029.1"><vh>進度</vh></v>
<v t="leo.20170403085042.1"><vh>bugs</vh></v>
<v t="leo.20170402122413.1"><vh>PySide 可能會是選項</vh></v>
</v>
<v t="1.20130426141258.2394" a="E"><vh>PythonCAD 程式碼</vh>
<v t="leo.20170331153122.1"><vh>從 @file 過渡到 @clean</vh></v>
<v t="leo.20170402113716.1"><vh>PyQt4 轉為 PyQt5</vh></v>
<v t="leo.20170402114140.1"><vh>差異註記</vh></v>
<v t="leo.20170404160530.1"><vh>除錯過程</vh></v>
<v t="amd_yen.20130426011410.8908"><vh>參考資料</vh>
<v t="amd_yen.20130426011410.8909"><vh>Pyeuclid</vh></v>
<v t="amd_yen.20130426011410.8910"><vh>@edit refs/simgeo.py</vh></v>
<v t="amd_yen.20130426011410.8911"><vh>@edit refs/test_simgeo.py</vh></v>
<v t="amd_yen.20130426011410.8912"><vh>@url Pythonwildmagic</vh></v>
</v>
<v t="1.20130426141258.2396" a="E"><vh>@clean customevent.py</vh>
<v t="1.20130426141258.2397"><vh>&lt;&lt;declarations&gt;&gt; (customevent)</vh></v>
<v t="1.20130426141258.2398" a="E"><vh>class testCmdLine</vh>
<v t="1.20130426141258.2399"><vh>__init__</vh></v>
<v t="1.20130426141258.2400"><vh>_inizializeCommand</vh></v>
<v t="1.20130426141258.2401"><vh>_addCustomEvent</vh></v>
<v t="1.20130426141258.2402"><vh>imputCommand</vh></v>
<v t="1.20130426141258.2403"><vh>performCommand</vh></v>
<v t="1.20130426141258.2404"><vh>convertToBool</vh></v>
<v t="1.20130426141258.2405"><vh>convertToInt</vh></v>
<v t="1.20130426141258.2406"><vh>convertToFloat</vh></v>
<v t="1.20130426141258.2407"><vh>convertToPoint</vh></v>
<v t="1.20130426141258.2408"><vh>outputMsg</vh></v>
</v>
<v t="1.20130426141258.2409"><vh>printEntity</vh></v>
<v t="1.20130426141258.2410"><vh>class GetEnts</vh>
<v t="1.20130426141258.2411"><vh>__init__</vh></v>
<v t="1.20130426141258.2412"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2413"><vh>class UnDo</vh>
<v t="1.20130426141258.2414"><vh>__init__</vh></v>
<v t="1.20130426141258.2415"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2416"><vh>class ReDo</vh>
<v t="1.20130426141258.2417"><vh>__init__</vh></v>
<v t="1.20130426141258.2418"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2419" a="E"><vh>class GetActiveDoc</vh>
<v t="1.20130426141258.2420"><vh>__init__</vh></v>
<v t="1.20130426141258.2421"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2422" a="E"><vh>class SetActiveDoc</vh>
<v t="1.20130426141258.2423"><vh>__init__</vh></v>
<v t="1.20130426141258.2424"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2425" a="E"><vh>class GetDocuments</vh>
<v t="1.20130426141258.2426"><vh>__init__</vh></v>
<v t="1.20130426141258.2427"><vh>applyCommand</vh></v>
<v t="1.20130426141258.2428"><vh>showDocuments</vh></v>
</v>
<v t="1.20130426141258.2429"><vh>class CreateStyle</vh>
<v t="1.20130426141258.2430"><vh>__init__</vh></v>
<v t="1.20130426141258.2431"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2432"><vh>class EntityExsist</vh>
<v t="1.20130426141258.2433"><vh>__init__</vh></v>
<v t="1.20130426141258.2434"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2435"><vh>class DeleteEntity</vh>
<v t="1.20130426141258.2436"><vh>__init__</vh></v>
<v t="1.20130426141258.2437"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2438"><vh>class EntityInfo</vh>
<v t="1.20130426141258.2439"><vh>__init__</vh></v>
<v t="1.20130426141258.2440"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2441"><vh>class PrintHelp</vh>
<v t="1.20130426141258.2442"><vh>__init__</vh></v>
<v t="1.20130426141258.2443"><vh>__next__</vh></v>
<v t="1.20130426141258.2444"><vh>applyCommand</vh></v>
</v>
<v t="1.20130426141258.2445" a="E"><vh>class TestKernel</vh>
<v t="1.20130426141258.2446"><vh>__init__</vh></v>
<v t="1.20130426141258.2447"><vh>__next__</vh></v>
<v t="1.20130426141258.2448"><vh>applyCommand</vh></v>
<v t="1.20130426141258.2449"><vh>featureTest</vh></v>
<v t="1.20130426141258.2450"><vh>testGeoChamfer</vh></v>
<v t="1.20130426141258.2451"><vh>testChamferCommand</vh></v>
<v t="1.20130426141258.2452"><vh>getRandomPoint</vh></v>
<v t="1.20130426141258.2453"><vh>performCommandRandomly</vh></v>
</v>
<v t="1.20130426141258.2454"><vh>class EasyTest</vh>
<v t="1.20130426141258.2455"><vh>__init__</vh></v>
<v t="1.20130426141258.2456"><vh>__next__</vh></v>
<v t="1.20130426141258.2457"><vh>applyCommand</vh></v>
<v t="1.20130426141258.2458"><vh>MassiveDelete</vh></v>
<v t="1.20130426141258.2459"><vh>easyTest</vh></v>
<v t="1.20130426141258.2460"><vh>trim</vh></v>
<v t="1.20130426141258.2461"><vh>rotate</vh></v>
<v t="1.20130426141258.2462"><vh>testMove</vh></v>
<v t="1.20130426141258.2463"><vh>testMirror</vh></v>
<v t="1.20130426141258.2464"><vh>testFillet</vh></v>
<v t="1.20130426141258.2465"><vh>testBisector</vh></v>
<v t="1.20130426141258.2466"><vh>multitest</vh></v>
<v t="1.20130426141258.2467"><vh>testFillet1</vh></v>
<v t="1.20130426141258.2468"><vh>testFillet2</vh></v>
<v t="1.20130426141258.2469"><vh>testChamfer</vh></v>
</v>
</v>
<v t="1.20130426141258.2470"><vh>@clean pythoncad_qt.py</vh>
<v t="1.20130426141258.2471"><vh>&lt;&lt;declarations&gt;&gt; (pythoncad_qt)</vh></v>
<v t="1.20130426141258.2472"><vh>getPythonCAD</vh></v>
</v>
<v t="1.20130426141258.2473"><vh>@clean test_sympy.py</vh>
<v t="1.20130426141258.2474"><vh>&lt;&lt;declarations&gt;&gt; (test_sympy)</vh></v>
</v>
<v t="1.20130426141258.2475"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.2476" a="E"><vh>@path Generic</vh>
<v t="1.20130426141258.2477" a="E"><vh>@clean application.py</vh>
<v t="1.20130426141258.2478"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="1.20130426141258.2479" a="E"><vh>class Application</vh>
<v t="1.20130426141258.2480"><vh>__init__</vh></v>
<v t="1.20130426141258.2481"><vh>getRecentFiles</vh></v>
<v t="1.20130426141258.2482"><vh>addRecentFiles</vh></v>
<v t="1.20130426141258.2483"><vh>getCommand</vh></v>
<v t="1.20130426141258.2484"><vh>getCommandList</vh></v>
<v t="1.20130426141258.2485"><vh>newDocument</vh></v>
<v t="1.20130426141258.2486"><vh>openDocument</vh></v>
<v t="1.20130426141258.2487"><vh>saveAs</vh></v>
<v t="1.20130426141258.2488"><vh>closeDocument</vh></v>
<v t="1.20130426141258.2489"><vh>ActiveDocument</vh></v>
<v t="1.20130426141258.2490"><vh>ActiveDocument</vh></v>
<v t="1.20130426141258.2491"><vh>getDocuments</vh></v>
<v t="1.20130426141258.2492"><vh>getApplicationStyleList</vh></v>
<v t="1.20130426141258.2493"><vh>getApplicationStyle</vh></v>
<v t="1.20130426141258.2494"><vh>setApplicationStyle</vh></v>
<v t="1.20130426141258.2495"><vh>deleteApplicationStyle</vh></v>
<v t="1.20130426141258.2496"><vh>getApplicationSetting</vh></v>
<v t="1.20130426141258.2497"><vh>updateApplicationSetting</vh></v>
</v>
</v>
<v t="1.20130426141258.2498"><vh>@clean application_test.py</vh>
<v t="1.20130426141258.2499"><vh>&lt;&lt;declarations&gt;&gt; (application_test)</vh></v>
<v t="1.20130426141258.2500"><vh>testSympySegment</vh></v>
<v t="1.20130426141258.2501"><vh>testSympyCline</vh></v>
<v t="1.20130426141258.2502"><vh>testSympyCircle</vh></v>
<v t="1.20130426141258.2503"><vh>testSympyEllipse</vh></v>
<v t="1.20130426141258.2504"><vh>TestSympy</vh></v>
<v t="1.20130426141258.2505"><vh>segment_segmet</vh></v>
<v t="1.20130426141258.2506"><vh>segment_cline</vh></v>
<v t="1.20130426141258.2507"><vh>segment_circle</vh></v>
<v t="1.20130426141258.2508"><vh>segment_ellipse</vh></v>
<v t="1.20130426141258.2509"><vh>TestIntersection</vh></v>
</v>
<v t="1.20130426141258.2510"><vh>@clean test_kernel.py</vh></v>
<v t="1.20130426141258.2577"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.2578" a="E"><vh>@path Kernel</vh>
<v t="1.20130426141258.2579"><vh>@clean binarytree.py</vh>
<v t="1.20130426141258.2580"><vh>class BinaryTree</vh>
<v t="1.20130426141258.2581"><vh>__init__</vh></v>
<v t="1.20130426141258.2582"><vh>__repr__</vh></v>
<v t="1.20130426141258.2583"><vh>lookUp</vh></v>
<v t="1.20130426141258.2584"><vh>insert</vh></v>
</v>
<v t="1.20130426141258.2585"><vh>class EmptyNode</vh>
<v t="1.20130426141258.2586"><vh>__repr__</vh></v>
<v t="1.20130426141258.2587"><vh>lookUp</vh></v>
<v t="1.20130426141258.2588"><vh>insert</vh></v>
</v>
<v t="1.20130426141258.2589"><vh>class BinaryNode</vh>
<v t="1.20130426141258.2590"><vh>__init__</vh></v>
<v t="1.20130426141258.2591"><vh>lookUp</vh></v>
<v t="1.20130426141258.2592"><vh>insert</vh></v>
<v t="1.20130426141258.2593"><vh>__repr__</vh></v>
</v>
<v t="1.20130426141258.2594"><vh>testBinaryTree</vh></v>
</v>
<v t="1.20130426141258.2595"><vh>@clean composedentity.py</vh>
<v t="1.20130426141258.2596"><vh>&lt;&lt;declarations&gt;&gt; (composedentity)</vh></v>
<v t="1.20130426141258.2597"><vh>class ComposedEntity</vh>
<v t="1.20130426141258.2598"><vh>__init__</vh></v>
<v t="1.20130426141258.2599"><vh>getChildEnt</vh></v>
<v t="1.20130426141258.2600"><vh>setChildEnt</vh></v>
<v t="1.20130426141258.2601"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.2602"><vh>setConstructionElement</vh></v>
</v>
</v>
<v t="1.20130426141258.2603" a="E"><vh>@clean document.py</vh>
<v t="1.20130426141258.2604"><vh>&lt;&lt;declarations&gt;&gt; (document)</vh></v>
<v t="1.20130426141258.2605" a="E"><vh>class Document</vh>
<v t="1.20130426141258.2606"><vh>__init__</vh></v>
<v t="1.20130426141258.2607"><vh>addPropertie</vh></v>
<v t="1.20130426141258.2608"><vh>getPropertie</vh></v>
<v t="1.20130426141258.2609"><vh>properties</vh></v>
<v t="1.20130426141258.2610"><vh>getMainStyle</vh></v>
<v t="1.20130426141258.2611"><vh>getDbSettingsObject</vh></v>
<v t="1.20130426141258.2612"><vh>startMassiveCreation</vh></v>
<v t="1.20130426141258.2613"><vh>stopMassiveCreation</vh></v>
<v t="1.20130426141258.2614"><vh>getEntity</vh></v>
<v t="1.20130426141258.2615"><vh>getEntityFromType</vh></v>
<v t="1.20130426141258.2616"><vh>getAllDrawingEntity</vh></v>
<v t="1.20130426141258.2617"><vh>getEntInDbTableFormat</vh></v>
<v t="1.20130426141258.2618"><vh>convertToGeometricalEntity</vh></v>
<v t="1.20130426141258.2619"><vh>haveDrawingEntitys</vh></v>
<v t="1.20130426141258.2620"><vh>saveSympyEnt</vh></v>
<v t="1.20130426141258.2621"><vh>saveEntity</vh></v>
<v t="1.20130426141258.2622"><vh>_saveComposedEntity</vh></v>
<v t="1.20130426141258.2623"><vh>_saveGeometricalEntity</vh></v>
<v t="1.20130426141258.2624"><vh>_saveDrwEnt</vh></v>
<v t="1.20130426141258.2625"><vh>getNewId</vh></v>
<v t="1.20130426141258.2626"><vh>_getCelements</vh></v>
<v t="1.20130426141258.2627"><vh>_saveSettings</vh></v>
<v t="1.20130426141258.2628"><vh>_saveStyle</vh></v>
<v t="1.20130426141258.2629"><vh>_saveLayer</vh></v>
<v t="1.20130426141258.2630"><vh>_savePyCadEnt</vh></v>
<v t="1.20130426141258.2631"><vh>_saveDbEnt</vh></v>
<v t="1.20130426141258.2632"><vh>entityExsist</vh></v>
<v t="1.20130426141258.2633"><vh>getStyle</vh></v>
<v t="1.20130426141258.2634"><vh>getActiveStyle</vh></v>
<v t="1.20130426141258.2635"><vh>setActiveStyle</vh></v>
<v t="1.20130426141258.2636"><vh>getStyleList</vh></v>
<v t="1.20130426141258.2637"><vh>unDo</vh></v>
<v t="1.20130426141258.2638"><vh>reDo</vh></v>
<v t="1.20130426141258.2639"><vh>clearUnDoHistory</vh></v>
<v t="1.20130426141258.2640"><vh>release</vh></v>
<v t="1.20130426141258.2641"><vh>deleteEntity</vh></v>
<v t="1.20130426141258.2642"><vh>massiveDelete</vh></v>
<v t="1.20130426141258.2643"><vh>hideEntity</vh></v>
<v t="1.20130426141258.2644"><vh>unHideEntity</vh></v>
<v t="1.20130426141258.2645"><vh>_hide</vh></v>
<v t="1.20130426141258.2646"><vh>importExternalFormat</vh></v>
<v t="1.20130426141258.2647"><vh>exportExternalFormat</vh></v>
<v t="1.20130426141258.2648"><vh>getTreeLayer</vh></v>
<v t="1.20130426141258.2649"><vh>getAllChildrenType</vh></v>
<v t="1.20130426141258.2650"><vh>getRelatioObject</vh></v>
<v t="1.20130426141258.2651"><vh>getName</vh></v>
</v>
</v>
<v t="1.20130426141258.2652"><vh>@clean entity.py</vh>
<v t="1.20130426141258.2653"><vh>&lt;&lt;declarations&gt;&gt; (entity)</vh></v>
<v t="1.20130426141258.2654"><vh>class Entity</vh>
<v t="1.20130426141258.2655"><vh>__init__</vh></v>
<v t="1.20130426141258.2656"><vh>__str__</vh></v>
<v t="1.20130426141258.2657"><vh>getBBox</vh></v>
<v t="1.20130426141258.2658"><vh>updateBBox</vh></v>
<v t="1.20130426141258.2659"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.2660"><vh>setConstructionElements</vh></v>
<v t="1.20130426141258.2661"><vh>toGeometricalEntity</vh></v>
</v>
</v>
<v t="1.20130426141258.2662" a="E"><vh>@clean exception.py</vh>
<v t="1.20130426141258.2663"><vh>class EntityMissing</vh>
<v t="1.20130426141258.2664"><vh>__init__</vh></v>
<v t="1.20130426141258.2665"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2666"><vh>class NoDefaultValue</vh>
<v t="1.20130426141258.2667"><vh>__init__</vh></v>
<v t="1.20130426141258.2668"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2669"><vh>class NotImplementedError</vh>
<v t="1.20130426141258.2670"><vh>__init__</vh></v>
<v t="1.20130426141258.2671"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2672"><vh>class DeprecatedError</vh>
<v t="1.20130426141258.2673"><vh>__init__</vh></v>
<v t="1.20130426141258.2674"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2675"><vh>class StructuralError</vh>
<v t="1.20130426141258.2676"><vh>__init__</vh></v>
<v t="1.20130426141258.2677"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2678"><vh>class EmptyFile</vh>
<v t="1.20130426141258.2679"><vh>__init__</vh></v>
<v t="1.20130426141258.2680"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2681"><vh>class StyleUndefinedAttribute</vh>
<v t="1.20130426141258.2682"><vh>__init__</vh></v>
<v t="1.20130426141258.2683"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2684"><vh>class PythonCadWarning</vh>
<v t="1.20130426141258.2685"><vh>__init__</vh></v>
<v t="1.20130426141258.2686"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2687"><vh>class EmptyDbSelect</vh>
<v t="1.20130426141258.2688"><vh>__init__</vh></v>
<v t="1.20130426141258.2689"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2690"><vh>class EntityMissing</vh>
<v t="1.20130426141258.2691"><vh>__init__</vh></v>
<v t="1.20130426141258.2692"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2693"><vh>class UndoDbExc</vh>
<v t="1.20130426141258.2694"><vh>__init__</vh></v>
<v t="1.20130426141258.2695"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2696"><vh>class EntDb</vh>
<v t="1.20130426141258.2697"><vh>__init__</vh></v>
<v t="1.20130426141258.2698"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2699"><vh>class DxfReport</vh>
<v t="1.20130426141258.2700"><vh>__init__</vh></v>
<v t="1.20130426141258.2701"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2702"><vh>class DxfUnsupportedFormat</vh>
<v t="1.20130426141258.2703"><vh>__init__</vh></v>
<v t="1.20130426141258.2704"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2705" a="E"><vh>class PyCadWrongCommand</vh>
<v t="1.20130426141258.2706"><vh>__init__</vh></v>
<v t="1.20130426141258.2707"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2708" a="E"><vh>class PyCadWrongImputData</vh>
<v t="1.20130426141258.2709"><vh>__init__</vh></v>
<v t="1.20130426141258.2710"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2711"><vh>class CommandException</vh>
<v t="1.20130426141258.2712"><vh>__init__</vh></v>
<v t="1.20130426141258.2713"><vh>__str__</vh></v>
</v>
<v t="1.20130426141258.2714"><vh>class ExcPoint</vh></v>
<v t="1.20130426141258.2715"><vh>class ExcLenght</vh></v>
<v t="1.20130426141258.2716"><vh>class ExcAngle</vh></v>
<v t="1.20130426141258.2717"><vh>class ExcText</vh></v>
<v t="1.20130426141258.2718"><vh>class ExcInt</vh></v>
<v t="1.20130426141258.2719"><vh>class ExcBool</vh></v>
<v t="1.20130426141258.2720"><vh>class ExcEntity</vh></v>
<v t="1.20130426141258.2721"><vh>class ExcMultiEntity</vh></v>
<v t="1.20130426141258.2722"><vh>class ExcEntityPoint</vh></v>
<v t="1.20130426141258.2723"><vh>class ExcDicTuple</vh></v>
</v>
<v t="1.20130426141258.2724"><vh>@clean initsetting.py</vh>
<v t="1.20130426141258.2725"><vh>&lt;&lt;declarations&gt;&gt; (initsetting)</vh></v>
<v t="1.20130426141258.2726"><vh>getDefaultStyle</vh></v>
</v>
<v t="1.20130426141258.2727"><vh>@clean layer.py</vh>
<v t="1.20130426141258.2728"><vh>class Layer</vh>
<v t="1.20130426141258.2729"><vh>__init__</vh></v>
<v t="1.20130426141258.2730"><vh>name</vh></v>
<v t="1.20130426141258.2731"><vh>name</vh></v>
<v t="1.20130426141258.2732"><vh>Visible</vh></v>
<v t="1.20130426141258.2733"><vh>Visible</vh></v>
</v>
</v>
<v t="1.20130426141258.2734"><vh>@clean layertree.py</vh>
<v t="1.20130426141258.2735"><vh>&lt;&lt;declarations&gt;&gt; (layertree)</vh></v>
<v t="1.20130426141258.2736"><vh>class LayerTree</vh>
<v t="1.20130426141258.2737"><vh>__init__</vh></v>
<v t="1.20130426141258.2738"><vh>setActiveLayer</vh></v>
<v t="1.20130426141258.2739"><vh>getActiveLater</vh></v>
<v t="1.20130426141258.2740"><vh>insert</vh></v>
<v t="1.20130426141258.2741"><vh>_getLayerConstructionElement</vh></v>
<v t="1.20130426141258.2742"><vh>getLayerChildrenLayer</vh></v>
<v t="1.20130426141258.2743"><vh>getLayerChildIds</vh></v>
<v t="1.20130426141258.2744"><vh>getLayerChildren</vh></v>
<v t="1.20130426141258.2745"><vh>getEntLayerDb</vh></v>
<v t="1.20130426141258.2746"><vh>getLayerTree</vh></v>
<v t="1.20130426141258.2747"><vh>getLayerdbTree</vh></v>
<v t="1.20130426141258.2748"><vh>getParentLayer</vh></v>
<v t="1.20130426141258.2749"><vh>delete</vh></v>
<v t="1.20130426141258.2750"><vh>deleteLayerEntity</vh></v>
<v t="1.20130426141258.2751"><vh>rename</vh></v>
<v t="1.20130426141258.2752"><vh>_rename</vh></v>
<v t="1.20130426141258.2753"><vh>_Hide</vh></v>
<v t="1.20130426141258.2754"><vh>isMainLayer</vh></v>
<v t="1.20130426141258.2755"><vh>Hide</vh></v>
<v t="1.20130426141258.2756"><vh>hideLayerEntity</vh></v>
</v>
</v>
<v t="1.20130426141258.2757" a="E"><vh>@clean pycadevent.py</vh>
<v t="1.20130426141258.2758" a="E"><vh>class PyCadEvent</vh>
<v t="1.20130426141258.2759"><vh>__init__</vh></v>
<v t="1.20130426141258.2760"><vh>handle</vh></v>
<v t="1.20130426141258.2761"><vh>unhandle</vh></v>
<v t="1.20130426141258.2762"><vh>fire</vh></v>
<v t="1.20130426141258.2763"><vh>getHandlerCount</vh></v>
</v>
</v>
<v t="1.20130426141258.2764"><vh>@clean pycadtransaction.py</vh>
<v t="1.20130426141258.2765"><vh>class Transaction</vh>
<v t="1.20130426141258.2766"><vh>__init__</vh></v>
<v t="1.20130426141258.2767"><vh>_GetCursor</vh></v>
<v t="1.20130426141258.2768"><vh>Close</vh></v>
</v>
</v>
<v t="1.20130426141258.2769"><vh>@clean settings.py</vh>
<v t="1.20130426141258.2770"><vh>class Settings</vh>
<v t="1.20130426141258.2771"><vh>__init__</vh></v>
<v t="1.20130426141258.2772"><vh>name</vh></v>
<v t="1.20130426141258.2773"><vh>name</vh></v>
<v t="1.20130426141258.2774"><vh>layerName</vh></v>
<v t="1.20130426141258.2775"><vh>layerName</vh></v>
<v t="1.20130426141258.2776"><vh>getVariable</vh></v>
<v t="1.20130426141258.2777"><vh>setVariable</vh></v>
</v>
</v>
<v t="1.20130426141258.2778"><vh>@clean unitparser.py</vh>
<v t="1.20130426141258.2779"><vh>&lt;&lt;declarations&gt;&gt; (unitparser)</vh></v>
<v t="1.20130426141258.2780"><vh>convertAngle</vh></v>
<v t="1.20130426141258.2781"><vh>sympyConvertAngle</vh></v>
<v t="1.20130426141258.2782"><vh>convertLengh</vh></v>
<v t="1.20130426141258.2783"><vh>sympyConvertLeng</vh></v>
</v>
<v t="1.20130426141258.2784"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.2785"><vh>@path Command</vh>
<v t="1.20130426141258.2786"><vh>@@clean arccommand.py</vh>
<v t="1.20130426141258.2787"><vh>&lt;&lt;declarations&gt;&gt; (arccommand)</vh></v>
<v t="1.20130426141258.2788"><vh>class ArcCommand</vh>
<v t="1.20130426141258.2789"><vh>__init__</vh></v>
<v t="1.20130426141258.2790"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2791"><vh>@@clean basecommand.py</vh>
<v t="1.20130426141258.2792"><vh>&lt;&lt;declarations&gt;&gt; (basecommand)</vh></v>
<v t="1.20130426141258.2793"><vh>class BaseCommand</vh>
<v t="1.20130426141258.2794"><vh>__init__</vh></v>
<v t="1.20130426141258.2795"><vh>__iter__</vh></v>
<v t="1.20130426141258.2796"><vh>__setitem__</vh></v>
<v t="1.20130426141258.2797"><vh>resetToDefault</vh></v>
<v t="1.20130426141258.2798"><vh>applyDefault</vh></v>
<v t="1.20130426141258.2799"><vh>reset</vh></v>
<v t="1.20130426141258.2800"><vh>valueIndex</vh></v>
<v t="1.20130426141258.2801"><vh>__next__</vh></v>
<v t="1.20130426141258.2802"><vh>activeException</vh></v>
<v t="1.20130426141258.2803"><vh>activeMessage</vh></v>
<v t="1.20130426141258.2804"><vh>performDefaultValue</vh></v>
<v t="1.20130426141258.2805"><vh>activeDefaultValue</vh></v>
<v t="1.20130426141258.2806"><vh>getActiveDefaultValue</vh></v>
<v t="1.20130426141258.2807"><vh>previus</vh></v>
<v t="1.20130426141258.2808"><vh>keys</vh></v>
<v t="1.20130426141258.2809"><vh>lenght</vh></v>
<v t="1.20130426141258.2810"><vh>applyCommand</vh></v>
<v t="1.20130426141258.2811"><vh>translateCmdValue</vh></v>
<v t="1.20130426141258.2812"><vh>getIdsString</vh></v>
<v t="1.20130426141258.2813"><vh>convertToBool</vh></v>
<v t="1.20130426141258.2814"><vh>convertToInt</vh></v>
<v t="1.20130426141258.2815"><vh>convertToFloat</vh></v>
<v t="1.20130426141258.2816"><vh>convertToAngle</vh></v>
</v>
</v>
<v t="1.20130426141258.2817"><vh>@@clean bisectorcommand.py</vh>
<v t="1.20130426141258.2818"><vh>&lt;&lt;declarations&gt;&gt; (bisectorcommand)</vh></v>
<v t="1.20130426141258.2819"><vh>class BisectorCommand</vh>
<v t="1.20130426141258.2820"><vh>__init__</vh></v>
<v t="1.20130426141258.2821"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2822"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2823"><vh>@@clean ccirclecommand.py</vh>
<v t="1.20130426141258.2824"><vh>&lt;&lt;declarations&gt;&gt; (ccirclecommand)</vh></v>
<v t="1.20130426141258.2825"><vh>class CCircleCommand</vh>
<v t="1.20130426141258.2826"><vh>__init__</vh></v>
<v t="1.20130426141258.2827"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2828"><vh>@@clean chamfercommand.py</vh>
<v t="1.20130426141258.2829"><vh>&lt;&lt;declarations&gt;&gt; (chamfercommand)</vh></v>
<v t="1.20130426141258.2830"><vh>class ChamferCommand</vh>
<v t="1.20130426141258.2831"><vh>__init__</vh></v>
<v t="1.20130426141258.2832"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2833"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2834"><vh>@@clean circlecommand.py</vh>
<v t="1.20130426141258.2835"><vh>&lt;&lt;declarations&gt;&gt; (circlecommand)</vh></v>
<v t="1.20130426141258.2836"><vh>class CircleCommand</vh>
<v t="1.20130426141258.2837"><vh>__init__</vh></v>
<v t="1.20130426141258.2838"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2839"><vh>@@clean clinecommand.py</vh>
<v t="1.20130426141258.2840"><vh>&lt;&lt;declarations&gt;&gt; (clinecommand)</vh></v>
<v t="1.20130426141258.2841"><vh>class CLineCommand</vh>
<v t="1.20130426141258.2842"><vh>__init__</vh></v>
<v t="1.20130426141258.2843"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2844"><vh>@@clean copycommand.py</vh>
<v t="1.20130426141258.2845"><vh>&lt;&lt;declarations&gt;&gt; (copycommand)</vh></v>
<v t="1.20130426141258.2846"><vh>class CopyCommand</vh>
<v t="1.20130426141258.2847"><vh>__init__</vh></v>
<v t="1.20130426141258.2848"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2849"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2850"><vh>@@clean deletecommand.py</vh>
<v t="1.20130426141258.2851"><vh>&lt;&lt;declarations&gt;&gt; (deletecommand)</vh></v>
<v t="1.20130426141258.2852"><vh>class DeleteCommand</vh>
<v t="1.20130426141258.2853"><vh>__init__</vh></v>
<v t="1.20130426141258.2854"><vh>applyDefault</vh></v>
<v t="1.20130426141258.2855"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2856"><vh>@@clean dimensioncommand.py</vh>
<v t="1.20130426141258.2857"><vh>&lt;&lt;declarations&gt;&gt; (dimensioncommand)</vh></v>
<v t="1.20130426141258.2858"><vh>class DimensionCommand</vh>
<v t="1.20130426141258.2859"><vh>__init__</vh></v>
<v t="1.20130426141258.2860"><vh>getAngle</vh></v>
<v t="1.20130426141258.2861"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2862"><vh>@@clean ellipsecommand.py</vh>
<v t="1.20130426141258.2863"><vh>&lt;&lt;declarations&gt;&gt; (ellipsecommand)</vh></v>
<v t="1.20130426141258.2864"><vh>class EllipseCommand</vh>
<v t="1.20130426141258.2865"><vh>__init__</vh></v>
<v t="1.20130426141258.2866"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2867"><vh>@@clean filletcommand.py</vh>
<v t="1.20130426141258.2868"><vh>&lt;&lt;declarations&gt;&gt; (filletcommand)</vh></v>
<v t="1.20130426141258.2869"><vh>class FilletCommand</vh>
<v t="1.20130426141258.2870"><vh>__init__</vh></v>
<v t="1.20130426141258.2871"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2872"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2873"><vh>@@clean mirrorcommand.py</vh>
<v t="1.20130426141258.2874"><vh>&lt;&lt;declarations&gt;&gt; (mirrorcommand)</vh></v>
<v t="1.20130426141258.2875"><vh>class MirrorCommand</vh>
<v t="1.20130426141258.2876"><vh>__init__</vh></v>
<v t="1.20130426141258.2877"><vh>performMirror</vh></v>
<v t="1.20130426141258.2878"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2879"><vh>@@clean movecommand.py</vh>
<v t="1.20130426141258.2880"><vh>&lt;&lt;declarations&gt;&gt; (movecommand)</vh></v>
<v t="1.20130426141258.2881"><vh>class MoveCommand</vh>
<v t="1.20130426141258.2882"><vh>__init__</vh></v>
<v t="1.20130426141258.2883"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2884"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2885"><vh>@@clean pointcommand.py</vh>
<v t="1.20130426141258.2886"><vh>&lt;&lt;declarations&gt;&gt; (pointcommand)</vh></v>
<v t="1.20130426141258.2887"><vh>class PointCommand</vh>
<v t="1.20130426141258.2888"><vh>__init__</vh></v>
<v t="1.20130426141258.2889"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2890"><vh>@@clean polygoncommand.py</vh>
<v t="1.20130426141258.2891"><vh>&lt;&lt;declarations&gt;&gt; (polygoncommand)</vh></v>
<v t="1.20130426141258.2892"><vh>class PolygonCommand</vh>
<v t="1.20130426141258.2893"><vh>__init__</vh></v>
<v t="1.20130426141258.2894"><vh>side</vh></v>
<v t="1.20130426141258.2895"><vh>side</vh></v>
<v t="1.20130426141258.2896"><vh>updateSide</vh></v>
<v t="1.20130426141258.2897"><vh>external</vh></v>
<v t="1.20130426141258.2898"><vh>external</vh></v>
<v t="1.20130426141258.2899"><vh>externalPick</vh></v>
<v t="1.20130426141258.2900"><vh>externalPick</vh></v>
<v t="1.20130426141258.2901"><vh>center</vh></v>
<v t="1.20130426141258.2902"><vh>center</vh></v>
<v t="1.20130426141258.2903"><vh>getCoord</vh></v>
<v t="1.20130426141258.2904"><vh>CalculatePoint</vh></v>
<v t="1.20130426141258.2905"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2906"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2907"><vh>@@clean polylinecommand.py</vh>
<v t="1.20130426141258.2908"><vh>&lt;&lt;declarations&gt;&gt; (polylinecommand)</vh></v>
<v t="1.20130426141258.2909"><vh>class PolylineCommand</vh>
<v t="1.20130426141258.2910"><vh>__init__</vh></v>
<v t="1.20130426141258.2911"><vh>__setitem__</vh></v>
<v t="1.20130426141258.2912"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2913"><vh>@@clean propertycommand.py</vh>
<v t="1.20130426141258.2914"><vh>&lt;&lt;declarations&gt;&gt; (propertycommand)</vh></v>
<v t="1.20130426141258.2915"><vh>class PropertyCommand</vh>
<v t="1.20130426141258.2916"><vh>__init__</vh></v>
<v t="1.20130426141258.2917"><vh>changeProp</vh></v>
<v t="1.20130426141258.2918"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2919"><vh>@@clean rectanglecommand.py</vh>
<v t="1.20130426141258.2920"><vh>&lt;&lt;declarations&gt;&gt; (rectanglecommand)</vh></v>
<v t="1.20130426141258.2921"><vh>class RectangleCommand</vh>
<v t="1.20130426141258.2922"><vh>__init__</vh></v>
<v t="1.20130426141258.2923"><vh>getEntsToSave</vh></v>
<v t="1.20130426141258.2924"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2925"><vh>@@clean rotatecommand.py</vh>
<v t="1.20130426141258.2926"><vh>&lt;&lt;declarations&gt;&gt; (rotatecommand)</vh></v>
<v t="1.20130426141258.2927"><vh>class RotateCommand</vh>
<v t="1.20130426141258.2928"><vh>__init__</vh></v>
<v t="1.20130426141258.2929"><vh>performRotation</vh></v>
<v t="1.20130426141258.2930"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2931"><vh>@@clean segmentcommand.py</vh>
<v t="1.20130426141258.2932"><vh>&lt;&lt;declarations&gt;&gt; (segmentcommand)</vh></v>
<v t="1.20130426141258.2933"><vh>class SegmentCommand</vh>
<v t="1.20130426141258.2934"><vh>__init__</vh></v>
<v t="1.20130426141258.2935"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2936"><vh>@@clean textcommand.py</vh>
<v t="1.20130426141258.2937"><vh>&lt;&lt;declarations&gt;&gt; (textcommand)</vh></v>
<v t="1.20130426141258.2938"><vh>class TextCommand</vh>
<v t="1.20130426141258.2939"><vh>__init__</vh></v>
<v t="1.20130426141258.2940"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2941"><vh>@@clean trimcommand.py</vh>
<v t="1.20130426141258.2942"><vh>&lt;&lt;declarations&gt;&gt; (trimcommand)</vh></v>
<v t="1.20130426141258.2943"><vh>class TrimCommand</vh>
<v t="1.20130426141258.2944"><vh>__init__</vh></v>
<v t="1.20130426141258.2945"><vh>performTrim</vh></v>
<v t="1.20130426141258.2946"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.2947"><vh>@@clean __init__.py</vh>
<v t="1.20130426141258.2948"><vh>&lt;&lt;declarations&gt;&gt; (__init__)</vh></v>
</v>
</v>
<v t="1.20130426141258.2949"><vh>@path Db</vh>
<v t="1.20130426141258.2950"><vh>@clean basedb.py</vh>
<v t="1.20130426141258.2951"><vh>&lt;&lt;declarations&gt;&gt; (basedb)</vh></v>
<v t="1.20130426141258.2952"><vh>class BaseDb</vh>
<v t="1.20130426141258.2953"><vh>__init__</vh></v>
<v t="1.20130426141258.2954"><vh>createConnection</vh></v>
<v t="1.20130426141258.2955"><vh>setConnection</vh></v>
<v t="1.20130426141258.2956"><vh>getConnection</vh></v>
<v t="1.20130426141258.2957"><vh>makeSelect</vh></v>
<v t="1.20130426141258.2958"><vh>fetchOneRow</vh></v>
<v t="1.20130426141258.2959"><vh>makeUpdateInsert</vh></v>
<v t="1.20130426141258.2960"><vh>close</vh></v>
<v t="1.20130426141258.2961"><vh>suspendCommit</vh></v>
<v t="1.20130426141258.2962"><vh>reactiveCommit</vh></v>
<v t="1.20130426141258.2963"><vh>performCommit</vh></v>
</v>
</v>
<v t="1.20130426141258.2964"><vh>@clean entitydb.py</vh>
<v t="1.20130426141258.2965"><vh>&lt;&lt;declarations&gt;&gt; (entitydb)</vh></v>
<v t="1.20130426141258.2966"><vh>class EntityDb</vh>
<v t="1.20130426141258.2967"><vh>__init__</vh></v>
<v t="1.20130426141258.2968"><vh>getRevisionIndex</vh></v>
<v t="1.20130426141258.2969"><vh>increaseRevisionIndex</vh></v>
<v t="1.20130426141258.2970"><vh>decreseRevisionIndex</vh></v>
<v t="1.20130426141258.2971"><vh>saveEntity</vh></v>
<v t="1.20130426141258.2972"><vh>getEntityFromTableId</vh></v>
<v t="1.20130426141258.2973"><vh>getEntityEntityId</vh></v>
<v t="1.20130426141258.2974"><vh>getEntitysFromStyle</vh></v>
<v t="1.20130426141258.2975"><vh>_getEntInVersion</vh></v>
<v t="1.20130426141258.2976"><vh>getMultiFilteredEntity</vh></v>
<v t="1.20130426141258.2977"><vh>getEntityFromType</vh></v>
<v t="1.20130426141258.2978"><vh>getEntityFromTypeArray</vh></v>
<v t="1.20130426141258.2979"><vh>convertRowToDbEnt</vh></v>
<v t="1.20130426141258.2980"><vh>exsisting</vh></v>
<v t="1.20130426141258.2981"><vh>haveDrwEntitys</vh></v>
<v t="1.20130426141258.2982"><vh>getNewEntId</vh></v>
<v t="1.20130426141258.2983"><vh>markUndoVisibility</vh></v>
<v t="1.20130426141258.2984"><vh>markUndoVisibilityFromEntId</vh></v>
<v t="1.20130426141258.2985"><vh>markEntVisibility</vh></v>
<v t="1.20130426141258.2986"><vh>hideAllEntityIstance</vh></v>
<v t="1.20130426141258.2987"><vh>delete</vh></v>
<v t="1.20130426141258.2988"><vh>uptateEntity</vh></v>
<v t="1.20130426141258.2989"><vh>clearEnt</vh></v>
</v>
</v>
<v t="1.20130426141258.2990"><vh>@clean pycadobject.py</vh>
<v t="1.20130426141258.2991"><vh>&lt;&lt;declarations&gt;&gt; (pycadobject)</vh></v>
<v t="1.20130426141258.2992"><vh>class PyCadObject</vh>
<v t="1.20130426141258.2993"><vh>__init__</vh></v>
<v t="1.20130426141258.2994"><vh>addPropertie</vh></v>
<v t="1.20130426141258.2995"><vh>getPropertie</vh></v>
<v t="1.20130426141258.2996"><vh>resetProperty</vh></v>
<v t="1.20130426141258.2997"><vh>properties</vh></v>
<v t="1.20130426141258.2998"><vh>setVisible</vh></v>
<v t="1.20130426141258.2999"><vh>getVisible</vh></v>
<v t="1.20130426141258.3000"><vh>getId</vh></v>
<v t="1.20130426141258.3001"><vh>getState</vh></v>
<v t="1.20130426141258.3002"><vh>setState</vh></v>
<v t="1.20130426141258.3003"><vh>getIndex</vh></v>
<v t="1.20130426141258.3004"><vh>getNewIndex</vh></v>
<v t="1.20130426141258.3005"><vh>setIndex</vh></v>
<v t="1.20130426141258.3006"><vh>delete</vh></v>
<v t="1.20130426141258.3007"><vh>relese</vh></v>
<v t="1.20130426141258.3008"><vh>getStyle</vh></v>
<v t="1.20130426141258.3009"><vh>setStyle</vh></v>
<v t="1.20130426141258.3010"><vh>getInnerStyle</vh></v>
<v t="1.20130426141258.3011"><vh>setEntType</vh></v>
<v t="1.20130426141258.3012"><vh>getEntityType</vh></v>
</v>
</v>
<v t="1.20130426141258.3013"><vh>@clean relationdb.py</vh>
<v t="1.20130426141258.3014"><vh>&lt;&lt;declarations&gt;&gt; (relationdb)</vh></v>
<v t="1.20130426141258.3015"><vh>class RelationDb</vh>
<v t="1.20130426141258.3016"><vh>__init__</vh></v>
<v t="1.20130426141258.3017"><vh>saveRelation</vh></v>
<v t="1.20130426141258.3018"><vh>getChildrenIds</vh></v>
<v t="1.20130426141258.3019"><vh>getAllChildrenType</vh></v>
<v t="1.20130426141258.3020"><vh>getParentEnt</vh></v>
<v t="1.20130426141258.3021"><vh>deleteFromParent</vh></v>
<v t="1.20130426141258.3022"><vh>deleteFromChild</vh></v>
<v t="1.20130426141258.3023"><vh>deleteRelation</vh></v>
<v t="1.20130426141258.3024"><vh>relationExsist</vh></v>
</v>
</v>
<v t="1.20130426141258.3025"><vh>@clean undodb.py</vh>
<v t="1.20130426141258.3026"><vh>&lt;&lt;declarations&gt;&gt; (undodb)</vh></v>
<v t="1.20130426141258.3027"><vh>class UndoDb</vh>
<v t="1.20130426141258.3028"><vh>__init__</vh></v>
<v t="1.20130426141258.3029"><vh>getMaxUndoIndex</vh></v>
<v t="1.20130426141258.3030"><vh>getLastUndoIndex</vh></v>
<v t="1.20130426141258.3031"><vh>dbUndo</vh></v>
<v t="1.20130426141258.3032"><vh>dbRedo</vh></v>
<v t="1.20130426141258.3033"><vh>undoIdExsist</vh></v>
<v t="1.20130426141258.3034"><vh>getNewUndo</vh></v>
<v t="1.20130426141258.3035"><vh>clearUndoTable</vh></v>
<v t="1.20130426141258.3036"><vh>deleteUndo</vh></v>
<v t="1.20130426141258.3037"><vh>getMaxUndoId</vh></v>
<v t="1.20130426141258.3038"><vh>getActiveUndoId</vh></v>
</v>
<v t="1.20130426141258.3039"><vh>test</vh></v>
</v>
<v t="1.20130426141258.3040"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3041" a="E"><vh>@path ExternalFormat</vh>
<v t="1.20130426141258.3042"><vh>@clean externalformat.py</vh>
<v t="1.20130426141258.3043"><vh>&lt;&lt;declarations&gt;&gt; (externalformat)</vh></v>
<v t="1.20130426141258.3044"><vh>class ExtFormat</vh>
<v t="1.20130426141258.3045"><vh>__init__</vh></v>
<v t="1.20130426141258.3046"><vh>openFile</vh></v>
<v t="1.20130426141258.3047"><vh>saveFile</vh></v>
<v t="1.20130426141258.3048"><vh>getErrorList</vh></v>
</v>
</v>
<v t="1.20130426141258.3049"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.3050" a="E"><vh>@path Dxf</vh>
<v t="1.20130426141258.3051" a="E"><vh>@clean dxf.py</vh>
<v t="1.20130426141258.3052"><vh>&lt;&lt;declarations&gt;&gt; (dxf)</vh></v>
<v t="1.20130426141258.3053"><vh>ChangeColor</vh></v>
<v t="1.20130426141258.3054"><vh>changeColorFromDxf</vh></v>
<v t="1.20130426141258.3055" a="E"><vh>class DrawingFile</vh>
<v t="1.20130426141258.3056"><vh>__init__</vh></v>
<v t="1.20130426141258.3057"><vh>readAsci</vh></v>
<v t="1.20130426141258.3058"><vh>createAsci</vh></v>
<v t="1.20130426141258.3059"><vh>fileObject</vh></v>
<v t="1.20130426141258.3060"><vh>readLine</vh></v>
<v t="1.20130426141258.3061"><vh>writeLine</vh></v>
<v t="1.20130426141258.3062"><vh>writeError</vh></v>
<v t="1.20130426141258.3063"><vh>getError</vh></v>
<v t="1.20130426141258.3064"><vh>close</vh></v>
<v t="1.20130426141258.3065"><vh>getFileName</vh></v>
</v>
<v t="1.20130426141258.3066"><vh>class Dxf</vh>
<v t="1.20130426141258.3067"><vh>__init__</vh></v>
<v t="1.20130426141258.3068"><vh>exportEntitis</vh></v>
<v t="1.20130426141258.3069"><vh>getAllEntitis</vh></v>
<v t="1.20130426141258.3070"><vh>writeSegment</vh></v>
<v t="1.20130426141258.3071"><vh>writeArc</vh></v>
<v t="1.20130426141258.3072"><vh>writePolyline</vh></v>
<v t="1.20130426141258.3073"><vh>writeText</vh></v>
<v t="1.20130426141258.3074"><vh>importEntitis</vh></v>
<v t="1.20130426141258.3075"><vh>readLayer</vh></v>
<v t="1.20130426141258.3076"><vh>createLineFromDxf</vh></v>
<v t="1.20130426141258.3077"><vh>createLine</vh></v>
<v t="1.20130426141258.3078"><vh>createCircleFromDxf</vh></v>
<v t="1.20130426141258.3079"><vh>createTextFromDxf</vh></v>
<v t="1.20130426141258.3080"><vh>createArcFromDxf</vh></v>
<v t="1.20130426141258.3081"><vh>createArc</vh></v>
<v t="1.20130426141258.3082"><vh>createText</vh></v>
<v t="1.20130426141258.3083"><vh>createPolylineFromDxf</vh></v>
<v t="1.20130426141258.3084"><vh>createPolyline</vh></v>
</v>
<v t="1.20130426141258.3085"><vh>dPrint</vh></v>
</v>
<v t="1.20130426141258.3086"><vh>@clean __init__.py</vh></v>
</v>
</v>
<v t="1.20130426141258.3087"><vh>@path GeoComposedEntity</vh>
<v t="1.20130426141258.3088"><vh>@clean bisector.py</vh>
<v t="1.20130426141258.3089"><vh>&lt;&lt;declarations&gt;&gt; (bisector)</vh></v>
<v t="1.20130426141258.3090"><vh>class Bisector</vh>
<v t="1.20130426141258.3091"><vh>__init__</vh></v>
<v t="1.20130426141258.3092"><vh>_UpdateBisector</vh></v>
<v t="1.20130426141258.3093"><vh>lengh</vh></v>
<v t="1.20130426141258.3094"><vh>lengh</vh></v>
<v t="1.20130426141258.3095"><vh>bisector</vh></v>
<v t="1.20130426141258.3096"><vh>bisector</vh></v>
<v t="1.20130426141258.3097"><vh>getDefaultLeng</vh></v>
<v t="1.20130426141258.3098"><vh>clone</vh></v>
<v t="1.20130426141258.3099"><vh>getReletedComponent</vh></v>
</v>
</v>
<v t="1.20130426141258.3100"><vh>@clean chamfer.py</vh>
<v t="1.20130426141258.3101"><vh>&lt;&lt;declarations&gt;&gt; (chamfer)</vh></v>
<v t="1.20130426141258.3102"><vh>class Chamfer</vh>
<v t="1.20130426141258.3103"><vh>__init__</vh></v>
<v t="1.20130426141258.3104"><vh>setConstructionElements</vh></v>
<v t="1.20130426141258.3105"><vh>_UpdateChamferSegment</vh></v>
<v t="1.20130426141258.3106"><vh>_updateSegment</vh></v>
<v t="1.20130426141258.3107"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3108"><vh>getLength</vh></v>
<v t="1.20130426141258.3109"><vh>setDistance1</vh></v>
<v t="1.20130426141258.3110"><vh>getDistance1</vh></v>
<v t="1.20130426141258.3111"><vh>setDistance2</vh></v>
<v t="1.20130426141258.3112"><vh>getDistance2</vh></v>
<v t="1.20130426141258.3113"><vh>clone</vh></v>
<v t="1.20130426141258.3114"><vh>getReletedComponent</vh></v>
</v>
</v>
<v t="1.20130426141258.3115"><vh>@clean fillet.py</vh>
<v t="1.20130426141258.3116"><vh>&lt;&lt;declarations&gt;&gt; (fillet)</vh></v>
<v t="1.20130426141258.3117"><vh>class Fillet</vh>
<v t="1.20130426141258.3118"><vh>__init__</vh></v>
<v t="1.20130426141258.3119"><vh>_calculateCenter</vh></v>
<v t="1.20130426141258.3120"><vh>_UpdateFilletArc</vh></v>
<v t="1.20130426141258.3121"><vh>_UpdateAngle</vh></v>
<v t="1.20130426141258.3122"><vh>_updateSegment</vh></v>
<v t="1.20130426141258.3123"><vh>startAngle</vh></v>
<v t="1.20130426141258.3124"><vh>startAngle</vh></v>
<v t="1.20130426141258.3125"><vh>endAngle</vh></v>
<v t="1.20130426141258.3126"><vh>endAngle</vh></v>
<v t="1.20130426141258.3127"><vh>radius</vh></v>
<v t="1.20130426141258.3128"><vh>radius</vh></v>
<v t="1.20130426141258.3129"><vh>center</vh></v>
<v t="1.20130426141258.3130"><vh>clone</vh></v>
<v t="1.20130426141258.3131"><vh>getReletedComponent</vh></v>
</v>
</v>
<v t="1.20130426141258.3132"><vh>@clean objoint.py</vh>
<v t="1.20130426141258.3133"><vh>&lt;&lt;declarations&gt;&gt; (objoint)</vh></v>
<v t="1.20130426141258.3134"><vh>class ObjectJoint</vh>
<v t="1.20130426141258.3135"><vh>__init__</vh></v>
<v t="1.20130426141258.3136"><vh>angle</vh></v>
<v t="1.20130426141258.3137"><vh>trimMode</vh></v>
<v t="1.20130426141258.3138"><vh>trimMode</vh></v>
<v t="1.20130426141258.3139"><vh>obj1</vh></v>
<v t="1.20130426141258.3140"><vh>obj1</vh></v>
<v t="1.20130426141258.3141"><vh>obj2</vh></v>
<v t="1.20130426141258.3142"><vh>obj2</vh></v>
<v t="1.20130426141258.3143"><vh>pointClick1</vh></v>
<v t="1.20130426141258.3144"><vh>pointClick1</vh></v>
<v t="1.20130426141258.3145"><vh>pointClick2</vh></v>
<v t="1.20130426141258.3146"><vh>pointClick2</vh></v>
<v t="1.20130426141258.3147"><vh>intersection</vh></v>
<v t="1.20130426141258.3148"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3149"><vh>getReletedComponent</vh></v>
<v t="1.20130426141258.3150"><vh>getAngledVector</vh></v>
</v>
</v>
<v t="1.20130426141258.3151"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3152"><vh>@path GeoEntity</vh>
<v t="1.20130426141258.3153"><vh>@clean arc.py</vh>
<v t="1.20130426141258.3154"><vh>&lt;&lt;declarations&gt;&gt; (arc)</vh></v>
<v t="1.20130426141258.3155"><vh>class Arc</vh>
<v t="1.20130426141258.3156"><vh>__init__</vh></v>
<v t="1.20130426141258.3157"><vh>isCircle</vh></v>
<v t="1.20130426141258.3158"><vh>info</vh></v>
<v t="1.20130426141258.3159"><vh>__eq__</vh></v>
<v t="1.20130426141258.3160"><vh>__ne__</vh></v>
<v t="1.20130426141258.3161"><vh>getCenter</vh></v>
<v t="1.20130426141258.3162"><vh>setCenter</vh></v>
<v t="1.20130426141258.3163"><vh>getRadius</vh></v>
<v t="1.20130426141258.3164"><vh>setRadius</vh></v>
<v t="1.20130426141258.3165"><vh>getStartAngle</vh></v>
<v t="1.20130426141258.3166"><vh>setStartAngle</vh></v>
<v t="1.20130426141258.3167"><vh>getEndAngle</vh></v>
<v t="1.20130426141258.3168"><vh>setEndAngle</vh></v>
<v t="1.20130426141258.3169"><vh>getAngle</vh></v>
<v t="1.20130426141258.3170"><vh>throughAngle</vh></v>
<v t="1.20130426141258.3171"><vh>getEndpoints</vh></v>
<v t="1.20130426141258.3172"><vh>length</vh></v>
<v t="1.20130426141258.3173"><vh>area</vh></v>
<v t="1.20130426141258.3174"><vh>getProjection</vh></v>
<v t="1.20130426141258.3175"><vh>GetTangentPoint</vh></v>
<v t="1.20130426141258.3176"><vh>GetRadiusPointFromExt</vh></v>
<v t="1.20130426141258.3177"><vh>inRegion</vh></v>
<v t="1.20130426141258.3178"><vh>getBounds</vh></v>
<v t="1.20130426141258.3179"><vh>clone</vh></v>
<v t="1.20130426141258.3180"><vh>getSympy</vh></v>
<v t="1.20130426141258.3181"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3182"><vh>__str__</vh></v>
<v t="1.20130426141258.3183"><vh>test_angle</vh></v>
<v t="1.20130426141258.3184"><vh>rotate</vh></v>
<v t="1.20130426141258.3185"><vh>mirror</vh></v>
<v t="1.20130426141258.3186"><vh>getQuadrant</vh></v>
</v>
</v>
<v t="1.20130426141258.3187"><vh>@clean ccircle.py</vh>
<v t="1.20130426141258.3188"><vh>&lt;&lt;declarations&gt;&gt; (ccircle)</vh></v>
<v t="1.20130426141258.3189"><vh>class CCircle</vh>
<v t="1.20130426141258.3190"><vh>__init__</vh></v>
<v t="1.20130426141258.3191"><vh>info</vh></v>
<v t="1.20130426141258.3192"><vh>__eq__</vh></v>
<v t="1.20130426141258.3193"><vh>__ne__</vh></v>
<v t="1.20130426141258.3194"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3195"><vh>getCenter</vh></v>
<v t="1.20130426141258.3196"><vh>setCenter</vh></v>
<v t="1.20130426141258.3197"><vh>getRadius</vh></v>
<v t="1.20130426141258.3198"><vh>setRadius</vh></v>
<v t="1.20130426141258.3199"><vh>circumference</vh></v>
<v t="1.20130426141258.3200"><vh>area</vh></v>
<v t="1.20130426141258.3201"><vh>mapCoords</vh></v>
<v t="1.20130426141258.3202"><vh>GetTangentPoint</vh></v>
<v t="1.20130426141258.3203"><vh>GetRadiusPointFromExt</vh></v>
<v t="1.20130426141258.3204"><vh>inRegion</vh></v>
<v t="1.20130426141258.3205"><vh>clone</vh></v>
<v t="1.20130426141258.3206"><vh>getSympy</vh></v>
<v t="1.20130426141258.3207"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3208"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3209"><vh>@clean cline.py</vh>
<v t="1.20130426141258.3210"><vh>&lt;&lt;declarations&gt;&gt; (cline)</vh></v>
<v t="1.20130426141258.3211"><vh>class CLine</vh>
<v t="1.20130426141258.3212"><vh>__init__</vh></v>
<v t="1.20130426141258.3213"><vh>__str__</vh></v>
<v t="1.20130426141258.3214"><vh>info</vh></v>
<v t="1.20130426141258.3215"><vh>rotate</vh></v>
<v t="1.20130426141258.3216"><vh>isVertical</vh></v>
<v t="1.20130426141258.3217"><vh>isHorizontal</vh></v>
<v t="1.20130426141258.3218"><vh>getP1</vh></v>
<v t="1.20130426141258.3219"><vh>setP1</vh></v>
<v t="1.20130426141258.3220"><vh>getP2</vh></v>
<v t="1.20130426141258.3221"><vh>setP2</vh></v>
<v t="1.20130426141258.3222"><vh>getKeypoints</vh></v>
<v t="1.20130426141258.3223"><vh>getAngle</vh></v>
<v t="1.20130426141258.3224"><vh>clone</vh></v>
<v t="1.20130426141258.3225"><vh>getSympy</vh></v>
<v t="1.20130426141258.3226"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3227"><vh>vector</vh></v>
<v t="1.20130426141258.3228"><vh>mirror</vh></v>
</v>
<v t="1.20130426141258.3229"><vh>intersect_region</vh></v>
</v>
<v t="1.20130426141258.3230"><vh>@clean dimension.py</vh>
<v t="1.20130426141258.3231"><vh>&lt;&lt;declarations&gt;&gt; (dimension)</vh></v>
<v t="1.20130426141258.3232"><vh>class Dimension</vh>
<v t="1.20130426141258.3233"><vh>__init__</vh></v>
<v t="1.20130426141258.3234"><vh>__str__</vh></v>
<v t="1.20130426141258.3235"><vh>info</vh></v>
<v t="1.20130426141258.3236"><vh>isAngularDimension</vh></v>
<v t="1.20130426141258.3237"><vh>distance</vh></v>
<v t="1.20130426141258.3238"><vh>firstPoint</vh></v>
<v t="1.20130426141258.3239"><vh>secondPoint</vh></v>
<v t="1.20130426141258.3240"><vh>thirdPoint</vh></v>
<v t="1.20130426141258.3241"><vh>angle</vh></v>
<v t="1.20130426141258.3242"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3243"><vh>setConstructionElements</vh></v>
<v t="1.20130426141258.3244"><vh>clone</vh></v>
<v t="1.20130426141258.3245"><vh>getSympy</vh></v>
<v t="1.20130426141258.3246"><vh>move</vh></v>
<v t="1.20130426141258.3247"><vh>rotate</vh></v>
<v t="1.20130426141258.3248"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3249"><vh>@clean ellipse.py</vh>
<v t="1.20130426141258.3250"><vh>&lt;&lt;declarations&gt;&gt; (ellipse)</vh></v>
<v t="1.20130426141258.3251"><vh>class Ellipse</vh>
<v t="1.20130426141258.3252"><vh>__init__</vh></v>
<v t="1.20130426141258.3253"><vh>info</vh></v>
<v t="1.20130426141258.3254"><vh>__eq__</vh></v>
<v t="1.20130426141258.3255"><vh>__ne__</vh></v>
<v t="1.20130426141258.3256"><vh>getCenter</vh></v>
<v t="1.20130426141258.3257"><vh>setCenter</vh></v>
<v t="1.20130426141258.3258"><vh>gethorizontalRadiusAxis</vh></v>
<v t="1.20130426141258.3259"><vh>sethorizontalRadiusAxis</vh></v>
<v t="1.20130426141258.3260"><vh>getverticalRadiusAxis</vh></v>
<v t="1.20130426141258.3261"><vh>setverticalRadiusAxis</vh></v>
<v t="1.20130426141258.3262"><vh>eccentricity</vh></v>
<v t="1.20130426141258.3263"><vh>area</vh></v>
<v t="1.20130426141258.3264"><vh>circumference</vh></v>
<v t="1.20130426141258.3265"><vh>clone</vh></v>
<v t="1.20130426141258.3266"><vh>getSympy</vh></v>
<v t="1.20130426141258.3267"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3268"><vh>__str__</vh></v>
<v t="1.20130426141258.3269"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3270"><vh>@clean entityutil.py</vh>
<v t="1.20130426141258.3271"><vh>&lt;&lt;declarations&gt;&gt; (entityutil)</vh></v>
<v t="1.20130426141258.3272"><vh>getEntityEntity</vh></v>
</v>
<v t="1.20130426141258.3273"><vh>@clean geometricalentity.py</vh>
<v t="1.20130426141258.3274"><vh>&lt;&lt;declarations&gt;&gt; (geometricalentity)</vh></v>
<v t="1.20130426141258.3275"><vh>class GeometricalEntity</vh>
<v t="1.20130426141258.3276"><vh>__init__</vh></v>
<v t="1.20130426141258.3277"><vh>updateSnapPoint</vh></v>
<v t="1.20130426141258.3278"><vh>getUpdatedSnapPoints</vh></v>
<v t="1.20130426141258.3279"><vh>snapPoints</vh></v>
<v t="1.20130426141258.3280"><vh>snapPoints</vh></v>
<v t="1.20130426141258.3281"><vh>getArgumentsName</vh></v>
<v t="1.20130426141258.3282"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3283"><vh>setConstructionElements</vh></v>
<v t="1.20130426141258.3284"><vh>move</vh></v>
<v t="1.20130426141258.3285"><vh>rotate</vh></v>
<v t="1.20130426141258.3286"><vh>getSympy</vh></v>
<v t="1.20130426141258.3287"><vh>setFromSympy</vh></v>
</v>
<v t="1.20130426141258.3288"><vh>class GeometricalEntityComposed</vh>
<v t="1.20130426141258.3289"><vh>__init__</vh></v>
<v t="1.20130426141258.3290"><vh>getArgumentsName</vh></v>
<v t="1.20130426141258.3291"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3292"><vh>getReletedComponent</vh></v>
</v>
</v>
<v t="1.20130426141258.3293"><vh>@clean hatch.py</vh>
<v t="1.20130426141258.3294"><vh>&lt;&lt;declarations&gt;&gt; (hatch)</vh></v>
<v t="1.20130426141258.3295"><vh>class Path</vh>
<v t="1.20130426141258.3296"><vh>__init__</vh></v>
<v t="1.20130426141258.3297"><vh>__len__</vh></v>
<v t="1.20130426141258.3298"><vh>__str__</vh></v>
<v t="1.20130426141258.3299"><vh>isCircular</vh></v>
<v t="1.20130426141258.3300"><vh>getPath</vh></v>
<v t="1.20130426141258.3301"><vh>inPath</vh></v>
</v>
<v t="1.20130426141258.3302"><vh>class HatchRegion</vh>
<v t="1.20130426141258.3303"><vh>__init__</vh></v>
<v t="1.20130426141258.3304"><vh>getExternalPath</vh></v>
<v t="1.20130426141258.3305"><vh>hasVoids</vh></v>
<v t="1.20130426141258.3306"><vh>getVoids</vh></v>
</v>
<v t="1.20130426141258.3307"><vh>_seg_seg_touch</vh></v>
<v t="1.20130426141258.3308"><vh>_seg_arc_touch</vh></v>
<v t="1.20130426141258.3309"><vh>_arc_arc_touch</vh></v>
<v t="1.20130426141258.3310"><vh>_seg_joint_touch</vh></v>
<v t="1.20130426141258.3311"><vh>_old_validate_path</vh></v>
<v t="1.20130426141258.3312"><vh>_can_touch</vh></v>
<v t="1.20130426141258.3313"><vh>_validate_path</vh></v>
<v t="1.20130426141258.3314"><vh>point_boundaries</vh></v>
<v t="1.20130426141258.3315"><vh>point_in_path</vh></v>
<v t="1.20130426141258.3316"><vh>draw_path</vh></v>
<v t="1.20130426141258.3317"><vh>make_paths</vh></v>
<v t="1.20130426141258.3318"><vh>check_clist</vh></v>
<v t="1.20130426141258.3319"><vh>get_contained_circles</vh></v>
<v t="1.20130426141258.3320"><vh>make_hatch_area</vh></v>
<v t="1.20130426141258.3321"><vh>_make_paths</vh></v>
<v t="1.20130426141258.3322"><vh>hatchtests</vh></v>
</v>
<v t="1.20130426141258.3323"><vh>@clean nurbs.py</vh>
<v t="1.20130426141258.3324"><vh>&lt;&lt;declarations&gt;&gt; (nurbs)</vh></v>
<v t="1.20130426141258.3325"><vh>class Nurb</vh>
<v t="1.20130426141258.3326"><vh>__init__</vh></v>
<v t="1.20130426141258.3327"><vh>getControlPoints</vh></v>
<v t="1.20130426141258.3328"><vh>getKnots</vh></v>
<v t="1.20130426141258.3329"><vh>getOrder</vh></v>
<v t="1.20130426141258.3330"><vh>calculate</vh></v>
<v t="1.20130426141258.3331"><vh>_N</vh></v>
<v t="1.20130426141258.3332"><vh>writedata</vh></v>
<v t="1.20130426141258.3333"><vh>_NN</vh></v>
</v>
</v>
<v t="1.20130426141258.3334"><vh>@clean point.py</vh>
<v t="1.20130426141258.3335"><vh>&lt;&lt;declarations&gt;&gt; (point)</vh></v>
<v t="1.20130426141258.3336"><vh>class Point</vh>
<v t="1.20130426141258.3337"><vh>__init__</vh></v>
<v t="1.20130426141258.3338"><vh>getPoint</vh></v>
<v t="1.20130426141258.3339"><vh>__str__</vh></v>
<v t="1.20130426141258.3340"><vh>info</vh></v>
<v t="1.20130426141258.3341"><vh>__sub__</vh></v>
<v t="1.20130426141258.3342"><vh>__eq__</vh></v>
<v t="1.20130426141258.3343"><vh>__ne__</vh></v>
<v t="1.20130426141258.3344"><vh>__add__</vh></v>
<v t="1.20130426141258.3345"><vh>getConstructionElements</vh></v>
<v t="1.20130426141258.3346"><vh>setConstructionElements</vh></v>
<v t="1.20130426141258.3347"><vh>getx</vh></v>
<v t="1.20130426141258.3348"><vh>setx</vh></v>
<v t="1.20130426141258.3349"><vh>gety</vh></v>
<v t="1.20130426141258.3350"><vh>sety</vh></v>
<v t="1.20130426141258.3351"><vh>getCoords</vh></v>
<v t="1.20130426141258.3352"><vh>setCoords</vh></v>
<v t="1.20130426141258.3353"><vh>clone</vh></v>
<v t="1.20130426141258.3354"><vh>inRegion</vh></v>
<v t="1.20130426141258.3355"><vh>dist</vh></v>
<v t="1.20130426141258.3356"><vh>getSympy</vh></v>
<v t="1.20130426141258.3357"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3358"><vh>move</vh></v>
<v t="1.20130426141258.3359"><vh>rotate</vh></v>
<v t="1.20130426141258.3360"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3361"><vh>@clean polyline.py</vh>
<v t="1.20130426141258.3362"><vh>&lt;&lt;declarations&gt;&gt; (polyline)</vh></v>
<v t="1.20130426141258.3363"><vh>class Polyline</vh>
<v t="1.20130426141258.3364"><vh>__init__</vh></v>
<v t="1.20130426141258.3365"><vh>__str__</vh></v>
<v t="1.20130426141258.3366"><vh>info</vh></v>
<v t="1.20130426141258.3367"><vh>__eq__</vh></v>
<v t="1.20130426141258.3368"><vh>__ne__</vh></v>
<v t="1.20130426141258.3369"><vh>getPoints</vh></v>
<v t="1.20130426141258.3370"><vh>addPoint</vh></v>
<v t="1.20130426141258.3371"><vh>delPoint</vh></v>
<v t="1.20130426141258.3372"><vh>getBounds</vh></v>
<v t="1.20130426141258.3373"><vh>points</vh></v>
<v t="1.20130426141258.3374"><vh>clone</vh></v>
<v t="1.20130426141258.3375"><vh>getSympySegments</vh></v>
<v t="1.20130426141258.3376"><vh>getSegments</vh></v>
<v t="1.20130426141258.3377"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3378"><vh>@clean segment.py</vh>
<v t="1.20130426141258.3379"><vh>&lt;&lt;declarations&gt;&gt; (segment)</vh></v>
<v t="1.20130426141258.3380"><vh>class Segment</vh>
<v t="1.20130426141258.3381"><vh>__init__</vh></v>
<v t="1.20130426141258.3382"><vh>__str__</vh></v>
<v t="1.20130426141258.3383"><vh>info</vh></v>
<v t="1.20130426141258.3384"><vh>__eq__</vh></v>
<v t="1.20130426141258.3385"><vh>__ne__</vh></v>
<v t="1.20130426141258.3386"><vh>getEndpoints</vh></v>
<v t="1.20130426141258.3387"><vh>getKeypoints</vh></v>
<v t="1.20130426141258.3388"><vh>getP1</vh></v>
<v t="1.20130426141258.3389"><vh>setP1</vh></v>
<v t="1.20130426141258.3390"><vh>getP2</vh></v>
<v t="1.20130426141258.3391"><vh>setP2</vh></v>
<v t="1.20130426141258.3392"><vh>length</vh></v>
<v t="1.20130426141258.3393"><vh>getCoefficients</vh></v>
<v t="1.20130426141258.3394"><vh>getMiddlePoint</vh></v>
<v t="1.20130426141258.3395"><vh>getProjection</vh></v>
<v t="1.20130426141258.3396"><vh>mapCoords</vh></v>
<v t="1.20130426141258.3397"><vh>inRegion</vh></v>
<v t="1.20130426141258.3398"><vh>clipToRegion</vh></v>
<v t="1.20130426141258.3399"><vh>clone</vh></v>
<v t="1.20130426141258.3400"><vh>getSympy</vh></v>
<v t="1.20130426141258.3401"><vh>getSympyLine</vh></v>
<v t="1.20130426141258.3402"><vh>setFromSympy</vh></v>
<v t="1.20130426141258.3403"><vh>vector</vh></v>
<v t="1.20130426141258.3404"><vh>mirror</vh></v>
</v>
</v>
<v t="1.20130426141258.3405"><vh>@clean style.py</vh>
<v t="1.20130426141258.3406"><vh>&lt;&lt;declarations&gt;&gt; (style)</vh></v>
<v t="1.20130426141258.3407"><vh>class Style</vh></v>
</v>
<v t="1.20130426141258.3408"><vh>@clean text.py</vh>
<v t="1.20130426141258.3409"><vh>&lt;&lt;declarations&gt;&gt; (text)</vh></v>
<v t="1.20130426141258.3410"><vh>class Text</vh>
<v t="1.20130426141258.3411"><vh>__init__</vh></v>
<v t="1.20130426141258.3412"><vh>__eq__</vh></v>
<v t="1.20130426141258.3413"><vh>info</vh></v>
<v t="1.20130426141258.3414"><vh>text</vh></v>
<v t="1.20130426141258.3415"><vh>text</vh></v>
<v t="1.20130426141258.3416"><vh>location</vh></v>
<v t="1.20130426141258.3417"><vh>location</vh></v>
<v t="1.20130426141258.3418"><vh>angle</vh></v>
<v t="1.20130426141258.3419"><vh>angle</vh></v>
<v t="1.20130426141258.3420"><vh>pointPosition</vh></v>
<v t="1.20130426141258.3421"><vh>pointPosition</vh></v>
<v t="1.20130426141258.3422"><vh>getLineCount</vh></v>
<v t="1.20130426141258.3423"><vh>clone</vh></v>
<v t="1.20130426141258.3424"><vh>mirror</vh></v>
<v t="1.20130426141258.3425"><vh>rotate</vh></v>
</v>
</v>
<v t="1.20130426141258.3426"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3427"><vh>@path GeoUtil</vh>
<v t="1.20130426141258.3428"><vh>@clean geolib.py</vh>
<v t="1.20130426141258.3429"><vh>&lt;&lt;declarations&gt;&gt; (geolib)</vh></v>
<v t="1.20130426141258.3430"><vh>class Vector</vh>
<v t="1.20130426141258.3431"><vh>__init__</vh></v>
<v t="1.20130426141258.3432"><vh>mag</vh></v>
<v t="1.20130426141258.3433"><vh>norm</vh></v>
<v t="1.20130426141258.3434"><vh>__eq__</vh></v>
<v t="1.20130426141258.3435"><vh>point</vh></v>
<v t="1.20130426141258.3436"><vh>x</vh></v>
<v t="1.20130426141258.3437"><vh>y</vh></v>
<v t="1.20130426141258.3438"><vh>dot</vh></v>
<v t="1.20130426141258.3439"><vh>cross</vh></v>
<v t="1.20130426141258.3440"><vh>ang</vh></v>
<v t="1.20130426141258.3441"><vh>absAng</vh></v>
<v t="1.20130426141258.3442"><vh>mult</vh></v>
<v t="1.20130426141258.3443"><vh>map</vh></v>
<v t="1.20130426141258.3444"><vh>rotate</vh></v>
<v t="1.20130426141258.3445"><vh>invert</vh></v>
<v t="1.20130426141258.3446"><vh>__str__</vh></v>
</v>
</v>
<v t="1.20130426141258.3447"><vh>@clean intersection.py</vh>
<v t="1.20130426141258.3448"><vh>&lt;&lt;declarations&gt;&gt; (intersection)</vh></v>
<v t="1.20130426141258.3449"><vh>denom</vh></v>
<v t="1.20130426141258.3450"><vh>rnum</vh></v>
<v t="1.20130426141258.3451"><vh>snum</vh></v>
<v t="1.20130426141258.3452"><vh>_null_intfunc</vh></v>
<v t="1.20130426141258.3453"><vh>_non_intersecting</vh></v>
<v t="1.20130426141258.3454"><vh>_sympy_intersection</vh></v>
<v t="1.20130426141258.3455"><vh>_pol_obj_intersection</vh></v>
<v t="1.20130426141258.3456"><vh>_pol_pol_intersection</vh></v>
<v t="1.20130426141258.3457"><vh>find_intersections</vh></v>
<v t="1.20130426141258.3458"><vh>findSegmentExtendedIntersection</vh></v>
<v t="1.20130426141258.3459"><vh>findSegmentExtendedIntersectionPoint</vh></v>
</v>
<v t="1.20130426141258.3460"><vh>@clean rotate.py</vh>
<v t="1.20130426141258.3461"><vh>&lt;&lt;declarations&gt;&gt; (rotate)</vh></v>
<v t="1.20130426141258.3462"><vh>_calc_coords</vh></v>
<v t="1.20130426141258.3463"><vh>_xfrm_point</vh></v>
<v t="1.20130426141258.3464"><vh>_adjust_dimensions</vh></v>
<v t="1.20130426141258.3465"><vh>_most_used</vh></v>
<v t="1.20130426141258.3466"><vh>_used_by</vh></v>
<v t="1.20130426141258.3467"><vh>_can_move</vh></v>
<v t="1.20130426141258.3468"><vh>_rotate_polyline</vh></v>
<v t="1.20130426141258.3469"><vh>_rotate_leader</vh></v>
<v t="1.20130426141258.3470"><vh>_adjust_endpoint</vh></v>
<v t="1.20130426141258.3471"><vh>_rotate_arc</vh></v>
<v t="1.20130426141258.3472"><vh>_rotate_circ_ccirc</vh></v>
<v t="1.20130426141258.3473"><vh>_rotate_seg_cline</vh></v>
<v t="1.20130426141258.3474"><vh>_adjust_point_users</vh></v>
<v t="1.20130426141258.3475"><vh>rotate_objects</vh></v>
</v>
<v t="1.20130426141258.3476"><vh>@clean tangent.py</vh>
<v t="1.20130426141258.3477"><vh>&lt;&lt;declarations&gt;&gt; (tangent)</vh></v>
<v t="1.20130426141258.3478"><vh>_get_two_point_projection</vh></v>
<v t="1.20130426141258.3479"><vh>_get_angled_projection</vh></v>
<v t="1.20130426141258.3480"><vh>_two_line_tangent</vh></v>
<v t="1.20130426141258.3481"><vh>_gen_cline_ccircle_tangent</vh></v>
<v t="1.20130426141258.3482"><vh>_cl_cl_tangent</vh></v>
<v t="1.20130426141258.3483"><vh>_cl_cc_tangent</vh></v>
<v t="1.20130426141258.3484"><vh>calc_tangent_circle</vh></v>
<v t="1.20130426141258.3485"><vh>_calc_values</vh></v>
<v t="1.20130426141258.3486"><vh>_calc_tangent_triangle</vh></v>
<v t="1.20130426141258.3487"><vh>calc_two_circle_tangents</vh></v>
</v>
<v t="1.20130426141258.3488"><vh>@clean tolerance.py</vh>
<v t="1.20130426141258.3489"><vh>&lt;&lt;declarations&gt;&gt; (tolerance)</vh></v>
<v t="1.20130426141258.3490"><vh>class TolObject</vh>
<v t="1.20130426141258.3491"><vh>__init__</vh></v>
<v t="1.20130426141258.3492"><vh>setTolerance</vh></v>
<v t="1.20130426141258.3493"><vh>getTolerance</vh></v>
</v>
<v t="1.20130426141258.3494"><vh>class StaticTolObject</vh>
<v t="1.20130426141258.3495"><vh>setTolerance</vh></v>
<v t="1.20130426141258.3496"><vh>getTolerance</vh></v>
</v>
<v t="1.20130426141258.3497"><vh>toltest</vh></v>
</v>
<v t="1.20130426141258.3498"><vh>@clean util.py</vh>
<v t="1.20130426141258.3499"><vh>&lt;&lt;declarations&gt;&gt; (util)</vh></v>
<v t="1.20130426141258.3500"><vh>get_float</vh></v>
<v t="1.20130426141258.3501"><vh>test_boolean</vh></v>
<v t="1.20130426141258.3502"><vh>tuple_to_two_floats</vh></v>
<v t="1.20130426141258.3503"><vh>tuple_to_three_floats</vh></v>
<v t="1.20130426141258.3504"><vh>make_angle</vh></v>
<v t="1.20130426141258.3505"><vh>make_c_angle</vh></v>
<v t="1.20130426141258.3506"><vh>make_c_angle_rad</vh></v>
<v t="1.20130426141258.3507"><vh>make_coords</vh></v>
<v t="1.20130426141258.3508"><vh>make_region</vh></v>
<v t="1.20130426141258.3509"><vh>degrees</vh></v>
<v t="1.20130426141258.3510"><vh>radians</vh></v>
<v t="1.20130426141258.3511"><vh>map_coords</vh></v>
<v t="1.20130426141258.3512"><vh>in_region</vh></v>
<v t="1.20130426141258.3513"><vh>to_unicode</vh></v>
<v t="1.20130426141258.3514"><vh>getRandomString</vh></v>
<v t="1.20130426141258.3515"><vh>getSegmentNearestPoint</vh></v>
<v t="1.20130426141258.3516"><vh>updateSegment</vh></v>
<v t="1.20130426141258.3517"><vh>getIdPoint</vh></v>
</v>
<v t="1.20130426141258.3518"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="1.20130426141258.3519" a="E"><vh>@path Interface</vh>
<v t="1.20130426141258.3520"><vh>@clean cadinitsetting.py</vh>
<v t="1.20130426141258.3521"><vh>&lt;&lt;declarations&gt;&gt; (cadinitsetting)</vh></v>
</v>
<v t="1.20130426141258.3522"><vh>@clean cadscene.py</vh>
<v t="1.20130426141258.3523"><vh>&lt;&lt;declarations&gt;&gt; (cadscene)</vh></v>
<v t="1.20130426141258.3524"><vh>class CadScene</vh>
<v t="1.20130426141258.3525"><vh>__init__</vh></v>
<v t="1.20130426141258.3526"><vh>initSnap</vh></v>
<v t="1.20130426141258.3527"><vh>initGuides</vh></v>
<v t="1.20130426141258.3528"><vh>activeKernelCommand</vh></v>
<v t="1.20130426141258.3529"><vh>activeKernelCommand</vh></v>
<v t="1.20130426141258.3530"><vh>setActiveSnap</vh></v>
<v t="1.20130426141258.3531"><vh>_qtInputPopUpReturnPressed</vh></v>
<v t="1.20130426141258.3532"><vh>mouseMoveEvent</vh></v>
<v t="1.20130426141258.3533"><vh>mousePressEvent</vh></v>
<v t="1.20130426141258.3534"><vh>mouseReleaseEvent</vh></v>
<v t="1.20130426141258.3535"><vh>showContextMenu</vh></v>
<v t="1.20130426141258.3536"><vh>hanhlerDoubleClick</vh></v>
<v t="1.20130426141258.3537"><vh>hideHandler</vh></v>
<v t="1.20130426141258.3538"><vh>hideSnapMarks</vh></v>
<v t="1.20130426141258.3539"><vh>mouseDoubleClickEvent</vh></v>
<v t="1.20130426141258.3540"><vh>cancelCommand</vh></v>
<v t="1.20130426141258.3541"><vh>keyPressEvent</vh></v>
<v t="1.20130426141258.3542"><vh>keyReleaseEvent</vh></v>
<v t="1.20130426141258.3543"><vh>textInput</vh></v>
<v t="1.20130426141258.3544"><vh>updateSelected</vh></v>
<v t="1.20130426141258.3545"><vh>clearPreview</vh></v>
<v t="1.20130426141258.3546"><vh>initDocumentEvents</vh></v>
<v t="1.20130426141258.3547"><vh>populateScene</vh></v>
<v t="1.20130426141258.3548"><vh>addGraficalObject</vh></v>
<v t="1.20130426141258.3549"><vh>addGraficalItem</vh></v>
<v t="1.20130426141258.3550"><vh>eventUndoRedo</vh></v>
<v t="1.20130426141258.3551"><vh>eventShow</vh></v>
<v t="1.20130426141258.3552"><vh>eventUpdate</vh></v>
<v t="1.20130426141258.3553"><vh>eventDelete</vh></v>
<v t="1.20130426141258.3554"><vh>eventMassiveDelete</vh></v>
<v t="1.20130426141258.3555"><vh>deleteEntity</vh></v>
<v t="1.20130426141258.3556"><vh>getEntFromId</vh></v>
<v t="1.20130426141258.3557"><vh>updateItemsFromID</vh></v>
<v t="1.20130426141258.3558"><vh>getAllBaseEntity</vh></v>
<v t="1.20130426141258.3559"><vh>updateItemsFromID_2</vh></v>
</v>
</v>
<v t="1.20130426141258.3560"><vh>@clean cadview.py</vh>
<v t="1.20130426141258.3561"><vh>&lt;&lt;declarations&gt;&gt; (cadview)</vh></v>
<v t="1.20130426141258.3562"><vh>class CadView</vh>
<v t="1.20130426141258.3563"><vh>__init__</vh></v>
<v t="1.20130426141258.3564"><vh>Pan</vh></v>
<v t="1.20130426141258.3565"><vh>wheelEvent</vh></v>
<v t="1.20130426141258.3566"><vh>keyPressEvent</vh></v>
<v t="1.20130426141258.3567"><vh>keyReleaseEvent</vh></v>
<v t="1.20130426141258.3568"><vh>fit</vh></v>
<v t="1.20130426141258.3569"><vh>centerOnSelection</vh></v>
<v t="1.20130426141258.3570"><vh>zoomWindows</vh></v>
<v t="1.20130426141258.3571"><vh>scaleView</vh></v>
<v t="1.20130426141258.3572"><vh>updateShape</vh></v>
</v>
</v>
<v t="1.20130426141258.3573" a="E"><vh>@clean cadwindow.py</vh>
<v t="1.20130426141258.3574"><vh>&lt;&lt;declarations&gt;&gt; (cadwindow)</vh></v>
<v t="1.20130426141258.3575" a="E"><vh>class CadWindowMdi</vh>
<v t="1.20130426141258.3576"><vh>__init__</vh></v>
<v t="1.20130426141258.3577"><vh>scene</vh></v>
<v t="1.20130426141258.3578"><vh>view</vh></v>
<v t="1.20130426141258.3579"><vh>Application</vh></v>
<v t="1.20130426141258.3580"><vh>LayerDock</vh></v>
<v t="1.20130426141258.3581"><vh>_createStatusBar</vh></v>
<v t="1.20130426141258.3582"><vh>setForceDirection</vh></v>
<v t="1.20130426141258.3583"><vh>setSnapStatus</vh></v>
<v t="1.20130426141258.3584"><vh>setGrid</vh></v>
<v t="1.20130426141258.3585"><vh>commandExecuted</vh></v>
<v t="1.20130426141258.3586"><vh>_createDockWindows</vh></v>
<v t="1.20130426141258.3587"><vh>closeEvent</vh></v>
<v t="1.20130426141258.3588"><vh>subWindowActivatedEvent</vh></v>
<v t="1.20130426141258.3589"><vh>resetCommand</vh></v>
<v t="1.20130426141258.3590"><vh>updateMenus</vh></v>
<v t="1.20130426141258.3591"><vh>createMdiChild</vh></v>
<v t="1.20130426141258.3592"><vh>_registerCommands</vh></v>
<v t="1.20130426141258.3593"><vh>updateRecentFileList</vh></v>
<v t="1.20130426141258.3594"><vh>strippedName</vh></v>
<v t="1.20130426141258.3595"><vh>_onNewDrawing</vh></v>
<v t="1.20130426141258.3596"><vh>_onOpenDrawing</vh></v>
<v t="1.20130426141258.3597"><vh>_onImportDrawing</vh></v>
<v t="1.20130426141258.3598"><vh>_onOpenRecent</vh></v>
<v t="1.20130426141258.3599"><vh>_onSaveAsDrawing</vh></v>
<v t="1.20130426141258.3600"><vh>_onPrint</vh></v>
<v t="1.20130426141258.3601"><vh>_onCloseDrawing</vh></v>
<v t="1.20130426141258.3602"><vh>_onPoint</vh></v>
<v t="1.20130426141258.3603"><vh>_onSegment</vh></v>
<v t="1.20130426141258.3604"><vh>_onCircle</vh></v>
<v t="1.20130426141258.3605"><vh>_onArc</vh></v>
<v t="1.20130426141258.3606"><vh>_onEllipse</vh></v>
<v t="1.20130426141258.3607"><vh>_onRectangle</vh></v>
<v t="1.20130426141258.3608"><vh>_onPolygon</vh></v>
<v t="1.20130426141258.3609"><vh>_onPolyline</vh></v>
<v t="1.20130426141258.3610"><vh>_onFillet</vh></v>
<v t="1.20130426141258.3611"><vh>_onChamfer</vh></v>
<v t="1.20130426141258.3612"><vh>_onBisect</vh></v>
<v t="1.20130426141258.3613"><vh>_onText</vh></v>
<v t="1.20130426141258.3614"><vh>_onDimension</vh></v>
<v t="1.20130426141258.3615"><vh>_onUndo</vh></v>
<v t="1.20130426141258.3616"><vh>_onRedo</vh></v>
<v t="1.20130426141258.3617"><vh>_onProperty</vh></v>
<v t="1.20130426141258.3618"><vh>preferences</vh></v>
<v t="1.20130426141258.3619"><vh>_onCopy</vh></v>
<v t="1.20130426141258.3620"><vh>_onMove</vh></v>
<v t="1.20130426141258.3621"><vh>_onDelete</vh></v>
<v t="1.20130426141258.3622"><vh>_onTrim</vh></v>
<v t="1.20130426141258.3623"><vh>_onMirror</vh></v>
<v t="1.20130426141258.3624"><vh>_onRotate</vh></v>
<v t="1.20130426141258.3625"><vh>_onFit</vh></v>
<v t="1.20130426141258.3626"><vh>_onZoomWindow</vh></v>
<v t="1.20130426141258.3627"><vh>_onCenterItem</vh></v>
<v t="1.20130426141258.3628"><vh>_onSnapCommand</vh></v>
<v t="1.20130426141258.3629"><vh>_onInfo2p</vh></v>
<v t="1.20130426141258.3630"><vh>_onTile</vh></v>
<v t="1.20130426141258.3631"><vh>_onCascade</vh></v>
<v t="1.20130426141258.3632"><vh>_onAbout</vh></v>
<v t="1.20130426141258.3633"><vh>callCommand</vh></v>
<v t="1.20130426141258.3634"><vh>getCommand</vh></v>
<v t="1.20130426141258.3635"><vh>updateInput</vh></v>
<v t="1.20130426141258.3636"><vh>critical</vh></v>
<v t="1.20130426141258.3637"><vh>readSettings</vh></v>
<v t="1.20130426141258.3638"><vh>writeSettings</vh></v>
<v t="1.20130426141258.3639"><vh>activeMdiChild</vh></v>
<v t="1.20130426141258.3640"><vh>switchLayoutDirection</vh></v>
<v t="1.20130426141258.3641"><vh>setActiveSubWindow</vh></v>
<v t="1.20130426141258.3642"><vh>_getIcon</vh></v>
<v t="1.20130426141258.3643"><vh>keyPressEvent</vh></v>
<v t="1.20130426141258.3644"><vh>plotFromSympy</vh></v>
<v t="1.20130426141258.3645"><vh>plotSympyEntity</vh></v>
<v t="1.20130426141258.3646"><vh>createSympyDocument</vh></v>
<v t="1.20130426141258.3647"><vh>getSympyObject</vh></v>
</v>
<v t="1.20130426141258.3648"><vh>class statusButton</vh>
<v t="1.20130426141258.3649"><vh>__init__</vh></v>
<v t="1.20130426141258.3650"><vh>getIcon</vh></v>
<v t="1.20130426141258.3651"><vh>mousePressEvent</vh></v>
</v>
</v>
<v t="1.20130426141258.3652"><vh>@clean cadwindow_rc.py</vh>
<v t="1.20130426141258.3653"><vh>&lt;&lt;declarations&gt;&gt; (cadwindow_rc)</vh></v>
<v t="1.20130426141258.3654"><vh>qInitResources</vh></v>
<v t="1.20130426141258.3655"><vh>qCleanupResources</vh></v>
</v>
<v t="1.20130426141258.3656"><vh>@clean idocument.py</vh>
<v t="1.20130426141258.3657"><vh>&lt;&lt;declarations&gt;&gt; (idocument)</vh></v>
<v t="1.20130426141258.3658"><vh>class IDocument</vh>
<v t="1.20130426141258.3659"><vh>__init__</vh></v>
<v t="1.20130426141258.3660"><vh>document</vh></v>
<v t="1.20130426141258.3661"><vh>cmdInf</vh></v>
<v t="1.20130426141258.3662"><vh>view</vh></v>
<v t="1.20130426141258.3663"><vh>scene</vh></v>
<v t="1.20130426141258.3664"><vh>application</vh></v>
<v t="1.20130426141258.3665"><vh>layerDock</vh></v>
<v t="1.20130426141258.3666"><vh>fileName</vh></v>
<v t="1.20130426141258.3667"><vh>unDo</vh></v>
<v t="1.20130426141258.3668"><vh>reDo</vh></v>
<v t="1.20130426141258.3669"><vh>importExternalFormat</vh></v>
<v t="1.20130426141258.3670"><vh>renderCurrentScene</vh></v>
<v t="1.20130426141258.3671"><vh>wWellEWvent</vh></v>
<v t="1.20130426141258.3672"><vh>popUpWarning</vh></v>
<v t="1.20130426141258.3673"><vh>popUpInfo</vh></v>
<v t="1.20130426141258.3674"><vh>_errorEvent</vh></v>
<v t="1.20130426141258.3675"><vh>setStatusbarCoords</vh></v>
<v t="1.20130426141258.3676"><vh>keyEvent</vh></v>
<v t="1.20130426141258.3677"><vh>keyShortcut</vh></v>
</v>
</v>
<v t="1.20130426141258.3678" a="E"><vh>@clean pycadapp.py</vh>
<v t="1.20130426141258.3679"><vh>&lt;&lt;declarations&gt;&gt; (pycadapp)</vh></v>
<v t="1.20130426141258.3680" a="E"><vh>class PyCadApp</vh>
<v t="1.20130426141258.3681"><vh>CadWindow</vh></v>
<v t="1.20130426141258.3682"><vh>SetCadWindow</vh></v>
<v t="1.20130426141258.3683"><vh>Application</vh></v>
<v t="1.20130426141258.3684"><vh>SetApplication</vh></v>
<v t="1.20130426141258.3685"><vh>ActiveDocument</vh></v>
<v t="1.20130426141258.3686"><vh>CreateNewDocument</vh></v>
<v t="1.20130426141258.3687"><vh>OpenDocument</vh></v>
<v t="1.20130426141258.3688"><vh>critical</vh></v>
</v>
</v>
<v t="1.20130426141258.3689"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.3690"><vh>@path CmdIntf</vh>
<v t="1.20130426141258.3691"><vh>@clean cmdaction.py</vh>
<v t="1.20130426141258.3692"><vh>&lt;&lt;declarations&gt;&gt; (cmdaction)</vh></v>
<v t="1.20130426141258.3693"><vh>class CmdAction</vh>
<v t="1.20130426141258.3694"><vh>__init__</vh></v>
<v t="1.20130426141258.3695"><vh>show</vh></v>
<v t="1.20130426141258.3696"><vh>hide</vh></v>
<v t="1.20130426141258.3697"><vh>command</vh></v>
<v t="1.20130426141258.3698"><vh>_actionHandler</vh></v>
</v>
</v>
<v t="1.20130426141258.3699"><vh>@clean cmdcategory.py</vh>
<v t="1.20130426141258.3700"><vh>class CmdCategory</vh>
<v t="1.20130426141258.3701"><vh>__init__</vh></v>
<v t="1.20130426141258.3702"><vh>getMenu</vh></v>
<v t="1.20130426141258.3703"><vh>getToolbarList</vh></v>
<v t="1.20130426141258.3704"><vh>getToolbar</vh></v>
</v>
</v>
<v t="1.20130426141258.3705"><vh>@clean cmdintf.py</vh>
<v t="1.20130426141258.3706"><vh>&lt;&lt;declarations&gt;&gt; (cmdintf)</vh></v>
<v t="1.20130426141258.3707"><vh>class CmdIntf</vh>
<v t="1.20130426141258.3708"><vh>__init__</vh></v>
<v t="1.20130426141258.3709"><vh>commandLine</vh></v>
<v t="1.20130426141258.3710"><vh>FunctionHandler</vh></v>
<v t="1.20130426141258.3711"><vh>Category</vh></v>
<v t="1.20130426141258.3712"><vh>_actionHandler</vh></v>
<v t="1.20130426141258.3713"><vh>_getIcon</vh></v>
<v t="1.20130426141258.3714"><vh>registerCommand</vh></v>
<v t="1.20130426141258.3715"><vh>evaluate</vh></v>
<v t="1.20130426141258.3716"><vh>evaluateInnerCommand</vh></v>
<v t="1.20130426141258.3717"><vh>evaluateMouseImput</vh></v>
<v t="1.20130426141258.3718"><vh>resetCommand</vh></v>
<v t="1.20130426141258.3719"><vh>hideAction</vh></v>
<v t="1.20130426141258.3720"><vh>showAction</vh></v>
<v t="1.20130426141258.3721"><vh>setVisible</vh></v>
<v t="1.20130426141258.3722"><vh>updateText</vh></v>
</v>
</v>
<v t="1.20130426141258.3723"><vh>@clean cmdlinedock.py</vh>
<v t="1.20130426141258.3724"><vh>&lt;&lt;declarations&gt;&gt; (cmdlinedock)</vh></v>
<v t="1.20130426141258.3725"><vh>class CmdLineDock</vh>
<v t="1.20130426141258.3726"><vh>__init__</vh></v>
<v t="1.20130426141258.3727"><vh>FunctionHandler</vh></v>
<v t="1.20130426141258.3728"><vh>_returnPressed</vh></v>
<v t="1.20130426141258.3729"><vh>_keyPress</vh></v>
<v t="1.20130426141258.3730"><vh>evaluate</vh></v>
<v t="1.20130426141258.3731"><vh>setFocus</vh></v>
<v t="1.20130426141258.3732"><vh>printMsg</vh></v>
</v>
<v t="1.20130426141258.3733"><vh>class PyCadTextView</vh>
<v t="1.20130426141258.3734"><vh>__init__</vh></v>
<v t="1.20130426141258.3735"><vh>contextMenuEvent</vh></v>
<v t="1.20130426141258.3736"><vh>printMsg</vh></v>
<v t="1.20130426141258.3737"><vh>scrollToBottom</vh></v>
</v>
</v>
<v t="1.20130426141258.3738"><vh>@clean functionhandler.py</vh>
<v t="1.20130426141258.3739"><vh>&lt;&lt;declarations&gt;&gt; (functionhandler)</vh></v>
<v t="1.20130426141258.3740"><vh>class FunctionHandler</vh>
<v t="1.20130426141258.3741"><vh>__init__</vh></v>
<v t="1.20130426141258.3742"><vh>registerCommand</vh></v>
<v t="1.20130426141258.3743"><vh>evaluate</vh></v>
<v t="1.20130426141258.3744"><vh>resetCommand</vh></v>
<v t="1.20130426141258.3745"><vh>printCommand</vh></v>
<v t="1.20130426141258.3746"><vh>printOutput</vh></v>
</v>
</v>
<v t="1.20130426141258.3747"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3748"><vh>@path Command</vh>
<v t="1.20130426141258.3749"><vh>@clean distance2point.py</vh>
<v t="1.20130426141258.3750"><vh>&lt;&lt;declarations&gt;&gt; (distance2point)</vh></v>
<v t="1.20130426141258.3751"><vh>class Distance2Point</vh>
<v t="1.20130426141258.3752"><vh>__init__</vh></v>
<v t="1.20130426141258.3753"><vh>applyCommand</vh></v>
</v>
</v>
<v t="1.20130426141258.3754"><vh>@clean icommand.py</vh>
<v t="1.20130426141258.3755"><vh>&lt;&lt;declarations&gt;&gt; (icommand)</vh></v>
<v t="1.20130426141258.3756"><vh>class ICommand</vh>
<v t="1.20130426141258.3757"><vh>__init__</vh></v>
<v t="1.20130426141258.3758"><vh>forceDirection</vh></v>
<v t="1.20130426141258.3759"><vh>kernelCommand</vh></v>
<v t="1.20130426141258.3760"><vh>scene</vh></v>
<v t="1.20130426141258.3761"><vh>index</vh></v>
<v t="1.20130426141258.3762"><vh>restartCommand</vh></v>
<v t="1.20130426141258.3763"><vh>addMauseEvent</vh></v>
<v t="1.20130426141258.3764"><vh>addTextEvent</vh></v>
<v t="1.20130426141258.3765"><vh>applyDefault</vh></v>
<v t="1.20130426141258.3766"><vh>applyCommand</vh></v>
<v t="1.20130426141258.3767"><vh>getEntity</vh></v>
<v t="1.20130426141258.3768"><vh>updateMauseEvent</vh></v>
<v t="1.20130426141258.3769"><vh>getDistance</vh></v>
<v t="1.20130426141258.3770"><vh>calculateAngle</vh></v>
<v t="1.20130426141258.3771"><vh>decodeText</vh></v>
<v t="1.20130426141258.3772"><vh>getIdsString</vh></v>
<v t="1.20130426141258.3773"><vh>updatePreview</vh></v>
<v t="1.20130426141258.3774"><vh>addPreviewItemToTheScene</vh></v>
<v t="1.20130426141258.3775"><vh>removePreviewItemToTheScene</vh></v>
<v t="1.20130426141258.3776"><vh>getPointClick</vh></v>
<v t="1.20130426141258.3777"><vh>getEntityClick</vh></v>
<v t="1.20130426141258.3778"><vh>getDistanceClick</vh></v>
<v t="1.20130426141258.3779"><vh>getSnapClick</vh></v>
<v t="1.20130426141258.3780"><vh>getForceSnap</vh></v>
<v t="1.20130426141258.3781"><vh>getDummyElement</vh></v>
<v t="1.20130426141258.3782"><vh>getDummyActive</vh></v>
<v t="1.20130426141258.3783"><vh>getActiveSnapClick</vh></v>
<v t="1.20130426141258.3784"><vh>getActiveDistanceClick</vh></v>
<v t="1.20130426141258.3785"><vh>getDummyBefore</vh></v>
<v t="1.20130426141258.3786"><vh>getBeforeEntity</vh></v>
<v t="1.20130426141258.3787"><vh>getBeforeSnapClick</vh></v>
<v t="1.20130426141258.3788"><vh>getLastForceSnap</vh></v>
<v t="1.20130426141258.3789"><vh>correctPositionForcedDirection</vh></v>
<v t="1.20130426141258.3790"><vh>getIntersection</vh></v>
</v>
</v>
<v t="1.20130426141258.3791"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3792"><vh>@path Dialogs</vh>
<v t="1.20130426141258.3793"><vh>@clean dataModel.py</vh>
<v t="1.20130426141258.3794"><vh>&lt;&lt;declarations&gt;&gt; (dataModel)</vh></v>
<v t="1.20130426141258.3795"><vh>class DataModel</vh>
<v t="1.20130426141258.3796"><vh>__init__</vh></v>
<v t="1.20130426141258.3797"><vh>rowCount</vh></v>
<v t="1.20130426141258.3798"><vh>addNewRow</vh></v>
<v t="1.20130426141258.3799"><vh>insertRow</vh></v>
<v t="1.20130426141258.3800"><vh>insertRows</vh></v>
<v t="1.20130426141258.3801"><vh>removeRow</vh></v>
<v t="1.20130426141258.3802"><vh>removeRows</vh></v>
<v t="1.20130426141258.3803"><vh>columnCount</vh></v>
<v t="1.20130426141258.3804"><vh>_rule</vh></v>
<v t="1.20130426141258.3805"><vh>backgroudIndex</vh></v>
<v t="1.20130426141258.3806"><vh>data</vh></v>
<v t="1.20130426141258.3807"><vh>headerData</vh></v>
<v t="1.20130426141258.3808"><vh>flags</vh></v>
<v t="1.20130426141258.3809"><vh>enableRowEdit</vh></v>
<v t="1.20130426141258.3810"><vh>setData</vh></v>
<v t="1.20130426141258.3811"><vh>getRowData</vh></v>
</v>
<v t="1.20130426141258.3812"><vh>populateTable</vh></v>
</v>
<v t="1.20130426141258.3813"><vh>@clean preferences.py</vh>
<v t="1.20130426141258.3814"><vh>&lt;&lt;declarations&gt;&gt; (preferences)</vh></v>
<v t="1.20130426141258.3815"><vh>class Preferences</vh>
<v t="1.20130426141258.3816"><vh>__init__</vh></v>
<v t="1.20130426141258.3817"><vh>on_buttonBox_accepted</vh></v>
<v t="1.20130426141258.3818"><vh>on_buttonBox_rejected</vh></v>
</v>
</v>
<v t="1.20130426141258.3819"><vh>@clean property.py</vh>
<v t="1.20130426141258.3820"><vh>&lt;&lt;declarations&gt;&gt; (property)</vh></v>
<v t="1.20130426141258.3821"><vh>class Property</vh>
<v t="1.20130426141258.3822"><vh>__init__</vh></v>
<v t="1.20130426141258.3823"><vh>populateCustomProperty</vh></v>
<v t="1.20130426141258.3824"><vh>customPropertyContextMenuEvent</vh></v>
<v t="1.20130426141258.3825"><vh>_newCustomProperty</vh></v>
<v t="1.20130426141258.3826"><vh>_delCustomProperty</vh></v>
<v t="1.20130426141258.3827"><vh>uppdateCustomProperty</vh></v>
<v t="1.20130426141258.3828"><vh>on_buttonBox_accepted</vh></v>
<v t="1.20130426141258.3829"><vh>on_buttonBox_rejected</vh></v>
<v t="1.20130426141258.3830"><vh>changed</vh></v>
<v t="1.20130426141258.3831"><vh>value</vh></v>
</v>
</v>
<v t="1.20130426141258.3832"><vh>@clean Ui_preferences.py</vh>
<v t="1.20130426141258.3833"><vh>&lt;&lt;declarations&gt;&gt; (Ui_preferences)</vh></v>
<v t="1.20130426141258.3834"><vh>class Ui_preferences</vh>
<v t="1.20130426141258.3835"><vh>setupUi</vh></v>
<v t="1.20130426141258.3836"><vh>retranslateUi</vh></v>
</v>
</v>
<v t="1.20130426141258.3837"><vh>@clean Ui_property.py</vh>
<v t="1.20130426141258.3838"><vh>&lt;&lt;declarations&gt;&gt; (Ui_property)</vh></v>
<v t="1.20130426141258.3839"><vh>class Ui_Dialog</vh>
<v t="1.20130426141258.3840"><vh>setupUi</vh></v>
<v t="1.20130426141258.3841"><vh>retranslateUi</vh></v>
</v>
</v>
<v t="1.20130426141258.3842"><vh>@clean __init__.py</vh></v>
<v t="1.20130426141258.3843"><vh>@path Widget</vh>
<v t="1.20130426141258.3844"><vh>@clean widgets.py</vh>
<v t="1.20130426141258.3845"><vh>&lt;&lt;declarations&gt;&gt; (widgets)</vh></v>
<v t="1.20130426141258.3846"><vh>class BaseContainer</vh>
<v t="1.20130426141258.3847"><vh>__init__</vh></v>
<v t="1.20130426141258.3848"><vh>value</vh></v>
<v t="1.20130426141258.3849"><vh>changed</vh></v>
<v t="1.20130426141258.3850"><vh>changed</vh></v>
</v>
<v t="1.20130426141258.3851"><vh>class PyCadQColor</vh>
<v t="1.20130426141258.3852"><vh>__init__</vh></v>
<v t="1.20130426141258.3853"><vh>click</vh></v>
</v>
<v t="1.20130426141258.3854"><vh>class PyCadQLineType</vh>
<v t="1.20130426141258.3855"><vh>__init__</vh></v>
<v t="1.20130426141258.3856"><vh>penChanged</vh></v>
</v>
<v t="1.20130426141258.3857"><vh>class PyCadQDouble</vh>
<v t="1.20130426141258.3858"><vh>__init__</vh></v>
<v t="1.20130426141258.3859"><vh>penChanged</vh></v>
</v>
<v t="1.20130426141258.3860"><vh>class PyCadQFont</vh>
<v t="1.20130426141258.3861"><vh>__init__</vh></v>
</v>
</v>
<v t="1.20130426141258.3862"><vh>@clean __init__.py</vh></v>
</v>
</v>
<v t="1.20130426141258.3863"><vh>@path DrawingHelper</vh>
<v t="1.20130426141258.3864"><vh>@clean evaluator.py</vh>
<v t="1.20130426141258.3865"><vh>&lt;&lt;declarations&gt;&gt; (evaluator)</vh></v>
<v t="1.20130426141258.3866"><vh>class Evaluator</vh>
<v t="1.20130426141258.3867"><vh>__init__</vh></v>
<v t="1.20130426141258.3868"><vh>evaluate</vh></v>
<v t="1.20130426141258.3869"><vh>_eval</vh></v>
<v t="1.20130426141258.3870"><vh>_exec</vh></v>
</v>
</v>
<v t="1.20130426141258.3871"><vh>@clean polarguides.py</vh>
<v t="1.20130426141258.3872"><vh>&lt;&lt;declarations&gt;&gt; (polarguides)</vh></v>
<v t="1.20130426141258.3873"><vh>getPolarMenu</vh></v>
<v t="1.20130426141258.3874"><vh>class GuideHandler</vh>
<v t="1.20130426141258.3875"><vh>__init__</vh></v>
<v t="1.20130426141258.3876"><vh>collidesWithItem</vh></v>
<v t="1.20130426141258.3877"><vh>setForceDirection</vh></v>
<v t="1.20130426141258.3878"><vh>setIsGuided</vh></v>
<v t="1.20130426141258.3879"><vh>setIsGuidLocked</vh></v>
<v t="1.20130426141258.3880"><vh>addGuideByAngle</vh></v>
<v t="1.20130426141258.3881"><vh>addGuidesByIncrement</vh></v>
<v t="1.20130426141258.3882"><vh>clearGuides</vh></v>
<v t="1.20130426141258.3883"><vh>place</vh></v>
<v t="1.20130426141258.3884"><vh>reset</vh></v>
<v t="1.20130426141258.3885"><vh>hideGuides</vh></v>
<v t="1.20130426141258.3886"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3887"><vh>paint</vh></v>
</v>
<v t="1.20130426141258.3888"><vh>class Guide</vh>
<v t="1.20130426141258.3889"><vh>__init__</vh></v>
<v t="1.20130426141258.3890"><vh>collidesWithItem</vh></v>
<v t="1.20130426141258.3891"><vh>hide</vh></v>
<v t="1.20130426141258.3892"><vh>kill</vh></v>
<v t="1.20130426141258.3893"><vh>shape</vh></v>
<v t="1.20130426141258.3894"><vh>hoverEnterEvent</vh></v>
<v t="1.20130426141258.3895"><vh>hoverLeaveEvent</vh></v>
</v>
</v>
<v t="1.20130426141258.3896"><vh>@clean snap.py</vh>
<v t="1.20130426141258.3897"><vh>&lt;&lt;declarations&gt;&gt; (snap)</vh></v>
<v t="1.20130426141258.3898"><vh>class SnapPoint</vh>
<v t="1.20130426141258.3899"><vh>__init__</vh></v>
<v t="1.20130426141258.3900"><vh>getSnapPoint</vh></v>
<v t="1.20130426141258.3901"><vh>getSnapOrtoPoint</vh></v>
<v t="1.20130426141258.3902"><vh>getSnapTangentPoint</vh></v>
<v t="1.20130426141258.3903"><vh>getSnapMiddlePoint</vh></v>
<v t="1.20130426141258.3904"><vh>getSnapEndPoint</vh></v>
<v t="1.20130426141258.3905"><vh>getSnapCenterPoint</vh></v>
<v t="1.20130426141258.3906"><vh>getIntersection</vh></v>
<v t="1.20130426141258.3907"><vh>getSnapQuadrantPoint</vh></v>
</v>
<v t="1.20130426141258.3908"><vh>class SnapMark</vh>
<v t="1.20130426141258.3909"><vh>__init__</vh></v>
<v t="1.20130426141258.3910"><vh>collidesWithItem</vh></v>
<v t="1.20130426141258.3911"><vh>shape</vh></v>
<v t="1.20130426141258.3912"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3913"><vh>paint</vh></v>
<v t="1.20130426141258.3914"><vh>move</vh></v>
</v>
<v t="1.20130426141258.3915"><vh>class SnapEndMark</vh>
<v t="1.20130426141258.3916"><vh>__init__</vh></v>
<v t="1.20130426141258.3917"><vh>collidesWithItem</vh></v>
<v t="1.20130426141258.3918"><vh>definePath</vh></v>
</v>
</v>
<v t="1.20130426141258.3919"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.3920"><vh>@path Entity</vh>
<v t="1.20130426141258.3921"><vh>@clean actionhandler.py</vh>
<v t="1.20130426141258.3922"><vh>&lt;&lt;declarations&gt;&gt; (actionhandler)</vh></v>
<v t="1.20130426141258.3923"><vh>class CustomVector</vh>
<v t="1.20130426141258.3924"><vh>__init__</vh></v>
<v t="1.20130426141258.3925"><vh>absAng</vh></v>
<v t="1.20130426141258.3926"><vh>qtPoint</vh></v>
<v t="1.20130426141258.3927"><vh>mag</vh></v>
<v t="1.20130426141258.3928"><vh>mult</vh></v>
<v t="1.20130426141258.3929"><vh>norm</vh></v>
</v>
<v t="1.20130426141258.3930"><vh>class PositionHandler</vh>
<v t="1.20130426141258.3931"><vh>__init__</vh></v>
<v t="1.20130426141258.3932"><vh>_fireApply</vh></v>
<v t="1.20130426141258.3933"><vh>handlerUpdated</vh></v>
<v t="1.20130426141258.3934"><vh>updateSelected</vh></v>
<v t="1.20130426141258.3935"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3936"><vh>definePath</vh></v>
<v t="1.20130426141258.3937"><vh>shape</vh></v>
<v t="1.20130426141258.3938"><vh>paint</vh></v>
<v t="1.20130426141258.3939"><vh>distance</vh></v>
<v t="1.20130426141258.3940"><vh>angle</vh></v>
<v t="1.20130426141258.3941"><vh>scenePos</vh></v>
<v t="1.20130426141258.3942"><vh>deltaPos</vh></v>
</v>
<v t="1.20130426141258.3943"><vh>class ActionHandler</vh>
<v t="1.20130426141258.3944"><vh>__init__</vh></v>
<v t="1.20130426141258.3945"><vh>_fireApply</vh></v>
<v t="1.20130426141258.3946"><vh>positionChanged</vh></v>
<v t="1.20130426141258.3947"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3948"><vh>paint</vh></v>
</v>
<v t="1.20130426141258.3949"><vh>class ArcAngle</vh>
<v t="1.20130426141258.3950"><vh>__init__</vh></v>
<v t="1.20130426141258.3951"><vh>updateSelected</vh></v>
<v t="1.20130426141258.3952"><vh>definePath</vh></v>
<v t="1.20130426141258.3953"><vh>shape</vh></v>
<v t="1.20130426141258.3954"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3955"><vh>paint</vh></v>
<v t="1.20130426141258.3956"><vh>mousePressEvent</vh></v>
<v t="1.20130426141258.3957"><vh>mouseMoveEvent</vh></v>
<v t="1.20130426141258.3958"><vh>setRotation</vh></v>
<v t="1.20130426141258.3959"><vh>contextMenuEvent</vh></v>
<v t="1.20130426141258.3960"><vh>_keyPress</vh></v>
<v t="1.20130426141258.3961"><vh>_apply</vh></v>
</v>
<v t="1.20130426141258.3962"><vh>class ContextMenu</vh>
<v t="1.20130426141258.3963"><vh>__init__</vh></v>
</v>
<v t="1.20130426141258.3964"><vh>class CirclePosition</vh>
<v t="1.20130426141258.3965"><vh>__init__</vh></v>
<v t="1.20130426141258.3966"><vh>updateSelected</vh></v>
<v t="1.20130426141258.3967"><vh>definePath</vh></v>
<v t="1.20130426141258.3968"><vh>shape</vh></v>
<v t="1.20130426141258.3969"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3970"><vh>paint</vh></v>
<v t="1.20130426141258.3971"><vh>mousePressEvent</vh></v>
<v t="1.20130426141258.3972"><vh>mouseReleaseEvent</vh></v>
<v t="1.20130426141258.3973"><vh>mouseMoveEvent</vh></v>
<v t="1.20130426141258.3974"><vh>contextMenuEvent</vh></v>
<v t="1.20130426141258.3975"><vh>_keyPress</vh></v>
<v t="1.20130426141258.3976"><vh>_apply</vh></v>
</v>
<v t="1.20130426141258.3977"><vh>class ArrowItem</vh>
<v t="1.20130426141258.3978"><vh>__init__</vh></v>
<v t="1.20130426141258.3979"><vh>updateSelected</vh></v>
<v t="1.20130426141258.3980"><vh>definePath</vh></v>
<v t="1.20130426141258.3981"><vh>shape</vh></v>
<v t="1.20130426141258.3982"><vh>boundingRect</vh></v>
<v t="1.20130426141258.3983"><vh>paint</vh></v>
<v t="1.20130426141258.3984"><vh>mousePressEvent</vh></v>
<v t="1.20130426141258.3985"><vh>mouseReleaseEvent</vh></v>
<v t="1.20130426141258.3986"><vh>mouseMoveEvent</vh></v>
<v t="1.20130426141258.3987"><vh>setDistance</vh></v>
<v t="1.20130426141258.3988"><vh>contextMenuEvent</vh></v>
<v t="1.20130426141258.3989"><vh>_keyPress</vh></v>
<v t="1.20130426141258.3990"><vh>_apply</vh></v>
</v>
</v>
<v t="1.20130426141258.3991"><vh>@clean arc.py</vh>
<v t="1.20130426141258.3992"><vh>&lt;&lt;declarations&gt;&gt; (arc)</vh></v>
<v t="1.20130426141258.3993"><vh>class Arc</vh>
<v t="1.20130426141258.3994"><vh>__init__</vh></v>
<v t="1.20130426141258.3995"><vh>drawShape</vh></v>
<v t="1.20130426141258.3996"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.3997"><vh>@clean arrowitem.py</vh>
<v t="1.20130426141258.3998"><vh>&lt;&lt;declarations&gt;&gt; (arrowitem)</vh></v>
<v t="1.20130426141258.3999"><vh>class ArrowItem</vh>
<v t="1.20130426141258.4000"><vh>definePath</vh></v>
<v t="1.20130426141258.4001"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4002"><vh>paint</vh></v>
</v>
</v>
<v t="1.20130426141258.4003"><vh>@clean base.py</vh>
<v t="1.20130426141258.4004"><vh>&lt;&lt;declarations&gt;&gt; (base)</vh></v>
<v t="1.20130426141258.4005"><vh>class BaseEntity</vh>
<v t="1.20130426141258.4006"><vh>__init__</vh></v>
<v t="1.20130426141258.4007"><vh>nearestSnapPoint</vh></v>
<v t="1.20130426141258.4008"><vh>entity</vh></v>
<v t="1.20130426141258.4009"><vh>ID</vh></v>
<v t="1.20130426141258.4010"><vh>geoItem</vh></v>
<v t="1.20130426141258.4011"><vh>style</vh></v>
<v t="1.20130426141258.4012"><vh>toolTipMessage</vh></v>
<v t="1.20130426141258.4013"><vh>updateSelected</vh></v>
<v t="1.20130426141258.4014"><vh>itemChange</vh></v>
<v t="1.20130426141258.4015"><vh>setColor</vh></v>
<v t="1.20130426141258.4016"><vh>setHiglight</vh></v>
<v t="1.20130426141258.4017"><vh>hoverEnterEvent</vh></v>
<v t="1.20130426141258.4018"><vh>hoverLeaveEvent</vh></v>
<v t="1.20130426141258.4019"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4020"><vh>drawShape</vh></v>
<v t="1.20130426141258.4021"><vh>shape</vh></v>
<v t="1.20130426141258.4022"><vh>paint</vh></v>
<v t="1.20130426141258.4023"><vh>getDistance</vh></v>
<v t="1.20130426141258.4024"><vh>boundingRect</vh></v>
</v>
</v>
<v t="1.20130426141258.4025"><vh>@clean dimension.py</vh>
<v t="1.20130426141258.4026"><vh>&lt;&lt;declarations&gt;&gt; (dimension)</vh></v>
<v t="1.20130426141258.4027"><vh>class Dimension</vh>
<v t="1.20130426141258.4028"><vh>__init__</vh></v>
<v t="1.20130426141258.4029"><vh>updateInfo</vh></v>
<v t="1.20130426141258.4030"><vh>calculateTextPoint</vh></v>
<v t="1.20130426141258.4031"><vh>getDimensioLines</vh></v>
<v t="1.20130426141258.4032"><vh>drawShape</vh></v>
<v t="1.20130426141258.4033"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4034"><vh>@clean dinamicentryobject.py</vh>
<v t="1.20130426141258.4035"><vh>&lt;&lt;declarations&gt;&gt; (dinamicentryobject)</vh></v>
<v t="1.20130426141258.4036"><vh>class DinamicEntryLine</vh>
<v t="1.20130426141258.4037"><vh>__init__</vh></v>
<v t="1.20130426141258.4038"><vh>setPos</vh></v>
<v t="1.20130426141258.4039"><vh>text</vh></v>
<v t="1.20130426141258.4040"><vh>text</vh></v>
<v t="1.20130426141258.4041"><vh>show</vh></v>
<v t="1.20130426141258.4042"><vh>keyPressEvent</vh></v>
</v>
</v>
<v t="1.20130426141258.4043"><vh>@clean ellipse.py</vh>
<v t="1.20130426141258.4044"><vh>&lt;&lt;declarations&gt;&gt; (ellipse)</vh></v>
<v t="1.20130426141258.4045"><vh>class Ellipse</vh>
<v t="1.20130426141258.4046"><vh>__init__</vh></v>
<v t="1.20130426141258.4047"><vh>drawShape</vh></v>
<v t="1.20130426141258.4048"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4049"><vh>@clean point.py</vh>
<v t="1.20130426141258.4050"><vh>&lt;&lt;declarations&gt;&gt; (point)</vh></v>
<v t="1.20130426141258.4051"><vh>class Point</vh>
<v t="1.20130426141258.4052"><vh>__init__</vh></v>
<v t="1.20130426141258.4053"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4054"><vh>drawShape</vh></v>
<v t="1.20130426141258.4055"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4056"><vh>@clean polyline.py</vh>
<v t="1.20130426141258.4057"><vh>&lt;&lt;declarations&gt;&gt; (polyline)</vh></v>
<v t="1.20130426141258.4058"><vh>class Polyline</vh>
<v t="1.20130426141258.4059"><vh>__init__</vh></v>
<v t="1.20130426141258.4060"><vh>getQtPointF</vh></v>
<v t="1.20130426141258.4061"><vh>drawShape</vh></v>
<v t="1.20130426141258.4062"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4063"><vh>@clean segment.py</vh>
<v t="1.20130426141258.4064"><vh>&lt;&lt;declarations&gt;&gt; (segment)</vh></v>
<v t="1.20130426141258.4065"><vh>class Segment</vh>
<v t="1.20130426141258.4066"><vh>__init__</vh></v>
<v t="1.20130426141258.4067"><vh>drawShape</vh></v>
<v t="1.20130426141258.4068"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4069"><vh>@clean text.py</vh>
<v t="1.20130426141258.4070"><vh>&lt;&lt;declarations&gt;&gt; (text)</vh></v>
<v t="1.20130426141258.4071"><vh>class Text</vh>
<v t="1.20130426141258.4072"><vh>__init__</vh></v>
<v t="1.20130426141258.4073"><vh>drawShape</vh></v>
<v t="1.20130426141258.4074"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4075"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.4076"><vh>@path LayerIntf</vh>
<v t="1.20130426141258.4077"><vh>@clean layerdock.py</vh>
<v t="1.20130426141258.4078"><vh>&lt;&lt;declarations&gt;&gt; (layerdock)</vh></v>
<v t="1.20130426141258.4079"><vh>class LayerDock</vh>
<v t="1.20130426141258.4080"><vh>__init__</vh></v>
<v t="1.20130426141258.4081"><vh>ShowAllLayers</vh></v>
<v t="1.20130426141258.4082"><vh>RefreshStructure</vh></v>
</v>
</v>
<v t="1.20130426141258.4083"><vh>@clean layertreeobject.py</vh>
<v t="1.20130426141258.4084"><vh>&lt;&lt;declarations&gt;&gt; (layertreeobject)</vh></v>
<v t="1.20130426141258.4085"><vh>class LayerItem</vh>
<v t="1.20130426141258.4086"><vh>__init__</vh></v>
<v t="1.20130426141258.4087"><vh>setActive</vh></v>
<v t="1.20130426141258.4088"><vh>setVisible</vh></v>
<v t="1.20130426141258.4089"><vh>name</vh></v>
<v t="1.20130426141258.4090"><vh>id</vh></v>
</v>
<v t="1.20130426141258.4091"><vh>class LayerTreeObject</vh>
<v t="1.20130426141258.4092"><vh>__init__</vh></v>
<v t="1.20130426141258.4093"><vh>itemDoubleClicked</vh></v>
<v t="1.20130426141258.4094"><vh>updateTreeStructure</vh></v>
<v t="1.20130426141258.4095"><vh>populateStructure</vh></v>
<v t="1.20130426141258.4096"><vh>contextMenuEvent</vh></v>
<v t="1.20130426141258.4097"><vh>_addChild</vh></v>
<v t="1.20130426141258.4098"><vh>_remove</vh></v>
<v t="1.20130426141258.4099"><vh>_rename</vh></v>
<v t="1.20130426141258.4100"><vh>_hide</vh></v>
<v t="1.20130426141258.4101"><vh>_show</vh></v>
<v t="1.20130426141258.4102"><vh>_setCurrent</vh></v>
<v t="1.20130426141258.4103"><vh>_property</vh></v>
<v t="1.20130426141258.4104"><vh>currentIterfaceTreeObject</vh></v>
</v>
</v>
<v t="1.20130426141258.4105"><vh>@clean __init__.py</vh></v>
</v>
<v t="1.20130426141258.4106"><vh>@path Preview</vh>
<v t="1.20130426141258.4107"><vh>@clean arc.py</vh>
<v t="1.20130426141258.4108"><vh>&lt;&lt;declarations&gt;&gt; (arc)</vh></v>
<v t="1.20130426141258.4109"><vh>class PreviewArc</vh>
<v t="1.20130426141258.4110"><vh>__init__</vh></v>
<v t="1.20130426141258.4111"><vh>canDraw</vh></v>
<v t="1.20130426141258.4112"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4113"><vh>drawShape</vh></v>
<v t="1.20130426141258.4114"><vh>updatePreview</vh></v>
</v>
</v>
<v t="1.20130426141258.4115"><vh>@clean base.py</vh>
<v t="1.20130426141258.4116"><vh>&lt;&lt;declarations&gt;&gt; (base)</vh></v>
<v t="1.20130426141258.4117"><vh>class PreviewBase</vh>
<v t="1.20130426141258.4118"><vh>__init__</vh></v>
<v t="1.20130426141258.4119"><vh>updateColor</vh></v>
<v t="1.20130426141258.4120"><vh>updatePreview</vh></v>
<v t="1.20130426141258.4121"><vh>paint</vh></v>
<v t="1.20130426141258.4122"><vh>convertToQTObject</vh></v>
<v t="1.20130426141258.4123"><vh>revertToQTObject</vh></v>
<v t="1.20130426141258.4124"><vh>shape</vh></v>
<v t="1.20130426141258.4125"><vh>drawShape</vh></v>
<v t="1.20130426141258.4126"><vh>boundingRect</vh></v>
</v>
</v>
<v t="1.20130426141258.4127"><vh>@clean ellipse.py</vh>
<v t="1.20130426141258.4128"><vh>&lt;&lt;declarations&gt;&gt; (ellipse)</vh></v>
<v t="1.20130426141258.4129"><vh>class QtEllipseItem</vh>
<v t="1.20130426141258.4130"><vh>__init__</vh></v>
<v t="1.20130426141258.4131"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4132"><vh>drawShape</vh></v>
<v t="1.20130426141258.4133"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4134"><vh>center</vh></v>
<v t="1.20130426141258.4135"><vh>center</vh></v>
<v t="1.20130426141258.4136"><vh>major</vh></v>
<v t="1.20130426141258.4137"><vh>major</vh></v>
<v t="1.20130426141258.4138"><vh>minor</vh></v>
<v t="1.20130426141258.4139"><vh>minor</vh></v>
</v>
</v>
<v t="1.20130426141258.4140"><vh>@clean factory.py</vh>
<v t="1.20130426141258.4141"><vh>&lt;&lt;declarations&gt;&gt; (factory)</vh></v>
<v t="1.20130426141258.4142"><vh>getPreviewObject</vh></v>
</v>
<v t="1.20130426141258.4143"><vh>@clean point.py</vh>
<v t="1.20130426141258.4144"><vh>&lt;&lt;declarations&gt;&gt; (point)</vh></v>
<v t="1.20130426141258.4145"><vh>class PreviewPoint</vh>
<v t="1.20130426141258.4146"><vh>__init__</vh></v>
<v t="1.20130426141258.4147"><vh>drawShape</vh></v>
<v t="1.20130426141258.4148"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4149"><vh>boundingRect</vh></v>
</v>
</v>
<v t="1.20130426141258.4150"><vh>@clean polygon.py</vh>
<v t="1.20130426141258.4151"><vh>&lt;&lt;declarations&gt;&gt; (polygon)</vh></v>
<v t="1.20130426141258.4152"><vh>class QtPolygonItem</vh>
<v t="1.20130426141258.4153"><vh>__init__</vh></v>
<v t="1.20130426141258.4154"><vh>polygonPoint</vh></v>
<v t="1.20130426141258.4155"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4156"><vh>drawShape</vh></v>
<v t="1.20130426141258.4157"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4158"><vh>center</vh></v>
<v t="1.20130426141258.4159"><vh>center</vh></v>
<v t="1.20130426141258.4160"><vh>vertex</vh></v>
<v t="1.20130426141258.4161"><vh>vertex</vh></v>
<v t="1.20130426141258.4162"><vh>side</vh></v>
</v>
</v>
<v t="1.20130426141258.4163"><vh>@clean polyline.py</vh>
<v t="1.20130426141258.4164"><vh>&lt;&lt;declarations&gt;&gt; (polyline)</vh></v>
<v t="1.20130426141258.4165"><vh>class QtPolylineItem</vh>
<v t="1.20130426141258.4166"><vh>__init__</vh></v>
<v t="1.20130426141258.4167"><vh>drawShape</vh></v>
<v t="1.20130426141258.4168"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4169"><vh>drawGeometry</vh></v>
</v>
</v>
<v t="1.20130426141258.4170"><vh>@clean rectangle.py</vh>
<v t="1.20130426141258.4171"><vh>&lt;&lt;declarations&gt;&gt; (rectangle)</vh></v>
<v t="1.20130426141258.4172"><vh>class QtRectangleItem</vh>
<v t="1.20130426141258.4173"><vh>__init__</vh></v>
<v t="1.20130426141258.4174"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4175"><vh>boundingRect</vh></v>
<v t="1.20130426141258.4176"><vh>getRectangle</vh></v>
</v>
</v>
<v t="1.20130426141258.4177"><vh>@clean segment.py</vh>
<v t="1.20130426141258.4178"><vh>&lt;&lt;declarations&gt;&gt; (segment)</vh></v>
<v t="1.20130426141258.4179"><vh>class PreviewSegment</vh>
<v t="1.20130426141258.4180"><vh>__init__</vh></v>
<v t="1.20130426141258.4181"><vh>canDraw</vh></v>
<v t="1.20130426141258.4182"><vh>drawGeometry</vh></v>
<v t="1.20130426141258.4183"><vh>drawShape</vh></v>
</v>
</v>
<v t="1.20130426141258.4184"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="1.20130426141258.2394">這是 PythonCAD 的程式碼, 利用 PyQt 作為 GUI, SQLite 作為資料庫檔案, 內建簡單的 2D 繪圖核心, 若在實際應用上需要增進繪圖速度, 則可將部份核心程式碼改用 C 或 C++ 編寫.</t>
<t tx="1.20130426141258.2396">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2397">from PyQt5 import QtCore
from Kernel.document     import *
from Kernel.exception    import *
from Kernel.GeoEntity.point         import Point
from Kernel.Command.basecommand     import BaseCommand
from Interface.pycadapp             import PyCadApp
</t>
<t tx="1.20130426141258.2398">class testCmdLine(object):
    @others
</t>
<t tx="1.20130426141258.2399">def __init__(self, dialog, scene):
    self.dialog=dialog
    self.scene=scene
    self._addCustomEvent()
    self._inizializeCommand()
    self.activeCommand=None
</t>
<t tx="1.20130426141258.2400">def _inizializeCommand(self):    
    """
        inizialize all the command class
    """
    self.__command={}
    self.__applicationCommand={}
    self.__pyCadApplication=PyCadApp.Application()
    # Application Command
    self.__applicationCommand['Documents']=GetDocuments(self.__pyCadApplication.getDocuments(), self.outputMsg)
    self.__applicationCommand['CreateStyle']=CreateStyle(self.__pyCadApplication.ActiveDocument)
    #self.__applicationCommand['SetActiveDoc']=SetActiveDoc(self.__pyCadApplication)
    self.__applicationCommand['GetActiveDoc']=GetActiveDoc(self.__pyCadApplication, self.outputMsg)
    self.__applicationCommand['GetEnts']=GetEnts(self.__pyCadApplication.ActiveDocument, self.outputMsg)
    self.__applicationCommand['EntExsist']=EntityExsist(self.__pyCadApplication.ActiveDocument,self.outputMsg )
    self.__applicationCommand['Delete']=DeleteEntity(self.__pyCadApplication.ActiveDocument,self.outputMsg )
    self.__applicationCommand['UnDo']=UnDo(self.__pyCadApplication, self.outputMsg)
    self.__applicationCommand['ReDo']=ReDo(self.__pyCadApplication, self.outputMsg)
    self.__applicationCommand['T']=TestKernel(self.__pyCadApplication, self.outputMsg)
    self.__applicationCommand['ET']=EasyTest(self.__pyCadApplication, self.outputMsg)
    self.__applicationCommand['Info']=EntityInfo(self.__pyCadApplication.ActiveDocument, self.outputMsg)
    # Document Commandf
    for command in self.__pyCadApplication.getCommandList():
        self.__applicationCommand[command]=self.__pyCadApplication.getCommand(command)
    self.__applicationCommand['?']=PrintHelp(self.__applicationCommand, self.outputMsg)    
</t>
<t tx="1.20130426141258.2401">def _addCustomEvent(self):
    """
        add custom event at the user interface
    """
    self.dialog.ImputCmd.returnPressed.connect(self.imputCommand)
    #QtCore.QObject.connect(self.dialog.uiTextEditor, QtCore.SIGNAL("textChanged()"),self.imputCommand)
    #QtCore.QObject.connect(self.uiTextEditor, QtCore.SIGNAL("textChanged()"), self.uiTextEditor.update)
</t>
<t tx="1.20130426141258.2402">def imputCommand(self):
    """
        imput dialog
    """
    text=self.dialog.ImputCmd.text()
    self.outputMsg("&gt;&gt;&gt; "+str(text))
    if self.activeCommand:
        try:
            if not self.performCommand(self.activeCommand, text):
                self.activeCommand=None
                #self.scene.populateScene(self.__pyCadApplication.ActiveDocument)
            else:
                self.outputMsg(self.activeCommand.getActiveMessage())
        except:
            self.outputMsg("Unable to perfor the command")
            self.activeCommand=None
    else:
        cmdObject=None
        if text in self.__applicationCommand:
            cmdObject=self.__applicationCommand[text]
            cmdObject.reset()
            self.outputMsg(cmdObject.getActiveMessage())
        else:
            self.outputMsg('Command not avaiable write ? for command list')
        self.activeCommand=cmdObject
    self.dialog.ImputCmd.setText("")
</t>
<t tx="1.20130426141258.2403">def performCommand(self,cObject, text):
    """
        Perform a Command
        cObject is the command object
    """
    try:
        iv=next(cObject)
        exception,message=iv
        try:
            raise exception(None)
        except ExcPoint:
            cObject[iv]=self.convertToPoint(text)  
            return cObject
        except (ExcLenght, ExcAngle, ExcInt):
            cObject[iv]=self.convertToFloat(text)
            return cObject
        except (ExcBool):
            cObject[iv]=self.convertToBool(text)
            return cObject
        except (ExcText):
            cObject[iv]=text
            return cObject
        except (ExcEntity):
            cObject[iv]=self.convertToInt(text)
            return cObject
        except:
            msg="Error on command imput"
            self.outputMsg(msg)
            raise CommandException(msg)
        
    except (StopIteration):
        cObject.applyCommand()
        return None
    except PyCadWrongCommand:
        self.outputMsg("Wrong Command")
</t>
<t tx="1.20130426141258.2404">def convertToBool(self, msg):   
    """
        return an int from user
    """        
    if msg=="Yes":
        return True
    else:
        return False
</t>
<t tx="1.20130426141258.2405">def convertToInt(self, msg):   
    """
        return an int from user
    """        
    if msg:
        return int(msg)
    return None
</t>
<t tx="1.20130426141258.2406">def convertToFloat(self, msg):
    """
        return a float number
    """
    if msg:
        return float(msg)
    return None
</t>
<t tx="1.20130426141258.2407">def convertToPoint(self, msg):
    """
        ask at the user to imput a point 
    """
    if msg:
        coords=msg.split(',')
        x=float(coords[0])
        y=float(coords[1])
        return Point(x, y)
    return None
</t>
<t tx="1.20130426141258.2408">def outputMsg(self, msg):   
    """
        print a message in to the self.dialog.uiTextEditor 
    """ 
    #self.dialog.uiTextEditor.moveCursor(QtGui.QTextCursor.Down)
    msg="\r&lt;PythonCAD&gt; : "+msg
    self.dialog.uiTextEditor.insertPlainText(msg)
</t>
<t tx="1.20130426141258.2409">def printEntity(ents, msgFucntion):
        """
            print a query result
        """
        i=0
        for e in ents:
            msgFucntion("Entity Type %s id %s "%(str(e.eType),str(e.getId())))
            if i &gt; 100:
                msgFucntion("There are more then 100 entitys in the select so i stop printing")
                break
            i+=1
</t>
<t tx="1.20130426141258.2410">class GetEnts(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2411">def __init__(self, document, msgFucntion):
    BaseCommand.__init__(self, document)
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.outputMsg=msgFucntion
    self.exception=[ExcText]
    self.message=["Give Me the Document Type Enter for All"]
</t>
<t tx="1.20130426141258.2412">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    docName=self.value[0]
    startTime=time.clock()
    if not docName:
        docName="ALL"
    ents=self.document.getEntityFromType(docName)
    endTime=time.clock()-startTime       
    printEntity(ents,self.outputMsg )
    self.outputMsg("Exec query get %s ent in %s s"%(str(len(ents)), str(endTime)))
    self.outputMsg("********************************")
</t>
<t tx="1.20130426141258.2413">class UnDo(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2414">def __init__(self, application, msgFunction):
    BaseCommand.__init__(self, None)
    self.__application=application
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.message=["Press enter to perform the Undo command"]
    self.outputMsg=msgFunction
</t>
<t tx="1.20130426141258.2415">def applyCommand(self):
    if len(self.value)!=0:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    doc=self.__application.ActiveDocument
    doc.unDo()
</t>
<t tx="1.20130426141258.2416">class ReDo(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2417">def __init__(self, application, msgFunction):
    BaseCommand.__init__(self, None)
    self.__application=application
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.message=["Press enter to perform the ReDo command"]
    self.outputMsg=msgFunction
</t>
<t tx="1.20130426141258.2418">def applyCommand(self):
    if len(self.value)!=0:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    doc=self.__application.ActiveDocument
    doc.reDo()
</t>
<t tx="1.20130426141258.2419">class GetActiveDoc(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2420">def __init__(self, application, msgFunction):
    BaseCommand.__init__(self, None)
    self.__application=application
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.message=["Press enter to perform the command"]
    self.outputMsg=msgFunction
</t>
<t tx="1.20130426141258.2421">def applyCommand(self):
    if len(self.value)!=0:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    docName=self.value[0]
    self.__application.ActiveDocument=docName
    doc=self.__application.ActiveDocument
    self.outputMsg("Active Document is %s"%str(doc.dbPath))
</t>
<t tx="1.20130426141258.2422">class SetActiveDoc(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2423">def __init__(self, application):
    BaseCommand.__init__(self, None)
    self.__application=application
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[ExcText]
    self.message=["Give Me the Document Name"]
</t>
<t tx="1.20130426141258.2424">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    docName=self.value[0]
    self.__application.ActiveDocument=docName
</t>
<t tx="1.20130426141258.2425">class GetDocuments(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2426">def __init__(self, documents, msgFunction):
    BaseCommand.__init__(self, None)
    self.__docuemnts=documents
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.message=["Press enter to perform the command"]
    self.outputMsg=msgFunction
</t>
<t tx="1.20130426141258.2427">def applyCommand(self):
    if len(self.value)!=0:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    self.showDocuments()
</t>
<t tx="1.20130426141258.2428">def showDocuments(self):
    """
        show The list of documents
    """
    try:
        self.outputMsg("Documents in the curret application")
        i=0
        for key in self.__docuemnts:
            self.outputMsg("%s File %s"%(str(i), str(key)))
            i+=1
        self.outputMsg("***********************************")
    except:
        self.outputMsg("Unable To Perform the GetDocuments") 
</t>
<t tx="1.20130426141258.2429">class CreateStyle(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2430">def __init__(self, document):
    BaseCommand.__init__(self, document)
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[ExcText]
    self.message=["Give Me the Style Name"]
</t>
<t tx="1.20130426141258.2431">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    styleName=self.value[0]
    #self.inputMsg("Write style name")
    stl=Style(styleName)
    self.document.saveEntity(stl)
</t>
<t tx="1.20130426141258.2432">class EntityExsist(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2433">def __init__(self, document, msgFunction ):
    BaseCommand.__init__(self, document)
    self.outputMsg=msgFunction
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[ExcText]
    self.message=["Give me the entity id"]
</t>
<t tx="1.20130426141258.2434">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    entId=self.value[0]
    #self.inputMsg("Write style name")
    if self.document.entityExsist(entId):
        self.outputMsg("Entity Found in the db")
    else:
        self.outputMsg("Entity Not Found")
</t>
<t tx="1.20130426141258.2435">class DeleteEntity(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2436">def __init__(self, document, msgFunction ):
    BaseCommand.__init__(self, document)
    self.outputMsg=msgFunction
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[ExcText]
    self.message=["Give me the entity id"]
</t>
<t tx="1.20130426141258.2437">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    entId=self.value[0]
    #self.inputMsg("Write style name")
    if self.document.entityExsist(entId):
        self.document.deleteEntity(entId)
</t>
<t tx="1.20130426141258.2438">class EntityInfo(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2439">def __init__(self, document, msgFunction ):
    BaseCommand.__init__(self, document)
    self.outputMsg=msgFunction
    self.exception=[ExcText]
    self.message=["Give me the entity id"]
</t>
<t tx="1.20130426141258.2440">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    entId=self.value[0]
    if self.document.entityExsist(entId):
        ent=self.document.getEntity(entId)
        geoEnt=self.document.convertToGeometricalEntity(ent)
        self.outputMsg("Entity %s"%str(geoEnt))
    else:
        self.outputMsg("Wrong id Number")
</t>
<t tx="1.20130426141258.2441">class PrintHelp(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2442">def __init__(self, commandArray, msgFunction):
    BaseCommand.__init__(self, None)
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.outputMsg=msgFunction
    self.message=["Print the help Press enter to ally the command "]
    self.commandNames=list(commandArray.keys())
</t>
<t tx="1.20130426141258.2443">def __next__(self):    
    raise StopIteration
</t>
<t tx="1.20130426141258.2444">def applyCommand(self):
    self.outputMsg("***********Command List******************")
    self.commandNames.sort()
    for s in self.commandNames:
        self.outputMsg(s)
</t>
<t tx="1.20130426141258.2445">class TestKernel(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2446">def __init__(self, application, msgFunction):
    BaseCommand.__init__(self, None)
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.outputMsg=msgFunction
    self.message=["Press enter to start the test"]
    self.__pyCadApplication=application
</t>
<t tx="1.20130426141258.2447">def __next__(self):    
    raise StopIteration
</t>
<t tx="1.20130426141258.2448">def applyCommand(self):
    self.outputMsg("*********** Start Test ******************")
    self.featureTest()
    self.outputMsg("*********** End   Test ******************")
</t>
<t tx="1.20130426141258.2449">def featureTest(self):
        """
            this function make a basic test
        """
        self.outputMsg("Create a new document 1")
        doc1=self.__pyCadApplication.newDocument()
        self.outputMsg("Create a new document 2")
        doc2=self.__pyCadApplication.newDocument()
        self.outputMsg("Set Current p1")
        self.__pyCadApplication.ActiveDocument=doc1
        self.outputMsg("Create Point")
        self.performCommandRandomly("POINT")
        self.outputMsg("Create Segment")
        self.performCommandRandomly("SEGMENT")
        self.outputMsg("Create Arc")
        self.performCommandRandomly("ARC")
        self.__pyCadApplication.ActiveDocument=doc2
        self.outputMsg("Create Ellipse")
        self.performCommandRandomly("ELLIPSE")
        self.outputMsg("Create Polyline")
        self.performCommandRandomly("POLYLINE")
        self.outputMsg("Create ACLine")
        self.performCommandRandomly("ACLINE")
        
        self.outputMsg("Get Entitys for doc 1")
        self.__pyCadApplication.ActiveDocument=doc1
        activeDoc=self.__pyCadApplication.ActiveDocument
        ents=activeDoc.getEntityFromType("ALL")
        self.printEntity(ents)
        self.outputMsg("Get Entitys for doc 2")
        self.__pyCadApplication.ActiveDocument=doc2
        activeDoc=self.__pyCadApplication.ActiveDocument
        ents=activeDoc.getEntityFromType("ALL")
        self.printEntity(ents)
        # Working with styles
        self.outputMsg("Create NewStyle")
        stl=Style("NewStyle")
        self.outputMsg("Save in document")
        activeDoc.saveEntity(stl)
        activeDoc.setActiveStyle(name='NewStyle')
        self.outputMsg("Create Segment")
        self.performCommandRandomly("SEGMENT")
        self.outputMsg("Create Arc")
        self.performCommandRandomly("ARC")
        
        self.outputMsg("Create NewStyle1")
        stl1=Style("NewStyle1")
        self.__pyCadApplication.setApplicationStyle(stl1)
        stl11=self.__pyCadApplication.getApplicationStyle(name='NewStyle1')
        styleDic=stl11.getConstructionElements()
        styleDic[list(styleDic.keys())[0]].setStyleProp('entity_color',(255,215,000))
        self.__pyCadApplication.setApplicationStyle(stl11)
        activeDoc.saveEntity(stl11)
        self.outputMsg("Create Segment")
        self.performCommandRandomly("SEGMENT")
        self.outputMsg("Create Arc")
        self.performCommandRandomly("ARC")
        
        self.outputMsg("Create NewStyle2 ")
        stl1=Style("NewStyle2")
        stl12=activeDoc.saveEntity(stl1)
        styleDic=stl11.getConstructionElements()
        styleDic[list(styleDic.keys())[0]].setStyleProp('entity_color',(255,215,000))
        self.outputMsg("Update NewStyle2")
        activeDoc.saveEntity(stl12)
        self.outputMsg("Done")
        # Test  Geometrical chamfer ent
        self.GeotestChamfer()
        # Test Chamfer Command 
        self.testChamferCommand()
</t>
<t tx="1.20130426141258.2450">def testGeoChamfer(self):    
    self.outputMsg("Test Chamfer")
    p1=Point(0.0, 0.0)
    p2=Point(10.0, 0.0)
    p3=Point(0.0, 10.0)
    
    s1=Segment(p1, p2)
    s2=Segment(p1, p3)
    
    cmf=Chamfer(es1.getId(), s2, 2.0, 2.0)
    cl=cmf.getLength()
    self.outputMsg("Chamfer Lengh %s"%str(cl))
    s1, s2, s3=cmf.getReletedComponent()
    if s3:
        for p in s3.getEndpoints():
            x, y=p.getCoords()
            self.outputMsg("P1 Cords %s,%s"%(str(x), str(y)))
    else:
        self.outputMsg("Chamfer segment in None")
</t>
<t tx="1.20130426141258.2451">def testChamferCommand(self):
    """
        this function is usefoul for short test
        as soon it works copy the code into featureTest
    """
    newDoc=self.__pyCadApplication.newDocument()
    intPoint=Point(0.0, 0.0)
    
    s1=Segment(intPoint, Point(10.0, 0.0))
    s2=Segment(intPoint, Point(0.0, 10.0))
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
   
    cObject=self.__pyCadApplication.getCommand("CHAMFER")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=2
    cObject[keys[3]]=2
    cObject[keys[4]]=None
    cObject[keys[5]]=None
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2452">def getRandomPoint(self):
    """
        get e random point
    """
    x=random()*1000
    y=random()*1000
    return Point(x, y)
</t>
<t tx="1.20130426141258.2453">def performCommandRandomly(self, commandName, andLoop=10):
    """
        set some random Value at the command imput
    """
    self.outputMsg("Start Command %s"%str(commandName))
    i=0
    cObject=self.__pyCadApplication.getCommand(commandName)
    for iv in cObject:
        exception,message=iv
        try:
            raise exception(None)
        except ExcPoint:
            self.outputMsg("Add Point")
            if i&gt;=andLoop:
                cObject[iv]=None
            else:
                cObject[iv]=self.getRandomPoint()
        except (ExcLenght, ExcAngle):
            self.outputMsg("Add Lengh/Angle")
            cObject[iv]=100
        except:
            self.outputMsg("Bad error !!")
            raise 
        i+=1
    else:
        self.outputMsg("Apply Command")
        cObject.applyCommand()
</t>
<t tx="1.20130426141258.2454">class EasyTest(BaseCommand):
    @others
</t>
<t tx="1.20130426141258.2455">def __init__(self, application, msgFunction):
    BaseCommand.__init__(self, None)
    #PyCadBaseCommand.__exception=[ExcPoint, ExcPoint]
    self.exception=[]
    self.outputMsg=msgFunction
    self.message=["Press enter to start the test"]
    self.__pyCadApplication=application
</t>
<t tx="1.20130426141258.2456">def __next__(self):    
    raise StopIteration
</t>
<t tx="1.20130426141258.2457">def applyCommand(self):
    self.outputMsg("*********** Start Test ******************")
    self.easyTest()
    
    #self.MassiveDelete()
    self.outputMsg("*********** End   Test ******************")    
</t>
<t tx="1.20130426141258.2458">def MassiveDelete(self):
    try:
        import time
        startTime=time.clock()
        newDoc=self.__pyCadApplication.ActiveDocument
        newDoc.startMassiveCreation()
        for i in range(1000):
            intPoint=Point(i, i)
            args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(10.0, 0.0)}
            s1=Segment(args)    
            newDoc.saveEntity(s1)
        else:
            newDoc.performCommit()    
            newDoc.stopMassiveCreation()
            endTime=time.clock()-startTime
            print("Create 1000 entity in %s"%str(endTime))    
    finally:
        ents=newDoc.getAllDrawingEntity()
        ids=[ent.getId() for ent in ents]
        startTime=time.clock()
        newDoc.massiveDelete(ids)
        endTime=time.clock()-startTime
        print("Delete 1000 entity in %s"%str(endTime))    
</t>
<t tx="1.20130426141258.2459">def easyTest(self):
    """
        this function is usefoul for short test
        as soon it works copy the code into featureTest
    """
    newDoc=self.__pyCadApplication.ActiveDocument
    newDoc.startMassiveCreation()
    #self.testChamfer()
    #self.testFillet1()
    #self.testFillet2()
    #self.multitest()
    #self.testMirror()
    #self.testMove()
    #self.rotate()
    self.trim()
    newDoc.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2460">def trim(self):    
    """
        test the trim command
    """
    newDoc=self.__pyCadApplication.ActiveDocument
    
    sArg1={"SEGMENT_0":Point(0, 0), "SEGMENT_1":Point(150, 0)}
    _st1=Segment(sArg1)
    newSeg1=newDoc.saveEntity(_st1)
    
    sArg2={"SEGMENT_0":Point(200, 0), "SEGMENT_1":Point(200, 150)}
    _st2=Segment(sArg2)
    newSeg2=newDoc.saveEntity(_st2)
    trimCmd=self.__pyCadApplication.getCommand('TRIM')
    
    keys=list(trimCmd.keys())
    trimCmd[keys[0]]=newSeg1.getId()
    trimCmd[keys[1]]=newSeg2.getId()
    trimCmd[keys[2]]=Point(140, 1)
    trimCmd[keys[3]]=Point(210, 1)
    trimCmd[keys[4]]="B"
    trimCmd.applyCommand() 
</t>
<t tx="1.20130426141258.2461">def rotate(self):
    """
        perform a rotate operation
    """
    newDoc=self.__pyCadApplication.ActiveDocument
    ang=1.5707963267948966
    cp=Point(0, 0)
    newDoc.saveEntity(cp)
    #Point 
    centerPoint=Point(100,100)
    dbPointEnt=newDoc.saveEntity(centerPoint)
    centerPoint.rotate(cp, ang)
    dbPointEnt=newDoc.saveEntity(centerPoint)
    
    #Arc 
    centerPoint=Point(100, 100)
    arg={"ARC_0":centerPoint, "ARC_1":50, "ARC_2":0.78539816339500002,"ARC_3":1.5707963267948966}
    arc=Arc(arg)
    entArc=newDoc.saveEntity(arc)
    arc.rotate(cp,ang)
    entArc=newDoc.saveEntity(arc)
    
    #Segment
    sArg={"SEGMENT_0":Point(100, 100), "SEGMENT_1":Point(150, 150)}
    _st=Segment(sArg)
    newSeg=newDoc.saveEntity(_st)
    _st.rotate(cp, ang)
    newDoc.saveEntity(_st)
    #Ellipse
    eArg={"ELLIPSE_0":Point(100, 0), "ELLIPSE_1":100, "ELLIPSE_2":50}
    _e=Ellipse(eArg)
    newE=newDoc.saveEntity(_e)
    _e.rotate(cp, ang)
    newDoc.saveEntity(_e)
</t>
<t tx="1.20130426141258.2462">def testMove(self):
    """
        perform a move operation
    """
    #Arc 
    newDoc=self.__pyCadApplication.ActiveDocument
    centerPoint=Point(100, 100)
    arg={"ARC_0":centerPoint, "ARC_1":50, "ARC_2":0.78539816339500002,"ARC_3":1.5707963267948966}
    arc=Arc(arg)
    entArc=newDoc.saveEntity(arc)
    
    sp=Point(0, 0)
    ep=Point(100, 100)
   
    arc.move(sp, ep)
    entArc=newDoc.saveEntity(arc)
    #Point 
    centerPoint=Point(100, 0)
    dbPointEnt=newDoc.saveEntity(centerPoint)
    centerPoint.move(sp, ep)
    dbPointEnt=newDoc.saveEntity(centerPoint)
    #Segment
    sArg={"SEGMENT_0":Point(100, 100), "SEGMENT_1":Point(150, 150)}
    _st=Segment(sArg)
    newSeg=newDoc.saveEntity(_st)
    _st.move(sp, ep)
    newDoc.saveEntity(_st)
    #Ellipse
    eArg={"ELLIPSE_0":Point(100, 0), "ELLIPSE_1":100, "ELLIPSE_2":50}
    _e=Ellipse(eArg)
    newE=newDoc.saveEntity(_e)
    _e.move(sp, ep)
    newDoc.saveEntity(_e)
</t>
<t tx="1.20130426141258.2463">def testMirror(self):    
    """
        perform a mirror operation of all the entity
    """
    #Arc mirror
    newDoc=self.__pyCadApplication.ActiveDocument
    centerPoint=Point(100, 100)
    arg={"ARC_0":centerPoint, "ARC_1":50, "ARC_2":0.78539816339500002,"ARC_3":1.5707963267948966}
    arc=Arc(arg)
    entArc=newDoc.saveEntity(arc)
    
    sArg={"SEGMENT_0":Point(-100, 0), "SEGMENT_1":Point(0, 100)}
    _s=Segment(sArg)
    
    mirrorSeg=newDoc.saveEntity(_s)
    arc.mirror(_s)
    entArc=newDoc.saveEntity(arc)
    #Point 
    centerPoint=Point(100, 0)
    dbPointEnt=newDoc.saveEntity(centerPoint)
    newcenterPoint=centerPoint.clone()
    newcenterPoint.mirror(_s)
    dbPointEnt=newDoc.saveEntity(newcenterPoint)
    #Segment
    sArg={"SEGMENT_0":Point(100, 100), "SEGMENT_1":Point(150, 150)}
    _st=Segment(sArg)
    newSeg=newDoc.saveEntity(_st)
    _st.mirror(_s)
    newDoc.saveEntity(_st)
    #Ellipse
    eArg={"ELLIPSE_0":Point(100, 0), "ELLIPSE_1":100, "ELLIPSE_2":50}
    _e=Ellipse(eArg)
    newE=newDoc.saveEntity(_e)
    _e.mirror(_s)
    newDoc.saveEntity(_e)
</t>
<t tx="1.20130426141258.2464">def testFillet(self, p1, p2, p3, pp1, pp2, R=100):
    newDoc=self.__pyCadApplication.ActiveDocument
    args={"SEGMENT_0":p1, "SEGMENT_1":p2}
    s1=Segment(args)
    args={"SEGMENT_0":p1, "SEGMENT_1":p3}
    s2=Segment(args)
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)

    cObject=self.__pyCadApplication.getCommand("FILLET")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=pp1
    cObject[keys[3]]=pp2
    cObject[keys[4]]="BOTH"
    cObject[keys[5]]=R
    cObject.applyCommand() 
</t>
<t tx="1.20130426141258.2465">def testBisector(self, p1, p2, p3, pp1, pp2, L=100):
    newDoc=self.__pyCadApplication.ActiveDocument
    args={"SEGMENT_0":p1, "SEGMENT_1":p2}
    s1=Segment(args)
    args={"SEGMENT_0":p1, "SEGMENT_1":p3}
    s2=Segment(args)
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
    
    cObject=self.__pyCadApplication.getCommand("BISECTOR")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=pp1
    cObject[keys[3]]=pp2
    cObject[keys[4]]=L
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2466">def multitest(self):    
    p1=Point(0, 0)
    p2=Point(10, 0)
    p3=Point(0, 10)
    pp1=Point(1, 0)
    pp2=Point(0, 3)
    self.testBisector(p1, p2, p3, pp1, pp2)
    self.testFillet(p1, p2, p3, pp1, pp2)
    
    p1=Point(0, 0)
    p2=Point(-10, 0)
    p3=Point(0, 10)
    pp1=Point(-1,  0)
    pp2=Point(0, 3)
    self.testBisector(p1, p2, p3, pp1, pp2)
    self.testFillet(p1, p2, p3, pp1, pp2)
    
    p1=Point(0, 0)
    p2=Point(-10, 0)
    p3=Point(0, -10)
    pp1=Point(-1, 0)
    pp2=Point(0, -3)
    self.testBisector(p1, p2, p3, pp1, pp2)
    self.testFillet(p1, p2, p3, pp1, pp2)        

    p1=Point(0, 0)
    p2=Point(10, 0)
    p3=Point(0, -10)
    pp1=Point(1, 0)
    pp2=Point(0, -3)
    self.testBisector(p1, p2, p3, pp1, pp2)   
    self.testFillet(p1, p2, p3, pp1, pp2)     
    
    p1=Point(100, 0)
    p2=Point(200, 0)
    p3=Point(200, 100)
    pp1=Point(110, -1)
    pp2=Point(112, 30)
    self.testBisector(p1, p2, p3, pp1, pp2)   
    self.testFillet(p1, p2, p3, pp1, pp2)

    p1=Point(100, 100)
    p2=Point(200, 0)
    p3=Point(200, 100)
    pp1=Point(110, -1)
    pp2=Point(112, 30)
    self.testBisector(p1, p2, p3, pp1, pp2, 30) 
    self.testFillet(p1, p2, p3, pp1, pp2, 30)   
</t>
<t tx="1.20130426141258.2467">def testFillet1(self):
    newDoc=self.__pyCadApplication.ActiveDocument
    intPoint=Point(0.0, 0.0)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(10.0, 0.0)}
    s1=Segment(args)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(0.0, 10.0)}
    s2=Segment(args)
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
    
    cObject=self.__pyCadApplication.getCommand("FILLET")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=Point(1, 0)
    cObject[keys[3]]=Point(0, 3)
    cObject[keys[4]]="BOTH"
    cObject[keys[5]]=4
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2468">def testFillet2(self):    
    newDoc=self.__pyCadApplication.ActiveDocument
    intPoint=Point(0, 0)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(1000, 1000)}
    s1=Segment(args)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(1000, 0)}
    s2=Segment(args)
    
    ent1=newDoc.saveEntity(s1)
    ent2=newDoc.saveEntity(s2)
    
    cObject=self.__pyCadApplication.getCommand("FILLET")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=Point(101, 0)
    cObject[keys[3]]=Point(0, 103)
    cObject[keys[4]]="NO_TRIM"
    cObject[keys[5]]=20
    cObject.applyCommand()

    cObject=self.__pyCadApplication.getCommand("FILLET")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=Point(101, 0)
    cObject[keys[3]]=Point(0, 103)
    cObject[keys[4]]="NO_TRIM"
    cObject[keys[5]]=100
    cObject.applyCommand()        
    
    cObject=self.__pyCadApplication.getCommand("BISECTOR")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=Point(101, 0)
    cObject[keys[3]]=Point(0, 103)
    cObject[keys[4]]=1000
    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2469">def testChamfer(self):
    newDoc=self.__pyCadApplication.ActiveDocument
    intPoint=Point(2.0, 2.0)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(10.0, 0.0)}
    s1=Segment(args)
    args={"SEGMENT_0":intPoint, "SEGMENT_1":Point(0.0, 10.0)}
    s2=Segment(args)
    
    ent1=newDoc.saveEntity(s1).getId()
    ent2=newDoc.saveEntity(s2).getId()
   
    cObject=self.__pyCadApplication.getCommand("CHAMFER")
    keys=list(cObject.keys())
    cObject[keys[0]]=ent1
    cObject[keys[1]]=ent2
    cObject[keys[2]]=None
    cObject[keys[3]]=None
    cObject[keys[4]]="FIRST"
    cObject[keys[5]]=2
    cObject[keys[6]]=2

    cObject.applyCommand()
</t>
<t tx="1.20130426141258.2470">@first #!/usr/bin/env python

#
# This is only needed for Python v2 but is harmless for Python v3.
#

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
#
if __name__ == '__main__':
    w,app=getPythonCAD()
    sys.exit(app.exec_())
</t>
<t tx="1.20130426141258.2471">import sys
#if sys.version_info &lt;(2, 7):
#    try:
#        import sip
#        sip.setapi('QString', 2)
#        sip.setapi('QVariant', 2)
#    except:
#        pass
    
#
from PyQt5 import QtCore, QtGui, QtWidgets
# 
import os
import sqlite3 as sqlite
#
# this is needed for me to use unpickle objects
#
sys.path.append(os.path.join(os.getcwd(), 'Generic'))
sys.path.append(os.path.join(os.getcwd(), 'Interface'))
#
from Interface.cadwindow    import CadWindowMdi
</t>
<t tx="1.20130426141258.2472">#
def getPythonCAD():

    app = QtWidgets.QApplication(sys.argv)
    # splashscreen
    splashPath=os.path.join(os.getcwd(), 'icons', 'splashScreen1.png')
    splash_pix = QtGui.QPixmap(splashPath)
    splash = QtWidgets.QSplashScreen(splash_pix, QtCore.Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    
    w=CadWindowMdi()
    w.show()
    
    # end splashscreen
    splash.finish(w)
    return w, app
</t>
<t tx="1.20130426141258.2473">#encoding: utf-8


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2474">from pythoncad_qt import *
from sympy import *

w,app=getPythonCAD()
w.createSympyDocument()

p=Point(10, 10)
w.plotFromSympy([p])

w.getSympyObject()
</t>
<t tx="1.20130426141258.2475"></t>
<t tx="1.20130426141258.2476"></t>
<t tx="1.20130426141258.2477">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This  module provide the main api interface of pythoncad
#
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__=='__main__':
    from . import application_test  as test
    app= Application()
    doc=app.newDocument()
    #doc.importExternalFormat('C:\Users\mboscolo\Desktop\jettrainer.dxf')
    #segments=doc.getEntityFromType("SEGMENT")
    #print len(segments)
    #test.TestSympy()
    test.TestIntersection()
</t>
<t tx="1.20130426141258.2478">import sys
import os
import shutil
from PyQt5 import QtCore
#
if __name__=="__main__":
    sys.path.append(os.path.join(os.getcwd(), 'Kernel'))
#
from Kernel.pycadevent          import PyCadEvent
from Kernel.exception           import *
from Kernel.document            import *
from Kernel.Command             import *
</t>
<t tx="1.20130426141258.2479">class Application(object):
    """
        this class provide the real pythoncad api interface ..
    """
    @others
</t>
<t tx="1.20130426141258.2480">def __init__(self, **args):
    userDirectory=os.getenv('USERPROFILE') or os.getenv('HOME')
    pyUserDir=os.path.join(userDirectory, "PythonCAD")
    if not os.path.exists(pyUserDir):
        os.makedirs(pyUserDir)
    baseDbName=os.path.join(pyUserDir, 'PythonCAD_Local.pdr')
    #--
    self.kernel=Document(baseDbName)
    self.__applicationCommand=APPLICATION_COMMAND
    # Setting up Application Events
    self.startUpEvent=PyCadEvent()
    self.beforeOpenDocumentEvent=PyCadEvent()
    self.afterOpenDocumentEvent=PyCadEvent()
    self.beforeCloseDocumentEvent=PyCadEvent()
    self.afterCloseDocumentEvent=PyCadEvent()
    self.activeteDocumentEvent=PyCadEvent()
    # manage Document inizialization
    self.__Documents={}
    if 'open' in args:
        self.openDocument(args['open'])
    else:
        self.__ActiveDocument=None
    # Fire the Application inizialization
    self.startUpEvent(self)
</t>
<t tx="1.20130426141258.2481">@property
def getRecentFiles(self):
    """
        read from application settings the recent files
    """
    objSettings=self.getApplicationSetting()
    nFiles=objSettings.getVariable("MAX_RECENT_FILE")
    if nFiles:
        files=objSettings.getVariable("RECENT_FILE_ARRAY")
        if files:
            return files
        else:
            objSettings.setVariable("RECENT_FILE_ARRAY",[] )
            self.updateApplicationSetting(objSettings)
    else:
        objSettings.setVariable("MAX_RECENT_FILE",MAX_RECENT_FILE )
        objSettings.setVariable("RECENT_FILE_ARRAY",[] )
        self.updateApplicationSetting(objSettings)
    return []
</t>
<t tx="1.20130426141258.2482">def addRecentFiles(self,fPath):
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
\\-4.#                                                                   S-PM 110427
\\-4.#Method to add the given full file name on top of the "Open history list",
\\-4.#provided it is different from the one already present on top of the list.
\\-4.#
\\-4.#--Req-global
\\-4.#MAX_RECENT_FILE    local default max. history list length
\\-4.#
\\-4.#--Req
\\-4.#fPath   full file name to add to the list
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
    #--standard "Documentation String"
    """Add a new file name on top of the history list"""

    #--Register
    rgO=None    #Object
    rgN=None    #Integer
    rgL=None    #List

    #--Action
    rgO=self.getApplicationSetting()    #get current settings

    #--get and consider history list lenght parameter
    rgN=rgO.getVariable("MAX_RECENT_FILE")
    if (not rgN): rgN=0 #assure it's numeric
    if (rgN&lt;1):   #&lt;-force a local default value, if not given
        rgN=MAX_RECENT_FILE
        if (rgN&lt;1): rgN=1   #force anyhow at least a length=1
        rgO.setVariable("MAX_RECENT_FILE",rgN)
    #&gt;

    #--get and consider current history list
    rgL=rgO.getVariable("RECENT_FILE_ARRAY")
    if (not rgL):   #&lt;-assign an empty list, if not given
        rgL=[]
    #&gt;

    #--conditioned addition of the given full file name
    if (len(rgL)==0):       #&lt;-empty list:
        rgL.insert(0,fPath)      #add given file path
    elif (rgL[0]!=fPath):   #=-last recorded path is not the same:
        rgL.insert(0,fPath)      #add given file path
    #&gt;

    while(len(rgL)&gt;(rgN)):    #--chop the list to the desired length
        rgL.pop(-1)
    #&gt;

    rgO.setVariable("RECENT_FILE_ARRAY", rgL)   #--update current settings
    self.updateApplicationSetting(rgO)
</t>
<t tx="1.20130426141258.2483">#addRecentFiles&gt;


def getCommand(self,commandType):
    """
        Get a command of commandType
    """
    if not self.__ActiveDocument:
        raise EntityMissing("Miss Active document in the application")
    if commandType in self.__applicationCommand:
        cmd=self.__applicationCommand[commandType]
        cmdIstance=cmd(self.__ActiveDocument)
        return cmdIstance
    else:
        raise PyCadWrongCommand("")
</t>
<t tx="1.20130426141258.2484">def getCommandList(self):
    """
        get the list of all the command
    """
    return list(self.__applicationCommand.keys())
</t>
<t tx="1.20130426141258.2485">def newDocument(self, fileName=None):
    """
        Create a new document empty document in the application
    """
    newDoc=Document(fileName)
    fileName=newDoc.dbPath
    self.__Documents[fileName]=newDoc
    self.afterOpenDocumentEvent(self, self.__Documents[fileName])   #   Fire the open document event
    self.ActiveDocument=self.__Documents[fileName]      #   Set Active the document
    self.addRecentFiles(fileName)
    return self.__Documents[fileName]
</t>
<t tx="1.20130426141258.2486">def openDocument(self, fileName):
    """
        open a saved document
    """
    self.beforeOpenDocumentEvent(self, fileName)
    if fileName not in self.__Documents:
        self.__Documents[fileName]=Document(fileName)
        self.addRecentFiles(fileName)
    self.afterOpenDocumentEvent(self, self.__Documents[fileName])   #   Fire the open document event
    self.ActiveDocument=self.__Documents[fileName]                  #   Set Active the document
    return self.__Documents[fileName]

</t>
<t tx="1.20130426141258.2487">def saveAs(self, newFileName):
    """
        seve the current document to the new position
    """
    '''
    # for debug
    oldFileName=QtCore.QFileInfo(self.__ActiveDocument.getName()).fileName().replace("\\", "\\\\")
    print("newFileName:", newFileName)
    print()
    print("old FileName:", oldFileName)
    return ""
    '''
    if self.__ActiveDocument:
        (name, extension)=os.path.splitext(str(newFileName[0]))
        if extension.upper()=='.DXF':
            self.__ActiveDocument.exportExternalFormat(newFileName[0])
            return self.__ActiveDocument
        else:
            #oldFileName=QtCore.QFileInfo(self.__ActiveDocument.getName()).fileName().replace("\\", "\\\\")
            #print("oldFileName is:", oldFileName)
            #s = s.replace("\\", "\\\\")
            oldFileName = self.__ActiveDocument.getName()
            print("oldFileName is:", oldFileName)
            print("newFileName:", newFileName)
            # 讓檔案無法儲存的原因為無法 close oldFileName
            self.closeDocument(oldFileName)
            shutil.copy2(oldFileName, newFileName[0])
            return self.openDocument(newFileName[0])
    raise EntityMissing("No document open in the application unable to perform the saveAs comand")
</t>
<t tx="1.20130426141258.2488">def closeDocument(self, dFile):
#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
#                                                                   S-PM 110427
# Method to "Close" the named drawing file.
# --Rq-local
#  __Documents   dictionary of currently opened drawing files
#                (was misspelled: "__Docuemnts")
# --Rq
#  dFile         drawing file to close
# -- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=

#"Close current document"    #standard "Documentation String"

    self.beforeCloseDocumentEvent(self, dFile)   #initial house-keeping

    if dFile in self.__Documents: #&lt;-file to Close is there:
        self.__Documents[dFile].close()
        del(self.__Documents[dFile])    #delete from dictionary
        #--check dictionary for possible next active document
        for keyDoc in self.__Documents: #&lt;-dictionary is not empty:
            self.ActiveDocument = self.__Documents[keyDoc]    #pick next
            break
        else:   #=-dictionary is empty:
            self.ActiveDocument = None  #set no active document
        #&gt;
    else:   #=-file to Close is NOT there:
        raise IOError("Unable to close the file:  %s"%str(dFile))
    #&gt;

    self.afterCloseDocumentEvent(self)          #final house-keeping

</t>
<t tx="1.20130426141258.2489">#closeDocument&gt;


@property
def ActiveDocument(self):
    """
        get The active Document
    """
    return self.__ActiveDocument
</t>
<t tx="1.20130426141258.2490">@ActiveDocument.setter
def ActiveDocument(self, document):
    """
        Set the document to active
    """
    if document:
        if document.dbPath in self.__Documents:
            self.__ActiveDocument=self.__Documents[document.dbPath]
        else:
            raise EntityMissing("Unable to set active the document %s"%str(document.dbPath))
    else:
        self.__ActiveDocument=document
    self.activeteDocumentEvent(self, self.__ActiveDocument)
    print("document.dbPath is:", document.dbPath)
</t>
<t tx="1.20130426141258.2491">def getDocuments(self):
    """
        get the Docuemnts Collection
    """
    return self.__Documents
</t>
<t tx="1.20130426141258.2492">#
# manage application style
#
def getApplicationStyleList(self):
    """
        Get the application styles
    """
    return self.kernel.getDBStyles()
</t>
<t tx="1.20130426141258.2493">def getApplicationStyle(self, id=None, name=None):
    """
        retrive a style from the application
    """
    return self.kernel.getStyle(id, name)
</t>
<t tx="1.20130426141258.2494">def setApplicationStyle(self, style):
    """
        add style to the application
    """
    self.kernel.saveEntity(style)
</t>
<t tx="1.20130426141258.2495">def deleteApplicationStyle(self, styleID):
    """
        delete the application style
    """
    self.kernel.deleteEntity(styleID)
</t>
<t tx="1.20130426141258.2496">#
# Manage the application settings
#
def getApplicationSetting(self):
    """
        return the setting object from the application
    """
    return self.kernel.getDbSettingsObject()
</t>
<t tx="1.20130426141258.2497">def updateApplicationSetting(self, settingObj):
    """
        update the application settingObj
    """
    #apObj=self.kernel.getDbSettingsObject()
    #apObj.setConstructionElement(settingObj)
    self.kernel.saveEntity(settingObj)
</t>
<t tx="1.20130426141258.2498">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
from application import Application

a=Application()
print("stored file")
for f in a.getRecentFiles:
    print("File :", str(f))

print("available command")
for c in a.getCommandList():
    print("Command:", str(c))

TestSympy()
TestIntersection()

doc=a.openDocument(a.getRecentFiles[0])
a.saveAs(r"C:\tmp\test.dxf")
</t>
<t tx="1.20130426141258.2499">import sympy            as mainSympy
import sympy.geometry   as geoSympy

from Kernel.GeoEntity.point         import Point
from Kernel.GeoEntity.segment       import Segment
from Kernel.GeoEntity.arc           import Arc
from Kernel.GeoEntity.ellipse       import Ellipse
from Kernel.GeoEntity.cline         import CLine

from Kernel.GeoUtil.intersection    import *
</t>
<t tx="1.20130426141258.2500">def testSympySegment():
    print("++ Sympy Segment ++")
    p1=Point(0, 1)
    p2=Point(10, 20)
    arg={"SEGMENT_0":p1, "SEGMENT_1":p2}
    seg=Segment(arg)
    symSeg=seg.getSympy()
    print(symSeg)
    p3=Point(30, 40)
    arg1={"SEGMENT_0":p1, "SEGMENT_1":p3}
    seg1=Segment(arg1)
    seg1.setFromSympy(symSeg)
    print("Segment ", seg1)
    print("-- Sympy Segment --")
</t>
<t tx="1.20130426141258.2501">def testSympyCline():
    print("++ Sympy CLine ++")
    p1=Point(0, 1)
    p2=Point(10, 20)
    arg={"CLINE_0":p1, "CLINE_1":p2}
    seg=CLine(arg)
    symSeg=seg.getSympy()
    print(symSeg)
    p3=Point(30, 40)
    arg1={"CLINE_0":p1, "CLINE_1":p3}
    seg1=CLine(arg1)
    seg1.setFromSympy(symSeg)
    print("CLine ", seg1)
    print("-- Sympy CLine --")
</t>
<t tx="1.20130426141258.2502">def testSympyCircle():
    print("++ Sympy Arc ++")
    p1=Point(0, 1)
    arg={"ARC_0":p1, "ARC_1":5, "ARC_2":0, "ARC_3":6.2831}
    arc=Arc(arg)
    sympCircle=arc.getSympy()
    print("sympCircle", sympCircle)
    sympCircel=geoSympy.Circle(geoSympy.Point(10, 10), 10)
    arc.setFromSympy(sympCircel)
    print("Pythonca Arc ", arc)
    print("-- Sympy Arc --")
</t>
<t tx="1.20130426141258.2503">def testSympyEllipse():
    print("++ Sympy Ellipse ++")
    p1=Point(0, 1)
    arg={"ELLIPSE_0":p1, "ELLIPSE_1":100, "ELLIPSE_2":50}
    eli=Ellipse(arg)
    sympEli=eli.getSympy()
    print("sympEllipse", sympEli)
    sympEli1=geoSympy.Ellipse(geoSympy.Point(10, 10), 300, 200)
    eli.setFromSympy(sympEli1)
    print("Pythonca Ellipse ", eli)
    print("-- Sympy Ellipse --")
</t>
<t tx="1.20130426141258.2504">def TestSympy():
    testSympySegment()
    testSympyCline()
    testSympyCircle()
    testSympyEllipse()
</t>
<t tx="1.20130426141258.2505">#*****************************************************************
#Test Intersection
#*****************************************************************
def segment_segmet():
    print("++ segment_segmet ++")
    p1=Point(0,0)
    p2=Point(0, 1)
    arg={"SEGMENT_0":p1, "SEGMENT_1":p2}
    seg1=Segment(arg)
    p3=Point(0, 0)
    p4=Point(-1,0)
    arg={"SEGMENT_0":p3, "SEGMENT_1":p4}
    seg2=Segment(arg)

    print(find_intersections(seg1, seg2))
    print("-- segment_segmet --")
</t>
<t tx="1.20130426141258.2506">def segment_cline():
    print("++ segment_cline ++")
    p1=Point(0,0)
    p2=Point(0, 1)
    arg={"CLINE_0":p1, "CLINE_1":p2}
    seg1=CLine(arg)
    p3=Point(0, 0)
    p4=Point(-1,0)
    arg={"SEGMENT_0":p3, "SEGMENT_1":p4}
    seg2=Segment(arg)

    print(find_intersections(seg1, seg2))
    print("-- segment_cline --")
</t>
<t tx="1.20130426141258.2507">def segment_circle():
    print("++ segment_circle ++")
    p1=Point(0, 0)
    arg={"ARC_0":p1, "ARC_1":5, "ARC_2":0, "ARC_3":6.2831}
    arc=Arc(arg)
    p2=Point(0, 0)
    p3=Point(-1,0)
    arg={"CLINE_0":p2, "CLINE_1":p3}
    seg1=CLine(arg)
    print(find_intersections(arc, seg1))
    print("-- segment_circle --")
</t>
<t tx="1.20130426141258.2508">def segment_ellipse():
    print("++ segment_ellipse ++")
    p1=Point(0, 0)
    arg={"ELLIPSE_0":p1, "ELLIPSE_1":300, "ELLIPSE_2":100}
    eli=Ellipse(arg)
    p2=Point(0, 0)
    p3=Point(-1,0)
    arg={"CLINE_0":p2, "CLINE_1":p3}
    seg1=CLine(arg)
    print(find_intersections(eli, seg1))
    print("-- segment_ellipse --")
</t>
<t tx="1.20130426141258.2509">def TestIntersection():
    segment_segmet()
    segment_cline()
    segment_circle()
    segment_ellipse()
</t>
<t tx="1.20130426141258.2510">@first #!/usr/bin/env python
@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__=='__main__':
    ta=textApplication()
    #ta.getRandomPoint()
    #ta.mainLoop()
    ta.featureTest()
    #io=ioKernel()
    #io.mainLoop()
    print("bye")
</t>
<t tx="1.20130426141258.2577"></t>
<t tx="1.20130426141258.2578"></t>
<t tx="1.20130426141258.2579">@language python
@tabwidth -4
@others
if __name__=='__main__':    
    testBinaryTree()
</t>
<t tx="1.20130426141258.2580">class BinaryTree(object):
    """
        generic tree binary structure object
    """    
    @others
</t>
<t tx="1.20130426141258.2581">def __init__(self):             self.__tree=EmptyNode()
</t>
<t tx="1.20130426141258.2582">def __repr__(self):             return repr(self.__tree)
</t>
<t tx="1.20130426141258.2583">def lookUp(self, key):          return self.__tree.lookUp(key)
</t>
<t tx="1.20130426141258.2584">def insert(self, key, value):   self.__tree=self.__tree.insert(key, value)
</t>
<t tx="1.20130426141258.2585">class EmptyNode(object):
    """
        empty Node
    """
    @others
</t>
<t tx="1.20130426141258.2586">def __repr__(self):             return '*'
</t>
<t tx="1.20130426141258.2587">def lookUp(self, key):          return None
</t>
<t tx="1.20130426141258.2588">def insert(self, key, value):   return BinaryNode(self,key,  value, self)
</t>
<t tx="1.20130426141258.2589">class BinaryNode(object):
    """
        this class rappresent a binary node
    """
    @others
</t>
<t tx="1.20130426141258.2590">def __init__(self, left,key, value, right):
    self.key,  self.data  = key, value
    self.left, self.right = left, right
</t>
<t tx="1.20130426141258.2591">def lookUp(self, key):
    """
        look up at the value
    """
    if self.key==key:       return self.data
    elif self.key&gt;key:      return self.left.lookUp(key)
    else:                   return self.right.lookUp(key)
</t>
<t tx="1.20130426141258.2592">def insert(self,key,value):
    """
        insert a new value at the node
    """
    if      self.key==key:      self.data=value
    elif    self.key&gt;key:       self.left=self.left.insert(key, value)
    elif    self.key&lt;key:       self.right=self.right.insert(key,  value)
    return self
</t>
<t tx="1.20130426141258.2593">def __repr__(self): return '(%s,%s,%s,%s)'%(repr(self.left), repr(self.key),  repr(self.data), repr(self.right))
</t>
<t tx="1.20130426141258.2594">def testBinaryTree():
    x=BinaryTree()
    x.insert('root', "1")
    x.insert('layer_1', "3")
    x.insert('layer_2', "2")   
    print("--&gt;", x.lookUp('layer_1'))
    print("--&gt;%s"%str(x))
</t>
<t tx="1.20130426141258.2595">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic DB class for storing entity with relation in pythoncad
# entity such as Chamfer Fillet Blocks
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2596">from Kernel.Db.pycadobject      import *
from Kernel.GeoEntity.style            import Style
from Kernel.GeoEntity.point            import Point
</t>
<t tx="1.20130426141258.2597">class ComposedEntity(PyCadObject):
    """
        this class provide the besic functionality for storing entity that need a 
        sort of relation such Chamfer Fillet Blocks
    """
    @others
</t>
<t tx="1.20130426141258.2598">def __init__(self, objId,constructionElements, eType, style, childEnt=[] ):
    """
        Inizialize a composed entity
    """
    from Kernel.initsetting             import PY_CAD_COMPOSED_ENT 
    if not eType in PY_CAD_COMPOSED_ENT:
        raise TypeError('entType not supported')
    PyCadObject.__init__(self,eType=eType, objId=objId,style=style)
    self.setChildEnt(childEnt)
    self.setConstructionElement(constructionElements)
</t>
<t tx="1.20130426141258.2599">def getChildEnt(self):
    """
        return an array of cildren ents
    """
    return self.__childEnt
</t>
<t tx="1.20130426141258.2600">def setChildEnt(self, childEnt):
    """
        set all the child entitys
    """
    from Kernel.initsetting             import PY_CAD_ENT   
    for ent in childEnt:
        if not ent.eType in PY_CAD_ENT:
            raise TypeError('entType with id: %s not supported as child ent'%(str(ent.getId())))
    self.__childEnt=childEnt
</t>
<t tx="1.20130426141258.2601">def getConstructionElements(self):
    """
        Return the base entity
    """
    return self._constructionElements
</t>
<t tx="1.20130426141258.2602">def setConstructionElement(self, constructionElements):
    """
        set the construction elements for the object
    """
    if not isinstance(constructionElements,dict):
        raise TypeError('type error in dictionary')
    self._constructionElements=constructionElements
</t>
<t tx="1.20130426141258.2603">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module all the interface needed to talk with pythoncad database
#
#**************************************************System Import




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2604">import os
import sys
import pickle as pickle
import logging
import time


#***************************************************Kernel Import
from Kernel.pycadevent              import PyCadEvent
from Kernel.initsetting             import *
from Kernel.ExternalFormat.externalformat  import ExtFormat
from Kernel.ExternalFormat.Dxf.dxf  import Dxf
from Kernel.exception               import *
from Kernel.settings                import *
from Kernel.entity                  import Entity
from Kernel.composedentity          import ComposedEntity
from Kernel.layertree               import LayerTree
from Kernel.layer                   import Layer

#***************************************************Db Import
from Kernel.Db.undodb               import UndoDb
from Kernel.Db.entitydb             import EntityDb
from Kernel.Db.basedb               import BaseDb
from Kernel.Db.relationdb           import RelationDb


#****************************************************Entity Import
from Kernel.GeoEntity.geometricalentity       import GeometricalEntity, GeometricalEntityComposed
from Kernel.GeoEntity.point        import Point
from Kernel.GeoEntity.segment      import Segment
from Kernel.GeoEntity.arc          import Arc
from Kernel.GeoEntity.ellipse      import Ellipse
from Kernel.GeoEntity.polyline     import Polyline
from Kernel.GeoEntity.style        import Style
from Kernel.GeoEntity.entityutil   import *

#   Define the log
LEVELS = {'PyCad_Debug':    logging.DEBUG,
          'PyCad_Info':     logging.INFO,
          'PyCad_Warning':  logging.WARNING,
          'PyCad_Error':    logging.ERROR,
          'PyCad_Critical': logging.CRITICAL}
#   Set the debug level
level = LEVELS.get('PyCad_Warning', logging.NOTSET)
logging.basicConfig(level=level)
</t>
<t tx="1.20130426141258.2605">#
class Document(BaseDb):
    """
        This class provide basic operation on the pycad db database
        dbPath: is the path the database if None look in the some directory.
    """
    @others
</t>
<t tx="1.20130426141258.2606">def __init__(self,dbPath=None):
    """
        init of the kernel
    """
    self.__logger=logging.getLogger('DbKernel')
    self.__logger.debug('__init__')
    BaseDb.__init__(self)
    # set the events
    self.__logger.debug('set events')
    self.saveEntityEvent=PyCadEvent()
    self.deleteEntityEvent=PyCadEvent()
    self.massiveDeleteEvent=PyCadEvent()
    self.showEntEvent=PyCadEvent()
    self.hideEntEvent=PyCadEvent()
    self.updateShowEntEvent=PyCadEvent()
    self.undoRedoEvent=PyCadEvent()
    self.handledErrorEvent=PyCadEvent()
    #create Connection
    self.createConnection(dbPath)
    # inizialize extentionObject
    self.__UndoDb=UndoDb(self.getConnection())
    self.__EntityDb=EntityDb(self.getConnection())
    self.__RelationDb=RelationDb(self.getConnection())
    # Some inizialization parameter
    self.__bulkCommit=False
    self.__bulkUndoIndex=-1     # undo index are always positive so we do not brake in case missing entity id
    self.__entId=self.__EntityDb.getNewEntId()
    #   set the default style
    self.__logger.debug('Set Style')
    self.__activeStyleObj=None
    self.__activeStyleObj=self.getMainStyle()
    self.__settings=self.getDbSettingsObject()
    self.__property={}
    #************************
    #Inizialize Layer structure
    #************************
    self.__logger.debug('Inizialize layer structure')
    try:
        self.__LayerTree=LayerTree(self)
    except StructuralError:
        raise StructuralError('Unable to create LayerTree structure')
    self.__logger.debug('Done inizialization')
</t>
<t tx="1.20130426141258.2607">def addPropertie(self,name,value):
    """
        add a properties to the object
    """
    self.__property[name]=value
</t>
<t tx="1.20130426141258.2608">def getPropertie(self,name):
    """
        get the properties with a given name
    """
    if name in self.__property:
        return self.__property[name]
    raise EntityMissing("No entity with name %s"%str(name))
</t>
<t tx="1.20130426141258.2609">@property
def properties(self):
    """
        get all the properties from the entity
    """
    return self.__property
</t>
<t tx="1.20130426141258.2610">def getMainStyle(self):
    """
        get all the db styles
    """

    self.__logger.debug('getDbSettingsObject')
    styleEntitys=self.getEntityFromType('STYLE')
    for styleEntity in styleEntitys:
        styles=styleEntity.getConstructionElements()
        for stl in styles:
            if styles[stl].name=="Main":
                return styleEntity
                break
    else:
        style=Style({"STYLE_0":"Main"})
        return self.saveEntity(style)
</t>
<t tx="1.20130426141258.2611">def getDbSettingsObject(self):
    """
        get the pythoncad settings object
    """
    self.__logger.debug('getDbSettingsObject')
    _settingsObjs=self.getEntityFromType('SETTINGS')
    if len(_settingsObjs)&lt;=0:
        _settingsObjs=Settings('MAIN_SETTING')
        self.saveEntity(_settingsObjs)
    else:
        for sto in _settingsObjs:
            _setts=sto.getConstructionElements()
            for i in _setts:
                if _setts[i].name=='MAIN_SETTING':
                    _settingsObjs=_setts[i]
                    break
    return _settingsObjs
</t>
<t tx="1.20130426141258.2612">def startMassiveCreation(self):
    """
        suspend the undo for write operation
    """
    self.__logger.debug('startMassiveCreation')
    self.__bulkCommit=True
    self.__bulkUndoIndex=self.__UndoDb.getNewUndo()
</t>
<t tx="1.20130426141258.2613">def stopMassiveCreation(self):
    """
        Reactive the undo trace
    """
    self.__logger.debug('stopMassiveCreation')
    self.__bulkCommit=False
    self.__bulkUndoIndex=-1
    self.performCommit()
</t>
<t tx="1.20130426141258.2614">def getEntity(self,entId):
    """
        get the entity from a given id
    """
    self.__logger.debug('getEntity')
    return self.__EntityDb.getEntityEntityId(entId)
</t>
<t tx="1.20130426141258.2615">def getEntityFromType(self,entityType):
    """
        get all the entity from a specifie type
        imput :
        type as string "SEGMENT"
        type as list ["SEGMENT","ARC",...   ]
    """
    self.__logger.debug('getEntityFromType')
    if isinstance(entityType,list):
        return self.__EntityDb.getEntityFromTypeArray(entityType)
    else:
        return self.__EntityDb.getEntityFromType(entityType)
</t>
<t tx="1.20130426141258.2616">def getAllDrawingEntity(self):
    """
        get all drawing entity from the db
    """
    return self.__EntityDb.getEntityFromTypeArray([DRAWIN_ENTITY[key] for key in list(DRAWIN_ENTITY.keys())])
</t>
<t tx="1.20130426141258.2617">def getEntInDbTableFormat(self, visible=1, entityType='ALL', entityTypeArray=None):
    """
        return a db table of the entity
        visible:            1=show the visible entity 2= sho the hidden entity
        entityType:         Tipe of Entity that you are looking for "SEGMENT,ARC.."
        entityTypeArray:    an array of element in case we are lookin for all the ARC and SEGMENT
            ['ARC','SEGMENT]
        Remarks if entityTypeArray is not None entityType is ignored
    """
    return self.__EntityDb.getMultiFilteredEntity(visible,entityType , entityTypeArray)
</t>
<t tx="1.20130426141258.2618">def convertToGeometricalEntity(self, entity):
    """
        Convert an entity into a geometrical entity
    """
    return entity.toGeometricalEntity()
</t>
<t tx="1.20130426141258.2619">def haveDrawingEntitys(self):
    """
        check if the drawing have some data in it
    """
    return self.__EntityDb.haveDrwEntitys([DRAWIN_ENTITY[key] for key in list(DRAWIN_ENTITY.keys())])
</t>
<t tx="1.20130426141258.2620">def saveSympyEnt(self, sympyEnt):
    """
        save the sympy entity
    """
    ent=getEntityEntity(sympyEnt)
    self.saveEntity(ent)
</t>
<t tx="1.20130426141258.2621">def saveEntity(self,entity):
    """
        save the entity into the database
    """
    self.__logger.debug('saveEntity')
    if not isinstance(entity,SUPPORTED_ENTITYS):
        msg="SaveEntity : Type %s not supported from pythoncad kernel"%type(entity)
        self.__logger.warning(msg)
        raise (TypeError(msg))
    try:
        _obj=None
        #self.__UndoDb.suspendCommit()
        #self.__EntityDb.suspendCommit()
        #self.__RelationDb.suspendCommit()
        BaseDb.commit=False
        if isinstance(entity,GeometricalEntity):
            _obj=self._saveGeometricalEntity(entity)
        elif isinstance(entity,ComposedEntity):
            _obj=self._saveComposedEntity(entity)
        elif isinstance(entity,Layer):
            _obj=self._saveLayer(entity)
        elif isinstance(entity,Settings):
            _obj=self._saveSettings(entity)
        elif isinstance(entity,Entity): # This is used if case of update of the entity
            _obj=self._savePyCadEnt(entity)
        else:
            raise StructuralError("Entity %s not allowed to be Saved"%str(type(entity)))
        if not self.__bulkCommit:
            #self.__UndoDb.reactiveCommit()
            #self.__EntityDb.reactiveCommit()
            #self.__RelationDb.reactiveCommit()
            BaseDb.commit=True
            self.performCommit()
        return _obj
    except:
        msg="Unexpected error: %s "%str(sys.exc_info()[0])
        raise (StructuralError(msg))
</t>
<t tx="1.20130426141258.2622">def _saveComposedEntity(self, entity):
    """
        save all the geometrical entity composed
    """
    relComp=[]
    #Save the releted component
    for e in entity.getChildEnt():
        relComp.append(self.saveEntity(e))
    #save the composedEntity
    _cElements, entityType =self._getCelements(entity)
    _obj=self._saveDbEnt(entType=entityType,constructorElements=_cElements)
    #seve the relation layer compose ent
    self.__RelationDb.saveRelation(self.__LayerTree.getActiveLater(),_obj)
    #seve the relation composed ent ent
    for c in relComp:
        self.__RelationDb.saveRelation(_obj,c)
    return _obj
</t>
<t tx="1.20130426141258.2623">def _saveGeometricalEntity(self, entity):
    """
        save all the geometrical entity
    """
    if isinstance(entity,Style):
        _obj=self._saveStyle(entity)
    elif isinstance(entity,Entity):
        _obj=self._savePyCadEnt(entity)
    else:
        _obj=self._saveDrwEnt(entity)
    return _obj
</t>
<t tx="1.20130426141258.2624">def _saveDrwEnt(self,entity):
    """
        Save a PythonCad drawing entity
    """
    self.__logger.debug('_saveDrwEnt')

    self.__entId+=1
    _cElements, entityType=self._getCelements(entity)
    _obj=self._saveDbEnt(entityType,_cElements)
    self.__RelationDb.saveRelation(self.__LayerTree.getActiveLater(),_obj)
    return _obj
</t>
<t tx="1.20130426141258.2625">def getNewId(self):
    """
        get a new id
    """
    self.__entId+=1
    return self.__entId
</t>
<t tx="1.20130426141258.2626">def _getCelements(self, entity):
    """
        get an array of construction elements
        entity must be a DRAWIN_ENTITY
    """
    for t in DRAWIN_ENTITY :
        if isinstance(entity, t):
            entityType=DRAWIN_ENTITY[t]
            break
    return entity.getConstructionElements(), entityType
</t>
<t tx="1.20130426141258.2627">def _saveSettings(self,settingsObj):
    """
        save the settings object
    """
    self.__logger.debug('_saveSettings')
    self.__entId+=1
    _cElements={}
    _cElements['SETTINGS']=settingsObj
    return self._saveDbEnt('SETTINGS',_cElements)
</t>
<t tx="1.20130426141258.2628">def _saveStyle(self, styleObject):
    """
        save the style object
    """
    self.__logger.debug('_saveStyle')
    self.__entId+=1
    _cElements={}
    _cElements['STYLE']=styleObject
    #-1 is for all the entity style that do not have style :-)
    _newDbEnt=Entity('STYLE',_cElements,None,self.__entId)
    self.__EntityDb.saveEntity(_newDbEnt,self.__UndoDb.getNewUndo())
    self.saveEntityEvent(self,_newDbEnt)
    self.showEntEvent(self,_newDbEnt)
    return _newDbEnt
</t>
<t tx="1.20130426141258.2629">def _saveLayer(self,layerObj):
    """
        save the layer object
    """
    self.__logger.debug('_saveLayer')
    self.__entId+=1
    _cElements={}
    _cElements['LAYER']=layerObj
    return self._saveDbEnt('LAYER',_cElements)
</t>
<t tx="1.20130426141258.2630">def _savePyCadEnt(self, entity):
    """
        save the entity in the database
    """
    return self._saveDbEnt(entity=entity)
</t>
<t tx="1.20130426141258.2631">def _saveDbEnt(self,entType=None,constructorElements=None, entity=None):
    """
        save the DbEnt to db
    """
    self.__logger.debug('_saveDbEnt')
    updateEvent=False
    if entity==None:
        _newDbEnt=Entity(entType,constructorElements,self.__activeStyleObj,self.__entId)
    else:
        if self.entityExsist(entity.getId()):
            updateEvent=True
        _newDbEnt=entity
    if self.__bulkUndoIndex&gt;=0:
        self.__EntityDb.saveEntity(_newDbEnt,self.__bulkUndoIndex)
    else:
        self.__EntityDb.saveEntity(_newDbEnt,self.__UndoDb.getNewUndo())
    self.saveEntityEvent(self,_newDbEnt)
    if updateEvent:
        self.updateShowEntEvent(self,_newDbEnt)
    else:
        self.showEntEvent(self,_newDbEnt)
    return _newDbEnt
</t>
<t tx="1.20130426141258.2632">def entityExsist(self, id):
    """
        check id the entity exsist in the database
    """
    return self.__EntityDb.exsisting(id)
</t>
<t tx="1.20130426141258.2633">def getStyle(self, id=None, name=None):
    """
        get the style object
    """
    self.__logger.debug('getStyle')
    _styleObjs=self.getStyleList()
    if id!=None:
        for sto in _styleObjs:
            if sto.getId()==id:
                return sto
    else:
        for sto in _styleObjs:
            _styleObj=sto.getConstructionElements()
            stlName=_styleObj[list(_styleObj.keys())[0]].getName()
            if stlName==name:
               return sto
    raise EntityMissing("Miss entity style in db id: &lt;%s&gt; name : &lt;%s&gt;"%(str(id), str(name)))
</t>
<t tx="1.20130426141258.2634">def getActiveStyle(self):
    """
        Get the current style
    """
    self.__logger.debug('getActiveStyle')
    if self.__activeStyleObj==None:

        self.setActiveStyle(0) # In this case get the first style

    return self.__activeStyleObj
</t>
<t tx="1.20130426141258.2635">def setActiveStyle(self, id=None, name=None):
    """
        set the current style
    """
    self.__logger.debug('setActiveStyle')
    if id==None and name==None:
        raise EntityMissing("Unable to retive the Style object")
    styleObject=self.getStyle(id, name)
    if styleObject==None:
        raise EntityMissing("Unable to retive the Style object")
    self.__activeStyleObj=styleObject
</t>
<t tx="1.20130426141258.2636">def getStyleList(self):
    """
        get all the style from the db
    """
    self.__logger.debug('getStyleList')
    return self.getEntityFromType('STYLE')
</t>
<t tx="1.20130426141258.2637">activeStyle=property(getActiveStyle,setActiveStyle)

def unDo(self):
    """
        perform an undo operation
    """
    self.__logger.debug('unDo')
    try:
        self.__EntityDb.markUndoVisibility(self.__UndoDb.getActiveUndoId(),0)
        _newUndo=self.__UndoDb.dbUndo()
        self.__EntityDb.performCommit()
        self.undoRedoEvent(self, None)
    except UndoDb:
        raise UndoDb("Generical problem to perform undo")
</t>
<t tx="1.20130426141258.2638">def reDo(self):
    """
        perform a redo operation
    """
    self.__logger.debug('reDo')
    try:
        _activeRedo=self.__UndoDb.dbRedo()
        self.__EntityDb.markUndoVisibility(_activeRedo, 1)
        self.__EntityDb.performCommit()
        self.undoRedoEvent(self, None)
    except UndoDb:
        raise UndoDb("Generical problem to perform reDo")
</t>
<t tx="1.20130426141258.2639">def clearUnDoHistory(self):
    """
        perform a clear history operation
    """
    self.__logger.debug('clearUnDoHistory')
    #:TODO

    #self.__UndoDb.clearUndoTable()
    #compact all the entity
    #self.__EntityDb.compactByUndo()
</t>
<t tx="1.20130426141258.2640">def release(self):
    """
        release the current drawing
    """
    try:
        # For Best Performance
        self.startMassiveCreation()
        # Clear the undo table
        self.__UndoDb.clearUndoTable()
        # Relese all the entity
        goodEntity=self.__EntityDb.getEntityFromType('ALL')
        for entity in goodEntity:
            entity.relese()
            self.saveEntity(entity)
        # Clear the old entity
        self.__EntityDb.clearEnt()
        # Increse the revision index
        self.__EntityDb.increaseRevisionIndex()
        # Commit all the change
        self.performCommit()
    except:
        self.__EntityDb.decreseRevisionIndex()
        print("Unable to perform the release operation")
    finally:
        self.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2641">def deleteEntity(self,entityId):
    """
        Delete the entity from the database
    """
    self.__logger.debug('deleteEntity')
    entity=self.__EntityDb.getEntityEntityId(entityId)
    entity.delete()
    self.saveEntity(entity)
    self.deleteEntityEvent(self,entity)
</t>
<t tx="1.20130426141258.2642">def massiveDelete(self, entityIds):
    """
        perform a massive delete more then one entity
    """
    self.__logger.debug('massiveDelete')
    _delEnity=[]
    try:
        self.startMassiveCreation()
        for entityId in entityIds:
            entity=self.__EntityDb.getEntityEntityId(entityId)
            entity.delete()
            self.saveEntity(entity)
            _delEnity.append(entity)
        else:
            self.performCommit()
    finally:
        self.massiveDeleteEvent(self, _delEnity)
        self.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2643">def hideEntity(self, entity=None, entityId=None):
    """
        Hide an entity
    """
    self._hide(entity, entityId, 0)
    self.hideEntEvent(self, entity) # Event
</t>
<t tx="1.20130426141258.2644">def unHideEntity(self, entity=None, entityId=None):
    """
        Unhide an entity
    """
    self._hide(entity, entityId, 1)
    self.showEntEvent(self, entity) #Event
</t>
<t tx="1.20130426141258.2645">def _hide(self,entity=None, entityId=None,  visible=0):
    """
        make the hide/unhide of an entity
    """
    if entity is None and entityId is None:
        raise EntityMissing("All function attribut are null")
    activeEnt=None
    if entity != None:
        activeEnt=self.__EntityDb.getEntityEntityId(entity.getId())
    if activeEnt == None and entityId is not None:
        activeEnt=self.__EntityDb.getEntityEntityId(entityId)
    if activeEnt.visible!=visible:
        activeEnt.visible=visible
        self.saveEntity(activeEnt)
</t>
<t tx="1.20130426141258.2646">def importExternalFormat(self, fileName):
    """
        This method allow you to import a file from an external format
    """
    try:
        extFormat=ExtFormat(self)
        extFormat.openFile(fileName)
    except DxfReport:
        self.__logger.error('DxfReport')
        _err={'object':extFormat, 'error':DxfReport}
        self.handledErrorEvent(_err)
    except DxfUnsupportedFormat:
        self.__logger.error('UnsupportedFormat')
        _err={'object':extFormat, 'error':DxfUnsupportedFormat}
        self.handledErrorEvent(_err)
</t>
<t tx="1.20130426141258.2647">def exportExternalFormat(self, fileName):
    """
        This method allow you to export a file to an external format\
    """
    try:
        extFormat=ExtFormat(self)
        extFormat.saveFile(fileName)
    except DxfReport:
        self.__logger.error('DxfReport')
        _err={'object':extFormat, 'error':DxfReport}
        self.handledErrorEvent(self,_err)#todo : test it not sure it works
    except DxfUnsupportedFormat:
        self.__logger.error('UnsupportedFormat')
        _err={'object':extFormat, 'error':DxfUnsupportedFormat}
        self.handledErrorEvent(self,_err)#todo : test it not sure it works
</t>
<t tx="1.20130426141258.2648">@property
def getTreeLayer(self):
    """
        Retrive the layer tree object
    """
    return self.__LayerTree
</t>
<t tx="1.20130426141258.2649">def getAllChildrenType(self, parentObject, childrenType):
    """
        Get all the entity children from an pyCadDb object
    """
    return self.__RelationDb.getAllChildrenType(parentObject, childrenType)
</t>
<t tx="1.20130426141258.2650">def getRelatioObject(self):
    """
        getRelationObject
    """
    return self.__RelationDb
</t>
<t tx="1.20130426141258.2651">def getName(self):
    """
        get the name of the active document
    """
    return self.dbPath
</t>
<t tx="1.20130426141258.2652">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic DB class for storing entity in pythoncad
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2653">from Kernel.Db.pycadobject             import *
from Kernel.GeoEntity.point            import Point
from Kernel.GeoEntity.style            import Style
</t>
<t tx="1.20130426141258.2654">class Entity(PyCadObject):
    """
        basic PythonCAD entity structure
    """
    @others
</t>
<t tx="1.20130426141258.2655">def __init__(self,entType,constructionElements,style,objId):
    from Kernel.initsetting             import PY_CAD_ENT
    if not entType in PY_CAD_ENT:
        raise TypeError('entType not supported')
    if not isinstance(constructionElements,dict):
        raise TypeError('type error in dictionary')
    PyCadObject.__init__(self,eType=entType, objId=objId,style=style)
    self.setConstructionElements(constructionElements)
    
    self._snapPoints=[]
</t>
<t tx="1.20130426141258.2656">def __str__(self):
    return 'Entity : %s'%self.eType
</t>
<t tx="1.20130426141258.2657">def getBBox(self):
    """
        get the bounding Box Of the entity
    """
    return self.__bBox
</t>
<t tx="1.20130426141258.2658">def updateBBox(self):
    """
        update the bounding box from the construction elements
    """
    # Todo : Find a better way to create the bounding box for all
    # the geometrical entity may be is better that all the geometrical
    # entity have an implementatio of the bounding box
    self.__bBox=(0,0,0,0)
    return
    _xList=[]
    _yList=[]
    for key in self._constructionElements:
        if isinstance(self._constructionElements[key],Point):
            x,y=self._constructionElements[key].getCoords()
            _xList.append(x)
            _yList.append(y)
    _xList.sort()
    _yList.sort()
    if len(_xList)&gt;0:
        if len(_xList)==1:
            _yList=_xList
        self.__bBox=(_xList[0],_yList[0],_xList[-1],_yList[-1])
    else:
        self.__bBox=(0,0,0,0)
</t>
<t tx="1.20130426141258.2659">def getConstructionElements(self):
    """
        return the base entity array
    """
    return self._constructionElements
</t>
<t tx="1.20130426141258.2660">def setConstructionElements(self, constructionElements):
    """
        set the construction elements for the object
    """
    self._constructionElements=constructionElements
    self.updateBBox()
</t>
<t tx="1.20130426141258.2661">def toGeometricalEntity(self):
    """
        Convert an entity into a geometrical entity
    """ 
    from Kernel.initsetting             import DRAWIN_ENTITY
    geoEnt=None
    cObjecs=self.getConstructionElements()
    cType=self.getEntityType()
    for key in DRAWIN_ENTITY:
        if DRAWIN_ENTITY[key]==cType:
            if cType =="POINT":
                geoEnt=Point(cObjecs["POINT_0"], cObjecs["POINT_1"])
            else:
                geoEnt=key(cObjecs)
            break
    return geoEnt
</t>
<t tx="1.20130426141258.2662">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module Provide custom exception for the db module and kernel
#




@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.2663">class EntityMissing(Exception):
    """
        Wrong entity provided
    """
    @others
</t>
<t tx="1.20130426141258.2664">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2665">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2666">class NoDefaultValue(Exception):
    """
        no default value provided by the command
    """
    @others
</t>
<t tx="1.20130426141258.2667">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2668">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2669">class NotImplementedError(Exception):
    """
        Thi means that the followeing method is not yet implemented
    """
    @others
</t>
<t tx="1.20130426141258.2670">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2671">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2672">class DeprecatedError(Exception):
    """
        This means that the followeing method is no longer supported
    """
    @others
</t>
<t tx="1.20130426141258.2673">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2674">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2675">class StructuralError(Exception):
    """
        Very bad error that menans that the kernel has made somthing very bad
    """
    @others
</t>
<t tx="1.20130426141258.2676">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2677">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2678">class EmptyFile(Exception):
    """
        class for managin empty file
    """
    @others
</t>
<t tx="1.20130426141258.2679">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2680">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2681">class StyleUndefinedAttribute(Exception):
    """
        Class for managing styleAttribute problems
    """
    @others
</t>
<t tx="1.20130426141258.2682">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2683">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2684">class PythonCadWarning(Exception):
    """
        Class for raise a warning exception
    """
    @others
</t>
<t tx="1.20130426141258.2685">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2686">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2687">class EmptyDbSelect(Exception):
    """
        This exception is used for null return of
        db select
    """
    @others
</t>
<t tx="1.20130426141258.2688">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2689">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2690">class EntityMissing(Exception):
    """
        This exception is used for null return of
        entity search
    """
    @others
</t>
<t tx="1.20130426141258.2691">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2692">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2693">class UndoDbExc(Exception):
    """
        This exception is used UndoDb class to manage is errors
    """
    @others
</t>
<t tx="1.20130426141258.2694">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2695">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2696">class EntDb(Exception):
    """
        Generic error on entity db creatioin
    """
    @others
</t>
<t tx="1.20130426141258.2697">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2698">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2699">class DxfReport(Exception):
    """
        error to say that the report of dxf is ready to be visualized
    """
    @others
</t>
<t tx="1.20130426141258.2700">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2701">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2702">class DxfUnsupportedFormat(Exception):
    """
        Unsupported format
    """
    @others
</t>
<t tx="1.20130426141258.2703">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2704">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2705">#********************************
#       command exception
#********************************
class PyCadWrongCommand(Exception):
    """
        Wrong command for the PyCadApplication
    """
    @others
</t>
<t tx="1.20130426141258.2706">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2707">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2708">class PyCadWrongImputData(Exception):
    """
        Wrong command for the PyCadApplication
    """
    @others
</t>
<t tx="1.20130426141258.2709">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2710">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2711">#********************************
#       imput command exception
#********************************
class CommandException(Exception):
    @others
</t>
<t tx="1.20130426141258.2712">def __init__(self, value):
    self.value = value
</t>
<t tx="1.20130426141258.2713">def __str__(self):
    return repr(self.value)
</t>
<t tx="1.20130426141258.2714">class ExcPoint(CommandException):
    """
        when this exception is trown it means that the command need a point
    """
    pass
</t>
<t tx="1.20130426141258.2715">class ExcLenght(CommandException):
    """
        when this exception is thrown it means that the command need a lenght
    """
    pass
</t>
<t tx="1.20130426141258.2716">class ExcAngle(CommandException):
    """
        when this exception is thrown it means that the command need a deg angle
    """
    pass
</t>
<t tx="1.20130426141258.2717">class ExcText(CommandException):
    """
        when this exception is thrown it means that the command need text
    """
    pass
</t>
<t tx="1.20130426141258.2718">class ExcInt(CommandException):
    """
        when this exception is thrown it means that the command need an Integer
    """
    pass
</t>
<t tx="1.20130426141258.2719">class ExcBool(CommandException):
    """
        when this exception is thrown it means that the command need n Boolean
    """
    pass
</t>
<t tx="1.20130426141258.2720">class ExcEntity(CommandException):
    """
        when this exception is thrown it means that the command need n dbEnity
    """
    pass
</t>
<t tx="1.20130426141258.2721">class ExcMultiEntity(CommandException):
    """
        when this exception is thrown it means that the command need an array of id
    """
    pass
</t>
<t tx="1.20130426141258.2722">class ExcEntityPoint(CommandException):
    """
        when this exception is thrown it means that the command need an a string
        like id@x,y
    """
    pass
</t>
<t tx="1.20130426141258.2723">class ExcDicTuple(CommandException):
    """
        require a dictionary of tuple
    """
    pass
</t>
<t tx="1.20130426141258.2724">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module provide all the global variable to be used from the pythoncad Application
#
#
# Command List
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
#
# Snap init settings
#
global SNAP_POINT_ARRAY
global ACTIVE_SNAP_POINT

SNAP_POINT_ARRAY={'LIST':0,
                    'END':1,
                    'MID':2,
                    'ORTHO':3,
                    'TANGENT':4,
                    'CENTER':5,
                    'QUADRANT':6,
                    'ORIG':7,
                    'INTERSECTION':8,
                    'NONE':9
                    }

ACTIVE_SNAP_POINT=SNAP_POINT_ARRAY["LIST"]

ACTIVE_SNAP_LIST=[SNAP_POINT_ARRAY["END"],
                  SNAP_POINT_ARRAY["MID"],
                  SNAP_POINT_ARRAY["ORTHO"],
                  SNAP_POINT_ARRAY["QUADRANT"],
                  SNAP_POINT_ARRAY["INTERSECTION"]
                  ]

#
# Color table to define a match from Autocad external format and Pythoncad internal format
#
cgcol = {
'#000000':0, 0:'#000000',
'#ff0000':1, 1:'#ff0000',
'#ffff00':2, 2:'#ffff00',
'#00ff00':3, 3:'#00ff00',
'#00ffff':4, 4:'#00ffff',
'#0000ff':5, 5:'#0000ff',
'#ff00ff':6, 6:'#ff00ff',
'#ffffff':7, 7:'#ffffff',
'#414141':8, 8:'#414141',
'#808080':9, 9:'#808080',
'#ff0000':10, 10:'#ff0000',
'#ffaaaa':11, 11:'#ffaaaa',
'#bd0000':12, 12:'#bd0000',
'#bd7e7e':13, 13:'#bd7e7e',
'#810000':14, 14:'#810000',
'#815656':15, 15:'#815656',
'#680000':16, 16:'#680000',
'#684545':17, 17:'#684545',
'#4f0000':18, 18:'#4f0000',
'#4f3535':19, 19:'#4f3535',
'#ff3f00':20, 20:'#ff3f00',
'#ffbfaa':21, 21:'#ffbfaa',
'#bd2e00':22, 22:'#bd2e00',
'#bd8d7e':23, 23:'#bd8d7e',
'#811f00':24, 24:'#811f00',
'#816056':25, 25:'#816056',
'#681900':26, 26:'#681900',
'#684e45':27, 27:'#684e45',
'#4f1300':28, 28:'#4f1300',
'#4f3b35':29, 29:'#4f3b35',
'#ff7f00':30, 30:'#ff7f00',
'#ffd4aa':31, 31:'#ffd4aa',
'#bd5e00':32, 32:'#bd5e00',
'#bd9d7e':33, 33:'#bd9d7e',
'#814000':34, 34:'#814000',
'#816b56':35, 35:'#816b56',
'#683400':36, 36:'#683400',
'#685645':37, 37:'#685645',
'#4f2700':38, 38:'#4f2700',
'#4f4235':39, 39:'#4f4235',
'#ffbf00':40, 40:'#ffbf00',
'#ffeaaa':41, 41:'#ffeaaa',
'#bd8d00':42, 42:'#bd8d00',
'#bdad7e':43, 43:'#bdad7e',
'#816000':44, 44:'#816000',
'#817656':45, 45:'#817656',
'#684e00':46, 46:'#684e00',
'#685f45':47, 47:'#685f45',
'#4f3b00':48, 48:'#4f3b00',
'#4f4935':49, 49:'#4f4935',
'#ffff00':50, 50:'#ffff00',
'#ffffaa':51, 51:'#ffffaa',
'#bdbd00':52, 52:'#bdbd00',
'#bdbd7e':53, 53:'#bdbd7e',
'#818100':54, 54:'#818100',
'#818156':55, 55:'#818156',
'#686800':56, 56:'#686800',
'#686845':57, 57:'#686845',
'#4f4f00':58, 58:'#4f4f00',
'#4f4f35':59, 59:'#4f4f35',
'#bfff00':60, 60:'#bfff00',
'#eaffaa':61, 61:'#eaffaa',
'#8dbd00':62, 62:'#8dbd00',
'#adbd7e':63, 63:'#adbd7e',
'#608100':64, 64:'#608100',
'#768156':65, 65:'#768156',
'#4e6800':66, 66:'#4e6800',
'#5f6845':67, 67:'#5f6845',
'#3b4f00':68, 68:'#3b4f00',
'#494f35':69, 69:'#494f35',
'#7fff00':70, 70:'#7fff00',
'#d4ffaa':71, 71:'#d4ffaa',
'#5ebd00':72, 72:'#5ebd00',
'#9dbd7e':73, 73:'#9dbd7e',
'#408100':74, 74:'#408100',
'#6b8156':75, 75:'#6b8156',
'#346800':76, 76:'#346800',
'#566845':77, 77:'#566845',
'#274f00':78, 78:'#274f00',
'#424f35':79, 79:'#424f35',
'#3fff00':80, 80:'#3fff00',
'#bfffaa':81, 81:'#bfffaa',
'#2ebd00':82, 82:'#2ebd00',
'#8dbd7e':83, 83:'#8dbd7e',
'#1f8100':84, 84:'#1f8100',
'#608156':85, 85:'#608156',
'#196800':86, 86:'#196800',
'#4e6845':87, 87:'#4e6845',
'#134f00':88, 88:'#134f00',
'#3b4f35':89, 89:'#3b4f35',
'#00ff00':90, 90:'#00ff00',
'#aaffaa':91, 91:'#aaffaa',
'#00bd00':92, 92:'#00bd00',
'#7ebd7e':93, 93:'#7ebd7e',
'#008100':94, 94:'#008100',
'#568156':95, 95:'#568156',
'#006800':96, 96:'#006800',
'#456845':97, 97:'#456845',
'#004f00':98, 98:'#004f00',
'#354f35':99, 99:'#354f35',
'#00ff3f':100, 100:'#00ff3f',
'#aaffbf':101, 101:'#aaffbf',
'#00bd2e':102, 102:'#00bd2e',
'#7ebd8d':103, 103:'#7ebd8d',
'#00811f':104, 104:'#00811f',
'#568160':105, 105:'#568160',
'#006819':106, 106:'#006819',
'#45684e':107, 107:'#45684e',
'#004f13':108, 108:'#004f13',
'#354f3b':109, 109:'#354f3b',
'#00ff7f':110, 110:'#00ff7f',
'#aaffd4':111, 111:'#aaffd4',
'#00bd5e':112, 112:'#00bd5e',
'#7ebd9d':113, 113:'#7ebd9d',
'#008140':114, 114:'#008140',
'#56816b':115, 115:'#56816b',
'#006834':116, 116:'#006834',
'#456856':117, 117:'#456856',
'#004f27':118, 118:'#004f27',
'#354f42':119, 119:'#354f42',
'#00ffbf':120, 120:'#00ffbf',
'#aaffea':121, 121:'#aaffea',
'#00bd8d':122, 122:'#00bd8d',
'#7ebdad':123, 123:'#7ebdad',
'#008160':124, 124:'#008160',
'#568176':125, 125:'#568176',
'#00684e':126, 126:'#00684e',
'#45685f':127, 127:'#45685f',
'#004f3b':128, 128:'#004f3b',
'#354f49':129, 129:'#354f49',
'#00ffff':130, 130:'#00ffff',
'#aaffff':131, 131:'#aaffff',
'#00bdbd':132, 132:'#00bdbd',
'#7ebdbd':133, 133:'#7ebdbd',
'#008181':134, 134:'#008181',
'#568181':135, 135:'#568181',
'#006868':136, 136:'#006868',
'#456868':137, 137:'#456868',
'#004f4f':138, 138:'#004f4f',
'#354f4f':139, 139:'#354f4f',
'#00bfff':140, 140:'#00bfff',
'#aaeaff':141, 141:'#aaeaff',
'#008dbd':142, 142:'#008dbd',
'#7eadbd':143, 143:'#7eadbd',
'#006081':144, 144:'#006081',
'#567681':145, 145:'#567681',
'#004e68':146, 146:'#004e68',
'#455f68':147, 147:'#455f68',
'#003b4f':148, 148:'#003b4f',
'#35494f':149, 149:'#35494f',
'#007fff':150, 150:'#007fff',
'#aad4ff':151, 151:'#aad4ff',
'#005ebd':152, 152:'#005ebd',
'#7e9dbd':153, 153:'#7e9dbd',
'#004081':154, 154:'#004081',
'#566b81':155, 155:'#566b81',
'#003468':156, 156:'#003468',
'#455668':157, 157:'#455668',
'#00274f':158, 158:'#00274f',
'#35424f':159, 159:'#35424f',
'#003fff':160, 160:'#003fff',
'#aabfff':161, 161:'#aabfff',
'#002ebd':162, 162:'#002ebd',
'#7e8dbd':163, 163:'#7e8dbd',
'#001f81':164, 164:'#001f81',
'#566081':165, 165:'#566081',
'#001968':166, 166:'#001968',
'#454e68':167, 167:'#454e68',
'#00134f':168, 168:'#00134f',
'#353b4f':169, 169:'#353b4f',
'#0000ff':170, 170:'#0000ff',
'#aaaaff':171, 171:'#aaaaff',
'#0000bd':172, 172:'#0000bd',
'#7e7ebd':173, 173:'#7e7ebd',
'#000081':174, 174:'#000081',
'#565681':175, 175:'#565681',
'#000068':176, 176:'#000068',
'#454568':177, 177:'#454568',
'#00004f':178, 178:'#00004f',
'#35354f':179, 179:'#35354f',
'#3f00ff':180, 180:'#3f00ff',
'#bfaaff':181, 181:'#bfaaff',
'#2e00bd':182, 182:'#2e00bd',
'#8d7ebd':183, 183:'#8d7ebd',
'#1f0081':184, 184:'#1f0081',
'#605681':185, 185:'#605681',
'#190068':186, 186:'#190068',
'#4e4568':187, 187:'#4e4568',
'#13004f':188, 188:'#13004f',
'#3b354f':189, 189:'#3b354f',
'#7f00ff':190, 190:'#7f00ff',
'#d4aaff':191, 191:'#d4aaff',
'#5e00bd':192, 192:'#5e00bd',
'#9d7ebd':193, 193:'#9d7ebd',
'#400081':194, 194:'#400081',
'#6b5681':195, 195:'#6b5681',
'#340068':196, 196:'#340068',
'#564568':197, 197:'#564568',
'#27004f':198, 198:'#27004f',
'#42354f':199, 199:'#42354f',
'#bf00ff':200, 200:'#bf00ff',
'#eaaaff':201, 201:'#eaaaff',
'#8d00bd':202, 202:'#8d00bd',
'#ad7ebd':203, 203:'#ad7ebd',
'#600081':204, 204:'#600081',
'#765681':205, 205:'#765681',
'#4e0068':206, 206:'#4e0068',
'#5f4568':207, 207:'#5f4568',
'#3b004f':208, 208:'#3b004f',
'#49354f':209, 209:'#49354f',
'#ff00ff':210, 210:'#ff00ff',
'#ffaaff':211, 211:'#ffaaff',
'#bd00bd':212, 212:'#bd00bd',
'#bd7ebd':213, 213:'#bd7ebd',
'#810081':214, 214:'#810081',
'#815681':215, 215:'#815681',
'#680068':216, 216:'#680068',
'#684568':217, 217:'#684568',
'#4f004f':218, 218:'#4f004f',
'#4f354f':219, 219:'#4f354f',
'#ff00bf':220, 220:'#ff00bf',
'#ffaaea':221, 221:'#ffaaea',
'#bd008d':222, 222:'#bd008d',
'#bd7ead':223, 223:'#bd7ead',
'#810060':224, 224:'#810060',
'#815676':225, 225:'#815676',
'#68004e':226, 226:'#68004e',
'#68455f':227, 227:'#68455f',
'#4f003b':228, 228:'#4f003b',
'#4f3549':229, 229:'#4f3549',
'#ff007f':230, 230:'#ff007f',
'#ffaad4':231, 231:'#ffaad4',
'#bd005e':232, 232:'#bd005e',
'#bd7e9d':233, 233:'#bd7e9d',
'#810040':234, 234:'#810040',
'#81566b':235, 235:'#81566b',
'#680034':236, 236:'#680034',
'#684556':237, 237:'#684556',
'#4f0027':238, 238:'#4f0027',
'#4f3542':239, 239:'#4f3542',
'#ff003f':240, 240:'#ff003f',
'#ffaabf':241, 241:'#ffaabf',
'#bd002e':242, 242:'#bd002e',
'#bd7e8d':243, 243:'#bd7e8d',
'#81001f':244, 244:'#81001f',
'#815660':245, 245:'#815660',
'#680019':246, 246:'#680019',
'#68454e':247, 247:'#68454e',
'#4f0013':248, 248:'#4f0013',
'#4f353b':249, 249:'#4f353b',
'#333333':250, 250:'#333333',
'#505050':251, 251:'#505050',
'#696969':252, 252:'#696969',
'#828282':253, 253:'#828282',
'#bebebe':254, 254:'#bebebe',
'#ffffff':255, 255:'#ffffff',
}
#descripe the text position refered to the point clicked
TEXT_POSITION=['n','ne', 'e', 'se', 's', 'sw', 'w','nw', 'c']
MOUSE_GRAPH_DIMENSION=6
</t>
<t tx="1.20130426141258.2725">from Kernel.Command                     import *
from Kernel.Command.segmentcommand      import SegmentCommand
from Kernel.Command.circlecommand       import CircleCommand
from Kernel.Command.arccommand          import ArcCommand
from Kernel.Command.pointcommand        import PointCommand
from Kernel.Command.ellipsecommand      import EllipseCommand
from Kernel.Command.polylinecommand     import PolylineCommand
#from Kernel.Command.aclinecommand       import ACLineCommand
from Kernel.Command.ccirclecommand      import CCircleCommand
from Kernel.Command.textcommand         import TextCommand
from Kernel.Command.chamfercommand      import ChamferCommand
from Kernel.Command.filletcommand       import FilletCommand
from Kernel.Command.bisectorcommand     import BisectorCommand
from Kernel.Command.rectanglecommand    import RectangleCommand
from Kernel.Command.polygoncommand      import PolygonCommand
from Kernel.Command.copycommand         import CopyCommand
from Kernel.Command.movecommand         import MoveCommand
from Kernel.Command.mirrorcommand       import MirrorCommand
from Kernel.Command.rotatecommand       import RotateCommand
from Kernel.Command.trimcommand         import TrimCommand
from Kernel.Command.deletecommand       import DeleteCommand
from Kernel.Command.dimensioncommand    import DimensionCommand
from Kernel.Command.propertycommand     import PropertyCommand
#
# Entity List
#
from Kernel.GeoEntity.point        import Point
from Kernel.GeoEntity.segment      import Segment
from Kernel.GeoEntity.arc          import Arc
from Kernel.GeoEntity.ellipse      import Ellipse
from Kernel.GeoEntity.polyline     import Polyline
from Kernel.GeoEntity.style        import Style
from Kernel.GeoEntity.cline        import CLine
from Kernel.GeoEntity.ccircle      import CCircle
from Kernel.GeoEntity.text         import Text
from Kernel.GeoEntity.dimension    import Dimension

from Kernel.GeoComposedEntity.chamfer   import Chamfer
from Kernel.GeoComposedEntity.fillet    import Fillet
from Kernel.GeoComposedEntity.bisector  import Bisector
#
# db Ent
#
from Kernel.settings            import *
from Kernel.entity              import Entity
from Kernel.layer               import Layer
from Kernel.composedentity      import ComposedEntity
#
# Default LAyer
#
MAIN_LAYER="MAIN"
#
# Max Number of recent file
#
MAX_RECENT_FILE=5
#
# Object workflow state of the entity
#
OBJECT_STATE=['MODIFIE','RELEASED', 'DELETE']
#
# Supported entity by the Application
#
PY_CAD_ENT=['POINT',
            'SEGMENT',
            'SETTINGS',
            'LAYER',
            'STYLE',
            'ARC',
            'ELLIPSE',
            'POLYLINE',
            'CLINE',
            'CCIRCLE',
            'TEXT',
            'COMPOSED_ENTITY',
            'DIMENSION' ]

PY_CAD_COMPOSED_ENT=['CHAMFER', 'FILLET', 'BISECTOR']
#
# Command Supported by the application
#
APPLICATION_COMMAND={'SEGMENT':SegmentCommand,
                        'ARC':ArcCommand,
                        'CIRCLE':CircleCommand,
                        'POINT':PointCommand,
                        'ELLIPSE':EllipseCommand,
                        'POLYLINE':PolylineCommand,
#                        'CLINE':ACLineCommand,
                        'CCIRCLE':CCircleCommand,
                        'TEXT':TextCommand,
                        'CHAMFER':ChamferCommand,
                        'FILLET':FilletCommand,
                        'BISECTOR':BisectorCommand,
                        'RECTANGLE':RectangleCommand,
                        'POLYGON':PolygonCommand,
                        'COPY':CopyCommand,
                        'MOVE':MoveCommand,
                        'MIRROR':MirrorCommand,
                        'ROTATE':RotateCommand,
                        'TRIM':TrimCommand,
                        'DELETE':DeleteCommand,
                        'DIMENSION':DimensionCommand,
                        'PROPERTY':PropertyCommand}
#
# Match object Name
#
DRAWIN_ENTITY={ Point:'POINT',
                Segment:'SEGMENT',
                Arc:'ARC',
                Ellipse:'ELLIPSE',
                Polyline:'POLYLINE',
                CLine:'CLINE',
                CCircle:'CCIRCLE',
                Text:'TEXT',
                ComposedEntity:'COMPOSED_ENTITY',
                Dimension:'DIMENSION'}

DRAWIN_COMPOSED_ENTITY={Fillet:'FILLET',
                        Chamfer:'CHAMFER',
                        Bisector:'BISECTOR'}



KERNEL_ENTITY=(Style,Entity,Settings,Layer)
#
# Entity supported by the kernel
#
SUPPORTED_ENTITYS=KERNEL_ENTITY+tuple(DRAWIN_ENTITY.keys())+(ComposedEntity, )


PYTHONCAD_COLOR={
    'aliceblue'             :(240,248,255),
    'antiquewhite'          :(250,235,215),
    'aqua'                  :(0,255,255),
    'aquamarine'            :(127,255,212),
    'azure'                 :(240,255,255),
    'beige'                 :(245,245,220),
    'bisque'                :(255,228,196),
    'black'                 :(0,0,0),
    'blanchedalmond'        :(255,235,205),
    'blue'                  :(0,0,255),
    'blueviolet'            :(138,0o43,226),
    'brown'                 :(165,0o42,0o42),
    'burlywood'             :(222,184,135),
    'cadetblue'             :(95,158,160),
    'chartreuse'            :(127,255,0),
    'chocolate'             :(210,105,30),
    'coral'                 :(255,127,80),
    'cornflowerblue'        :(100,149,237),
    'cornsilk'              :(255,248,220),
    'crimson'               :(220,20,60),
    'cyan'                  :(0,255,255),
    'darkblue'              :(0,0,139),
    'darkcyan'              :(0,139,139),
    'darkgoldenrod'         :(184,134,11),
    'darkgray'              :(169,169,169),
    'darkgreen'             :(0,100,0),
    'darkgrey'              :(169,169,169),
    'darkkhaki'             :(189,183,107),
    'darkmagenta'           :(139,0,139),
    'darkolivegreen'        :(85,107,47),
    'darkorange'            :(255,140,0),
    'darkorchid'            :(153,50,204),
    'darkred'               :(139,0,0),
    'darksalmon'            :(233,150,122),
    'darkseagreen'          :(143,188,143),
    'darkslateblue'         :(72,61,139),
    'darkslategray'         :(47,79,79),
    'darkslategrey'         :(47,79,79),
    'darkturquoise'         :(0,206,209),
    'darkviolet'            :(148,0,211),
    'deeppink'              :(255,20,147),
    'deepskyblue'           :(0,191,255),
    'dimgray'               :(105,105,105),
    'dimgrey'               :(105,105,105),
    'dodgerblue'            :(30,144,255),
    'firebrick'             :(178,340,34),
    'floralwhite'           :(255,250,240),
    'forestgreen'           :(34,139,34),
    'fuchsia'               :(255,0,255),
    'gainsboro'             :(220,220,220),
    'ghostwhite'            :(248,248,255),
    'gold'                  :(255,215,0),
    'goldenrod'             :(218,165,32),
    'gray'                  :(128,128,128),
    'green'                 :(0,128,0),
    'greenyellow'           :(173,255,47),
    'honeydew'              :(240,255,240),
    'hotpink'               :(255,105,180),
    'indianred'             :(205,920,92),
    'indigo'                :(75,0,130),
    'ivory'                 :(255,255,240),
    'khaki'                 :(240,230,140),
    'lavender'              :(230,230,250),
    'lavenderblush'         :(255,240,245),
    'lawngreen'             :(124,252,0),
    'lemonchiffon'          :(255,250,205),
    'lightblue'             :(173,216,230),
    'lightcoral'            :(240,128,128),
    'lightcyan'             :(224,255,255),
    'lightgoldenrodyellow'  :(250,250,210),
    'lightgray'             :(211,211,211),
    'lightgreen'            :(144,238,144),
    'lightgrey'             :(211,211,211),
    'lightpink'             :(255,182,193),
    'lightsalmon'           :(255,160,122),
    'lightseagreen'         :(32,178,170),
    'lightskyblue'          :(135,206,250),
    'lightslategray'        :(119,136,153),
    'lightslategrey'        :(119,136,153),
    'lightsteelblue'        :(176,196,222),
    'lightyellow'           :(255,255,224),
    'lime'                  :(0,255,0),
    'limegreen'             :(50,205,0o50),
    'linen'                 :(250,240,230),
    'magenta'               :(255,0,255),
    'maroon'                :(128,0,0),
    'mediumaquamarine'      :(102,205,170),
    'mediumblue'            :(0,0,205),
    'mediumorchid'          :(186,85,211),
    'mediumpurple'          :(147,112,219),
    'mediumseagreen'        :(60,179,113),
    'mediumslateblue'       :(123,104,238),
    'mediumspringgreen'     :(0,250,154),
    'mediumturquoise'       :(72,209,204),
    'mediumvioletred'       :(199,21,133),
    'midnightblue'          :(0o25,25,112),
    'mintcream'             :(245,255,250),
    'mistyrose'             :(255,228,225),
    'moccasin'              :(255,228,181),
    'navajowhite'           :(255,222,173),
    'navy'                  :(0,0,128),
    'oldlace'               :(253,245,230),
    'olive'                 :(128,128,0),
    'olivedrab'             :(107,142,35),
    'orange'                :(255,165,0),
    'orangered'             :(255,69,0),
    'orchid'                :(218,112,214),
    'palegoldenrod'         :(238,232,170),
    'palegreen'             :(152,251,152),
    'paleturquoise'         :(175,238,238),
    'palevioletred'         :(219,112,147),
    'papayawhip'            :(255,239,213),
    'peachpuff'             :(255,218,185),
    'peru'                  :(205,133,0o63),
    'pink'                  :(255,192,203),
    'plum'                  :(221,160,221),
    'powderblue'            :(176,224,230),
    'purple'                :(128,0,128),
    'red'                   :(255,0,0),
    'rosybrown'             :(188,143,143),
    'royalblue'             :(65,105,225),
    'saddlebrown'           :(139,69,19),
    'salmon'                :(250,128,114),
    'sandybrown'            :(244,164,96),
    'seagreen'              :(46,139,87),
    'seashell'              :(255,245,238),
    'sienna'                :(160,82,45),
    'silver'                :(192,192,192),
    'skyblue'               :(135,206,235),
    'slateblue'             :(106,90,205),
    'slategray'             :(112,128,144),
    'slategrey'             :(112,128,144),
    'snow'                  :(255,250,250),
    'springgreen'           :(0,255,127),
    'steelblue'             :(70,130,180),
    'tan'                   :(210,180,140),
    'teal'                  :(0,128,128),
    'thistle'               :(216,191,216),
    'tomato'                :(255,99,71),
    'turquoise'             :(64,224,208),
    'violet'                :(238,130,238),
    'wheat'                 :(245,222,179),
    'white'                 :(255,255,255),
    'whitesmok'             :(255,255,0),
    'yellowgreen'           :(154,205,0o50)}

PYTHONCAD_HIGLITGT_COLOR=PYTHONCAD_COLOR['tomato']
PYTHONCAD_PREVIEW_COLOR=PYTHONCAD_COLOR['steelblue']

PYTHONCAD_LINETYPE={
    'continue':             (1),
    'dash':                 (10, 10),
    'central':              (10, 8, 1, 8)}

PYTHONCAD_STYLE_ATTRIBUTES=['entity_color',
                            'entity_linetype',
                            'entity_thickness',
                            'text_font',
                            'text_height',
                            'text_aling',
                            'text_aline_to_point',
                            'property']

PYTHONCAD_STYLE_DEFAULT_VALUE=[(0, 0, 0),
                                '1',
                                '1',
                                'arial',
                                '10',
                                'left'
                                'sw']
</t>
<t tx="1.20130426141258.2726">def getDefaultStyle():
    return dict(list(zip(PYTHONCAD_STYLE_ATTRIBUTES,PYTHONCAD_STYLE_DEFAULT_VALUE)))
</t>
<t tx="1.20130426141258.2727">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas 2009 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# classes that describe the layer 
#



@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.2728">class Layer(object):
    """
        this class manage a single layer
    """
    @others
</t>
<t tx="1.20130426141258.2729">def __init__(self, layerName=None, visible=True):
    """
        name            = name of the layer
    """
    self.__name=layerName
    self.__visible=visible
</t>
<t tx="1.20130426141258.2730">@property
def name(self):
    """
        Get/Set The layer name
    """
    return self.__name
</t>
<t tx="1.20130426141258.2731">@name.setter
def name(self, value):
    self.__name=value
</t>
<t tx="1.20130426141258.2732">@property
def Visible(self):
    """
        manage layer visibility 
    """
    return self.__visible
</t>
<t tx="1.20130426141258.2733">@Visible.setter
def Visible(self, value):
    self.__visible=value
</t>
<t tx="1.20130426141258.2734">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module all the interface to store the layer
#
#TODO : REPAIR THE LOGGER FOR THIS CLASS





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2735">from Kernel.layer               import Layer
from Kernel.exception           import *
from Kernel.initsetting         import MAIN_LAYER
from Kernel.pycadevent          import PyCadEvent
</t>
<t tx="1.20130426141258.2736">class LayerTree(object):
    """
        this class represents the layer tree structure
    """
    @others
</t>
<t tx="1.20130426141258.2737">def __init__(self,kernel):
    self.__kr=kernel
    try:
        self.__mainLayer=self.getEntLayerDb(MAIN_LAYER)
    except EntityMissing:
        mainLayer=Layer(MAIN_LAYER)
        self.__mainLayer=self.__kr.saveEntity(mainLayer)
    except:
        raise StructuralError("Unable to inizialize LayerTree")
    self.__activeLayer=self.__mainLayer
    self.setCurrentEvent=PyCadEvent()
    self.deleteEvent=PyCadEvent()
    self.insertEvent=PyCadEvent()
    self.update=PyCadEvent()
</t>
<t tx="1.20130426141258.2738">def setActiveLayer(self, layerId):
    """
        set the active layer
    """
    activeLayer=self.__kr.getEntity(layerId)
    if activeLayer:
        self.__activeLayer=activeLayer
        self.setCurrentEvent(activeLayer)
    else:
        raise EntityMissing("Unable to find the layer %s"%str(layerName))
</t>
<t tx="1.20130426141258.2739">def getActiveLater(self):
    """
        get the active layer
    """
    return self.__activeLayer
</t>
<t tx="1.20130426141258.2740">def insert(self, layer, parentLayer):
    """
        Insert a new object in the class and set it as active
    """
    parentEntDb=self.__kr.getEntity(parentLayer.getId())
    if not parentEntDb:
        raise  EntityMissing("Unable to find the root layer %s id %s "%(str(parentLayer), str(parentLayer.getId())))
    childEndDb=self.__kr.getEntity(layer.getId())
    if not childEndDb:
        childEndDb=self.__kr.saveEntity(layer)
    if not self.__kr.getRelatioObject().relationExsist(parentEntDb.getId(),childEndDb.getId() ):
        self.__kr.getRelatioObject().saveRelation(parentEntDb, childEndDb)
    self.__activeLayer=childEndDb
    self.insertEvent(childEndDb) #Fire Event
</t>
<t tx="1.20130426141258.2741">def _getLayerConstructionElement(self, pyCadEnt):
    """
        Retrive the ConstructionElement in the pyCadEnt
    """
    unpickleLayers=pyCadEnt.getConstructionElements()
    for key in unpickleLayers:
        return unpickleLayers[key]
    return None
</t>
<t tx="1.20130426141258.2742">def getLayerChildrenLayer(self,layer):
    """
        get the layer children
    """
    return self.__kr.getAllChildrenType(layer, 'LAYER')
</t>
<t tx="1.20130426141258.2743">#************************************************************************
#*************************layer managment********************************
#************************************************************************
def getLayerChildIds(self,layer):
    """
        get all the child id of a layer
    """
    #manage in a better way the logger  self.__kr.__logger.debug('getLayerChild')
    _layerId=self.__kr.getEntLayerDb(layerName).getId()
    _childIds=self.__kr.__pyCadRelDb.getChildrenIds(_layerId)
    return _childIds
</t>
<t tx="1.20130426141258.2744">def getLayerChildren(self,layer,entityType=None):
    """
        get all dbEnt from layer of type entityType
    """
    _children=self.__kr.getAllChildrenType(layer,entityType)
    return _children
</t>
<t tx="1.20130426141258.2745">def getEntLayerDb(self,layerName):
    """
        get the pycadent  layer by giving a name
    """
    #TODO: manage logger self.__logger.debug('getEntLayerDb')
    _layersEnts=self.__kr.getEntityFromType('LAYER')
    #TODO: Optimaze this loop with the build in type [...] if possible
    for layersEnt in _layersEnts:
        unpickleLayers=layersEnt.getConstructionElements()
        for key in unpickleLayers:
            if unpickleLayers[key].name==layerName:
                return layersEnt
    else:
        raise EntityMissing("Layer name %s missing"%str(layerName))
</t>
<t tx="1.20130426141258.2746">def getLayerTree(self):
    """
        create a dictionary with all the layer nested
    """
    rootDbEnt=self.getEntLayerDb(MAIN_LAYER)
    def createNode(layer):
        childs={}
        c=self._getLayerConstructionElement(layer)
        layers=self.getLayerChildrenLayer(layer)
        for l in layers:
            ca=self._getLayerConstructionElement(l)
            childs[l.getId()]=(ca, createNode(l))
        return childs
    c=self._getLayerConstructionElement(rootDbEnt)
    exitDb={}
    exitDb[rootDbEnt.getId()]=(c,createNode(rootDbEnt) )
    return exitDb
</t>
<t tx="1.20130426141258.2747">def getLayerdbTree(self):
    """
        create a dictionary with all the layer nested as db entity
    """
    rootDbEnt=self.getEntLayerDb(MAIN_LAYER)
    def createNode(layer):
        childs={}
        layers=self.getLayerChildrenLayer(layer)
        for l in layers:
            childs[l.getId()]=(l, createNode(l))
        return childs
    exitDb={}
    exitDb[rootDbEnt.getId()]=(rootDbEnt,createNode(rootDbEnt) )
    return exitDb
</t>
<t tx="1.20130426141258.2748">def getParentLayer(self,layer):
    """
        get the parent layer
        ToDo: to be tested
    """
    return self.__kr.getRelatioObject().getParentEnt(layer)
</t>
<t tx="1.20130426141258.2749">def delete(self,layerId):
    """
        delete the current layer an all the entity releted to it
    """
    self.__kr.startMassiveCreation()
    deleteLayer=self.__kr.getEntity(layerId)
    if deleteLayer is self.__activeLayer:
        self.setActiveLayer(self.getParentLayer(deleteLayer).getId())
    #
    def recursiveDelete(layer):
        # delete all children layer
        for layer in self.getLayerChildrenLayer(deleteLayer):
            recursiveDelete(layer)
        # delete all the children entity
        self.deleteLayerEntity(layer)
        # finally delete the layer
        layerId=layer.getId()
        self.__kr.deleteEntity(layerId)
        self.deleteEvent(layerId) # Fire Event
    recursiveDelete(deleteLayer)    
    self.__kr.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2750">def deleteLayerEntity(self, layer):
    """
        delete all layer entity
    """
    for ent in self.getLayerChildren(layer):
            self.__kr.deleteEntity(ent.getId())
</t>
<t tx="1.20130426141258.2751">def rename(self, layerId, newName):
    """
        rename the layer
    """
    layer=self.__kr.getEntity(layerId)
    self._rename(layer, newName)
    self.update(layerId) # fire update event
</t>
<t tx="1.20130426141258.2752">def _rename(self, layer, newName):
    """
        rename the layer internal use
    """
    layer.getConstructionElements()['LAYER'].name=newName
    self.__kr.saveEntity(layer)
    self.update(layer)
</t>
<t tx="1.20130426141258.2753">def _Hide(self, layer, hide=True):
    """
        inner function for hiding the layer
    """
    # Hide/Show all the children entity
    self.hideLayerEntity(layer, hide)
    # Hide and update the layer object    
    layer.getConstructionElements()['LAYER'].Visible=not hide
    self.__kr.saveEntity(layer)
    self.update(layer)
</t>
<t tx="1.20130426141258.2754">def isMainLayer(self, layer):
    """
        check if the layer is the main layer
    """
    if layer.getConstructionElements()['LAYER'].name==MAIN_LAYER:
        return True
    return False
</t>
<t tx="1.20130426141258.2755">def Hide(self, layerId, hide=True):
    self.__kr.startMassiveCreation()
    topLayer=self.__kr.getEntity(layerId)  
    if self.isMainLayer(topLayer):
        raise PythonCadWarning("Unable to hide/show the main Layer")   
    if layerId is self.__activeLayer.getId():
        self.setActiveLayer(self.getParentLayer(topLayer).getId())
    #
    def recursiveHide(layer):
        self._Hide(layer, hide)
        # hide/show all children layer
        for layer in self.getLayerChildrenLayer(layer):
            recursiveHide(layer)
       
    recursiveHide(topLayer)    
    self.__kr.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2756">def hideLayerEntity(self, layer, hide=True):    
    """
        hide all the entity of the layer
    """
    if hide:
        for ent in self.getLayerChildren(layer):
            self.__kr.hideEntity(entity=ent)
    else:
        for ent in self.getLayerChildren(layer):
            self.__kr.unHideEntity(entity=ent)
</t>
<t tx="1.20130426141258.2757">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module define a custom event class 
#




@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.2758">class PyCadEvent(object):
    """
        this class fire the envent from the python kernel
    """
    @others
    __iadd__ = handle
    __isub__ = unhandle
    __call__ = fire
    __len__  = getHandlerCount
</t>
<t tx="1.20130426141258.2759">def __init__(self):
    self.handlers = set()
</t>
<t tx="1.20130426141258.2760">def handle(self, handler):
    self.handlers.add(handler)
    return self
</t>
<t tx="1.20130426141258.2761">def unhandle(self, handler):
    try:
        self.handlers.remove(handler)
    except:
        raise ValueError("PythonCad Handler is not handling this event.")
    return self
</t>
<t tx="1.20130426141258.2762">def fire(self, *args, **kargs):
    for handler in self.handlers:
        handler(*args, **kargs)
</t>
<t tx="1.20130426141258.2763">def getHandlerCount(self):
    return len(self.handlers)
</t>
<t tx="1.20130426141258.2764">@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.2765">class Transaction(object):
    @others
</t>
<t tx="1.20130426141258.2766">def __init__(self, connection):
    
    self._connection = connection
    self._cursor = self._connection.cursor()
</t>
<t tx="1.20130426141258.2767">def _GetCursor(self):
    return self._cursor
</t>
<t tx="1.20130426141258.2768">Cursor = property(_GetCursor, None, None, "gets the cursor")


def Close(self, commit):
    
    if commit == True:
        # commit transaction
        self._connection.commit()
    else:
        # abort transaction
        self._connection.abort()
    # close cursor
    self._cursor.close()
</t>
<t tx="1.20130426141258.2769">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide all the basic operation for the pythoncad settings
#





@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.2770">class Settings(object):
    """
        this class provide access at all the pythoncad settings
    """
    @others
</t>
<t tx="1.20130426141258.2771">def __init__(self,name):
    """
        the name of the settings schema
    """
    self.__name=name
    self.__activeLayer="ROOT"
    self.__property={}
</t>
<t tx="1.20130426141258.2772">@property
def name(self):
    """
        get the settings Name
    """
    return self.__name
</t>
<t tx="1.20130426141258.2773">@name.setter
def name(self,name):
    """
        set the settings name
    """
    self.__name=name
</t>
<t tx="1.20130426141258.2774">@property
def layerName(self):
    """
        get the anctive layer of the settings
    """
    return self.__activeLayer
</t>
<t tx="1.20130426141258.2775">@layerName.setter
def layerName(self,lName):
    """
        set the active layer id
    """
    self.__activeLayer=lName
</t>
<t tx="1.20130426141258.2776">def getVariable(self, name):
    """
        Get The variable in the settings object
    """
    if self.__property and name in self.__property:
        return self.__property[name]
    return None
</t>
<t tx="1.20130426141258.2777">def setVariable(self, name, value):
    """
        Set The variable in the settings object
    """
    self.__property[name]=value
</t>
<t tx="1.20130426141258.2778">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide a parser for the imput interface
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__ == '__main__':
    print(convertLengh('10*u.m+3.5*u.cm+10*u.ft'))
    print(convertAngle('10'))
    print(convertAngle('90*u.deg'))
    print(sympyConvertAngle('10*u.rad+10*u.deg'))
</t>
<t tx="1.20130426141258.2779">from sympy.physics                  import units as u
</t>
<t tx="1.20130426141258.2780">def convertAngle(value):
    """
        convert a angle in simpy units syntax into a rad float
    """
    value=str(value).lower()
    retVal=None
    try:
        retVal=float(value)
    except:
        try:
            retVal=sympyConvertAngle(value)
        except:
            print("Wrong formatting string")
    finally:
        return retVal
</t>
<t tx="1.20130426141258.2781">def sympyConvertAngle(value):
    retVal=None
    value='retVal='+value
    exec(value)
    retVal=retVal/u.rad
    return float(retVal)
</t>
<t tx="1.20130426141258.2782">def convertLengh(value):
    """
        convert a lengh in simpy units syntax into a mm float
        return : Float
    """
    value=str(value).lower()
    retVal=None
    try:
        retVal=float(value)
    except:
        try:
            retVal=sympyConvertLeng(value)
        except:
            print("Wrong formatting string")
    finally:
        return retVal
</t>
<t tx="1.20130426141258.2783">def sympyConvertLeng(value):
    retVal=None
    value='retVal='+value
    exec(value)
    retVal=retVal/u.mm
    return float(retVal.n())
</t>
<t tx="1.20130426141258.2784">@language python
@tabwidth -4
@others
#
# Copyright (c) 2004 Art Haas
#

#
# this file is needed for Python's import mechanism
#
</t>
<t tx="1.20130426141258.2785"></t>
<t tx="1.20130426141258.2786">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2787">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
from Kernel.GeoEntity.arc              import Arc
</t>
<t tx="1.20130426141258.2788">class ArcCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2789">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght, ExcAngle, ExcAngle]
    self.defaultValue=[None, 10, 0, math.pi*2]
    self.message=["Give Me the Center Point: ", 
                    "Give Me the Radius: ", 
                    "Give Me the Start Angle [Create a circle]: ", 
                    "Give Me the Span Angle: "]
</t>
<t tx="1.20130426141258.2790">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    self.applyDefault()
    arg={"ARC_0":self.value[0], 
            "ARC_1":self.value[1], 
            "ARC_2":self.value[2], 
            "ARC_3":self.value[3]
            }    
    arc=Arc(arg)
    self.document.saveEntity(arc)
</t>
<t tx="1.20130426141258.2791">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide basic command function
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2792">from Kernel.exception           import *
from Kernel.unitparser          import *
from Kernel.GeoEntity.point     import Point
</t>
<t tx="1.20130426141258.2793">class BaseCommand(object):
    """
        this class provide a base command
    """
    @others
</t>
<t tx="1.20130426141258.2794">def __init__(self, document):
    """
        kernel is a PyCadKernel object
    """
    self.exception=[]
    self.value=[]
    self.message=[]
    self.defaultValue=[]
    self.index=0
    self.document=document
    self.automaticApply=True
    self.autorestart=True
</t>
<t tx="1.20130426141258.2795">def __iter__(self):
    return self
</t>
<t tx="1.20130426141258.2796">def __setitem__(self, key, value):
    """
        set the value of the command
    """
    if not isinstance(value, tuple) or len(value)!=5:
        raise PyCadWrongImputData("BaseCommand : Wrong value provide a good tuple (point,entity,distance)")
    value=self.translateCmdValue(value)
    if value==None:
        raise PyCadWrongImputData("BaseCommand : Wrong imput parameter for the command")
    self.value.append(value)
</t>
<t tx="1.20130426141258.2797">def resetToDefault(self):
    """
        Reset the command to default value
    """
    self.value=[]
    for val in self.defaultValue:
        self.value.append(val)
</t>
<t tx="1.20130426141258.2798">def applyDefault(self):
    i=0
    for value in self.value:
        if self.value[i]==None:
            self.value[i]=self.defaultValue[i]
        i+=1
    for i in range(i,self.lenght):
        self.value.append(self.defaultValue[i])
</t>
<t tx="1.20130426141258.2799">def reset(self):
    """
        reset the command
    """
    self.index=0
    self.value=[]
</t>
<t tx="1.20130426141258.2800">@property
def valueIndex(self):
    """
        get the index of the insert value in the command
    """
    return len(self.value)
</t>
<t tx="1.20130426141258.2801">def __next__(self):
    """
        go on with the iteration
    """
    self.index+=1
    TotNIter=len(self.exception)
    if self.index&gt;=TotNIter:
        raise StopIteration
    return (self.exception[self.index],self.message[self.index])
</t>
<t tx="1.20130426141258.2802">def activeException(self):
    """
        Return the active exception
    """
    return self.exception[self.index]
</t>
<t tx="1.20130426141258.2803">@property
def activeMessage(self):
    """
        get Active message
    """
    if len(self.message)&gt;self.index:
        return self.message[self.index]
    else:
        return "Press enter to execute the command"
</t>
<t tx="1.20130426141258.2804">def performDefaultValue(self):
    """
        perform the default value
    """
    if self.activeDefaultValue()!=None:
        self.value.append(self.activeDefaultValue())
    else:
        raise NoDefaultValue("No default value is possible for the active command")
</t>
<t tx="1.20130426141258.2805">def activeDefaultValue(self):
    """
        Return the active default value
    """
    return self.defaultValue[self.index]
</t>
<t tx="1.20130426141258.2806">def getActiveDefaultValue(self):
    """
        get the default value for the active command input
    """
    if self.index&gt;=0 and self.index&lt;=len(self.defaultValue)-1:
        return self.defaultValue[self.index]
    else:
        return None
</t>
<t tx="1.20130426141258.2807">def previus(self):
    """
        came back with the iteration
    """
    self.index-=1
    if self.index&lt;0:
        self.index=0
    return (self.exception[self.index],self.message[self.index])
</t>
<t tx="1.20130426141258.2808">def keys(self):
    """
        return all the exception key
    """
    return self.exception
</t>
<t tx="1.20130426141258.2809">@property
def lenght(self):
    """
        get the number of command input value that the user have to provide
    """
    return len(self.exception)
</t>
<t tx="1.20130426141258.2810">def applyCommand(self):
    """
        this method here must be defined
    """
    pass
</t>
<t tx="1.20130426141258.2811">def translateCmdValue(self , value):
    """
        translate the imput value based on exception
    """
    point, entitys, distance, angle , text=value
    exitValue=None
    try:
        raise self.activeException()(None)
    except ExcPoint:
        exitValue=point
    except ExcEntity:
        if entitys:
            exitValue=str(entitys[0].ID)
    except ExcMultiEntity:
        exitValue=self.getIdsString(entitys)
    except ExcEntityPoint:
        if entitys:
            exitValue=(str(entitys[0].ID), point)
    except (ExcLenght):
        if distance:
            exitValue=self.convertToFloat(distance)
    except(ExcAngle):
        if angle:
            exitValue=convertAngle(angle)
        elif distance:
            exitValue=distance
        else:
            p0=Point(0.0, 0.0)
            x, y=point.getCoords()
            p1=Point(x, y)
            exitValue=Vector(p0, p1).absAng
    except(ExcInt):
        exitValue=self.convertToInt(distance)
    except(ExcText):
        exitValue=text
        if text==None:
            exitValue=""
    except(ExcBool):
        if text=="TRUE":
            exitValue=True
        else:
            exitValue=False
    except(ExcDicTuple):
        exitValue=text
    except:
        raise PyCadWrongImputData("BaseCommand : Wrong imput parameter for the command")
    finally: return exitValue
</t>
<t tx="1.20130426141258.2812">def getIdsString(self, selectedItems):
    """
        get the selected entity in terms of ids
    """
    text=None
    for ent in selectedItems:
        if not text:
            text=''
            text+=str(ent.ID)
        else:
            text+=","+str(ent.ID)
    return text
</t>
<t tx="1.20130426141258.2813">def convertToBool(self, msg):
    """
        return an int from user
    """
    if msg=="Yes":
        return True
    else:
        return False
</t>
<t tx="1.20130426141258.2814">def convertToInt(self, msg):
    """
        return an int from user
    """
    if msg:
        return int(convertLengh(msg))
    return None
</t>
<t tx="1.20130426141258.2815">def convertToFloat(self, msg):
    """
        return a float number
    """
    if msg:
        return convertLengh(msg)
    return None
</t>
<t tx="1.20130426141258.2816">def convertToAngle(self, msg):
    """
        convert the angle using sympy
    """
    if msg:
        p=convertAngle(msg)
        return p
    return None
</t>
<t tx="1.20130426141258.2817">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the bisector command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2818">from Kernel.exception                      import *
from Kernel.composedentity                 import ComposedEntity
from Kernel.Command.basecommand            import *
from Kernel.GeoComposedEntity.bisector     import Bisector
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoUtil.util                    import getIdPoint
</t>
<t tx="1.20130426141258.2819">class BisectorCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2820">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcLenght]
    self.defaultValue=[None, None, 100]
    self.message=[  "Select the First Segment: ", 
                    "Select the Second Segment: ", 
                    "Give me the Bisector Lengh: "]
</t>
<t tx="1.20130426141258.2821">def getEntsToSave(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2":p0, 
         "OBJECTJOINT_3":p1, 
         "OBJECTJOINT_5":self.value[2], 
         }

    cmf=Bisector(arg)
    bisectorSegment = cmf.getReletedComponent()
    objEnt.append(bisectorSegment)
    return objEnt
</t>
<t tx="1.20130426141258.2822">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of input parameters")
    for _ent in self.getEntsToSave():
        self.document.saveEntity(_ent)
</t>
<t tx="1.20130426141258.2823">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2824">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.ccircle          import CCircle
</t>
<t tx="1.20130426141258.2825">class CCircleCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2826">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght]
    self.defaultValue=[None, 10]
    self.message=["Give Me the center Point", "Give Me the radius"]
</t>
<t tx="1.20130426141258.2827">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={
         "CCIRCLE_0":self.value[0], 
         "CCIRCLE_1":self.value[1]
         }
    ccircle=CCircle(arg)
    self.document.saveEntity(ccircle)
</t>
<t tx="1.20130426141258.2828">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the champfer command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2829">from Kernel.exception                       import *
from Kernel.composedentity                  import ComposedEntity
from Kernel.Command.basecommand             import *
from Kernel.GeoComposedEntity.chamfer       import Chamfer
from Kernel.GeoEntity.segment               import Segment
from Kernel.GeoUtil.util                    import getIdPoint
</t>
<t tx="1.20130426141258.2830">class ChamferCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2831">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcText , 
                    ExcLenght, 
                    ExcLenght 
                    ]
    self.defaultValue=[None, None, "BOTH", 10, 10]
    self.message=[  "Select the First entity: ", 
                    "Select the Second entity: ", 
                    "Give me trim Mode (FIRST,SECOND,BOTH,NO_TRIM) [BOTH]: ", 
                    "Give me the first Chamfer Lenght: ", 
                    "Give me the second Chamfer Lenght: ", 
                    ]
</t>
<t tx="1.20130426141258.2832">def getEntsToSave(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
   
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2":p0, 
         "OBJECTJOINT_3":p1, 
         "OBJECTJOINT_4":self.value[2], 
         "OBJECTJOINT_5":self.value[3], 
         "OBJECTJOINT_6":self.value[4]
         }

    cmf=Chamfer(arg)
    seg1Mod, seg2Mod, chamferSegment = cmf.getReletedComponent()
    
    _cElements1, entityType=self.document._getCelements(seg1Mod)
    _cElements2, entityType=self.document._getCelements(seg2Mod)
   
    ent1.setConstructionElements(_cElements1)
    ent2.setConstructionElements(_cElements2)
    
    objEnt.append(ent1)
    objEnt.append(ent2)
    objEnt.append(chamferSegment)
    return objEnt
</t>
<t tx="1.20130426141258.2833">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=5:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2834">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the arc command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2835">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
from Kernel.GeoEntity.arc              import Arc
</t>
<t tx="1.20130426141258.2836">class CircleCommand(BaseCommand):
    """
        this class rappresent the arc command
    """
    @others
</t>
<t tx="1.20130426141258.2837">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght]
    self.defaultValue=[None, 10, 0, math.pi*2]
    self.message=["Give Me the center Point", 
                    "Give Me the radius"]
</t>
<t tx="1.20130426141258.2838">def applyCommand(self):
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    self.applyDefault()
    arg={"ARC_0":self.value[0], 
            "ARC_1":self.value[1], 
            "ARC_2":0, 
            "ARC_3":math.pi*2
            }    
    arc=Arc(arg)
    self.document.saveEntity(arc)
</t>
<t tx="1.20130426141258.2839">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2840">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.cline           import CLine
</t>
<t tx="1.20130426141258.2841">class CLineCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2842">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.message=["Give Me the first Point","Give Me the first Point"]
</t>
<t tx="1.20130426141258.2843">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={"CLINE_0":self.value[0],"CLINE_0":self.value[1] }
    cline=CLine(arg)
    self.document.saveEntity(cline)
</t>
<t tx="1.20130426141258.2844">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the move command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2845">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.arc           import Arc
</t>
<t tx="1.20130426141258.2846">class CopyCommand(BaseCommand):
    """
        this class rappresent the Move command
    """
    @others
</t>
<t tx="1.20130426141258.2847">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint,
                    ExcPoint]
    self.defaultValue=[None, None,None]
    self.message=[  "Select Entities to copy: ",
                    "Give me the Base Point: ",
                    "Give me the Destination Point: "]
</t>
<t tx="1.20130426141258.2848">def getEntsToSave(self):
    """
       get entity to save
    """
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.move(self.value[1], self.value[2])
        updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2849">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2850">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Trim command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2851">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity               import *
from Kernel.GeoUtil.intersection    import *
from Kernel.GeoUtil.util            import *
</t>
<t tx="1.20130426141258.2852">class DeleteCommand(BaseCommand):
    """
        this class rappresent the Trim command
    """
    @others
</t>
<t tx="1.20130426141258.2853">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity]
    self.message=["Select Entities to be Deleted: "]
</t>
<t tx="1.20130426141258.2854">def applyDefault(self):    
    """
        aver written to  avoid apply default in this command
    """
    return
</t>
<t tx="1.20130426141258.2855">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for id in str(self.value[0]).split(','):
            self.document.deleteEntity(id)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2856">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2857">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoUtil.geolib          import Vector
from Kernel.GeoEntity.dimension     import Dimension
</t>
<t tx="1.20130426141258.2858">class DimensionCommand(BaseCommand):
    """
        This class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2859">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint,ExcPoint,ExcPoint, ExcAngle]
    self.defaultValue=[None, None, None, 0]
    self.message=["Give Me The First Point: ",
                    "Give Me The Second Point: ",
                    "Give Me Dimesion Position: ", 
                    "Give Me The Orientation Angle"]   # what does it mean???
</t>
<t tx="1.20130426141258.2860">@property
def getAngle(self):
    """
        Calculate the angle based on the starting and ending point
    """
    v=Vector(self.value[0], self.value[1])
    return v.absAng
</t>
<t tx="1.20130426141258.2861">def applyCommand(self):
    if len(self.value)==3: #assing the angle
        self.value.append(self.getAngle)
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    dimArgs={"DIMENSION_1":self.value[0], 
                "DIMENSION_2":self.value[1], 
                "DIMENSION_3":self.value[2], 
                "DIMENSION_4":self.value[3]}
    dimension=Dimension(dimArgs)
    self.document.saveEntity(dimension)
</t>
<t tx="1.20130426141258.2862">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the ellipse command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2863">from Kernel.exception                   import *
from Kernel.Command.basecommand         import *
from Kernel.GeoEntity.ellipse          import Ellipse
</t>
<t tx="1.20130426141258.2864">class EllipseCommand(BaseCommand):
    """
        this class rappresent the ellips command
    """
    @others
</t>
<t tx="1.20130426141258.2865">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcLenght, ExcLenght]
    self.defaultValue=[None, 100, 50]
    self.message=["Give Me the Center Point (We know input sequence is at the moment very odd, sorry.): ", "Give Me First Axis Lenght: ", "Give Me Second Axis Half Lenght: "]
</t>
<t tx="1.20130426141258.2866">def applyCommand(self):
    if len(self.value)&gt;3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    arg={"ELLIPSE_0":self.value[0], "ELLIPSE_1":self.value[1], "ELLIPSE_2":self.value[2]}
    ellipse=Ellipse(arg)
    self.document.saveEntity(ellipse)
</t>
<t tx="1.20130426141258.2867">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the fillet command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2868">from Kernel.exception                      import *
from Kernel.composedentity                 import ComposedEntity
from Kernel.Command.basecommand            import *
from Kernel.GeoComposedEntity.fillet       import Fillet
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoUtil.util                   import getIdPoint
</t>
<t tx="1.20130426141258.2869">class FilletCommand(BaseCommand):
    """
        this class rappresent the champfer command
    """
    @others
</t>
<t tx="1.20130426141258.2870">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint, 
                    ExcText, 
                    ExcLenght]
    self.defaultValue=[None, None,"BOTH",10]
    self.message=[  "Select the First Entity: ", 
                    "Select the Second Entity: ", 
                    "Give me Trim Mode (FIRST,SECOND,BOTH,NO_TRIM) [BOTH]: ", 
                    "Give me the radius [10]: " 
                    ]
</t>
<t tx="1.20130426141258.2871">def getEntsToSave(self):
    """
        get the fillet segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    
    objEnt=[]
    ent1=self.document.getEntity(id0)
    ent2=self.document.getEntity(id1)
    
    cel1=ent1.getConstructionElements()
    seg1=Segment(cel1)
    
    cel2=ent2.getConstructionElements()
    seg2=Segment(cel2)
    arg={
         "OBJECTJOINT_0":seg1,
         "OBJECTJOINT_1":seg2,  
         "OBJECTJOINT_2": p0, 
         "OBJECTJOINT_3": p1, 
         "OBJECTJOINT_4":self.value[2], 
         "OBJECTJOINT_5":self.value[3]
         }

    fillet=Fillet(arg)
    seg1Mod, seg2Mod, filletArc = fillet.getReletedComponent()
    
    _cElements1, entityType=self.document._getCelements(seg1Mod)
    _cElements2, entityType=self.document._getCelements(seg2Mod)
   
    ent1.setConstructionElements(_cElements1)
    ent2.setConstructionElements(_cElements2)
    
    objEnt.append(ent1)
    objEnt.append(ent2)
    
    objEnt.append(filletArc)
    return objEnt
</t>
<t tx="1.20130426141258.2872">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2873">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the polyline command
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2874">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point            import Point
</t>
<t tx="1.20130426141258.2875">class MirrorCommand(BaseCommand):
    """
        This class rappresent the mirror command
    """
    @others
</t>
<t tx="1.20130426141258.2876">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcEntity, 
                    ExcText]
    self.defaultValue=[None, None, "C"]
    self.message=[  "Select the entity to mirror or give me a the keyword Text As: (10,20,30,...)", 
                    "Select the reference line ", 
                    "Move or Copy? [M]: "]
</t>
<t tx="1.20130426141258.2877">def performMirror(self):
    """
        perform the mirror of all the entity selected
    """
    move=True
    if self.value[2]:
        if self.value[2].upper()=='C':
            move=False
    mirrorRef=self.document.getEntity(self.value[1])
    geoMirrorRef=self.document.convertToGeometricalEntity(mirrorRef)
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.mirror(geoMirrorRef)
        if move:
            dbEnt.setConstructionElements(geoEnt.getConstructionElements())
            updEnts.append(dbEnt)
        else:
            updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2878">def applyCommand(self):
    """
        perform the write of the entity
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.performMirror():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2879">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the move command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2880">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.arc           import Arc
</t>
<t tx="1.20130426141258.2881">class MoveCommand(BaseCommand):
    """
        this class rappresent the Move command
    """
    @others
</t>
<t tx="1.20130426141258.2882">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint, 
                    ExcPoint]
    self.defaultValue=[None, None,None]
    self.message=[  "Select Entities to Move: ", 
                    "Give me the Base Point: ",
                    "Give me the Destination Point: "]
</t>
<t tx="1.20130426141258.2883">def getEntsToSave(self):
    """
       get entity to save
    """
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.move(self.value[1], self.value[2])
        dbEnt.setConstructionElements(geoEnt.getConstructionElements())
        updEnts.append(dbEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2884">def applyCommand(self):
    """
        apply the champfer command
    """
    if len(self.value)!=3:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2885">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the point command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2886">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2887">class PointCommand(BaseCommand):
    """
        this class rappresent the point command
    """
    @others
</t>
<t tx="1.20130426141258.2888">def __init__(self, kernel):
    BaseCommand.__init__(self, kernel)
    self.exception=[ExcPoint]
    self.defaultValue=[None]
    self.message=["Give Me the Point Position: "]
</t>
<t tx="1.20130426141258.2889">def applyCommand(self):
    if len(self.value)!=1:
        raise PyCadWrongImputData("Wrong number of input parameter")
    point=Point(self.value[0])
    self.document.saveEntity(point)
</t>
<t tx="1.20130426141258.2890">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Polygon command
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2891">import math
import array

from Kernel.exception                   import *
from Kernel.Command.basecommand         import *
from Kernel.GeoEntity.point             import Point
from Kernel.GeoEntity.segment           import Segment
</t>
<t tx="1.20130426141258.2892">class PolygonCommand(BaseCommand):
    """
        A specialized to for creating Polygons from Segments.
        The PolygonTool will create an uniformly sized polygon from Segment
        entities. The minimum number of sides is three, creating an equilateral
        triangle. There is no maximum number of sides, though realistically any
        polygon with more than 20 or so sides is unlikely to be drawn.
    """
    @others
</t>
<t tx="1.20130426141258.2893">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, 
                    ExcPoint, 
                    ExcInt, 
                    ExcText]
    self.defaultValue=[None, None,6,"I"]
    self.message=["Give Me the Polygon Center Point: ",
                    "Give Me a Point to Define Circumference: ", 
                    "Give Me The Number of Sides: ", 
                    "Inscribed or Circumscribed [I]: "]
    self.__xpts = array.array("d")
    self.__ypts = array.array("d")
    self.__increment=0.0 #default value
</t>
<t tx="1.20130426141258.2894">@property
def side(self):
    """
        Get the number of sides of the polygon to be created.
        A ValueError exception is raised if the side count has not been
        set with setSideCount()
    """
    if self.value[2] is None:
        raise ValueError("No side count defined.")
    return int(self.value[2])
</t>
<t tx="1.20130426141258.2895">@side.setter
def side(self, value):
    self.value[2]=value
</t>
<t tx="1.20130426141258.2896">def updateSide(self):
    """
        Set the number of sides of the polygon to create.
        Argument "count" should be an integer value greater than 2.
    """
    self.__increment = (math.pi*2)/float(self.side)
    for i in range(self.side):
        self.__xpts.insert(i, 0.0)
        self.__ypts.insert(i, 0.0)
</t>
<t tx="1.20130426141258.2897">@property
def external(self):
    """
        Test if the polygon will be created outside a circle.
        If the setExternal() method has been called, this method will
        return True. By default this method will return False.
    """
    return self.value[3]
</t>
<t tx="1.20130426141258.2898">@external.setter
def external(self, value):
    """
        Create the polygon on the outside of a reference circle.
        By default the polygon is drawing completely contained within a
        circle. Invoking this method will created the polygon so that all
        sides are outside the circle.
    """
    if value=="I":
        self.value[3] = True
    else:
        self.value[3] = False
</t>
<t tx="1.20130426141258.2899">@property  
def externalPick(self):
    """
        get user external pick
    """
    return self.value[1]
</t>
<t tx="1.20130426141258.2900">@externalPick.setter
def externalPick(self, value):
    """
        get user external pick
    """
    self.value[1]=value
</t>
<t tx="1.20130426141258.2901">@property
def center(self):
    """
        Retrieve the center of the polygon to be created.
    """
    if self.value[0] is None:
        raise ValueError("Center is undefined.")
    return self.value[0]
</t>
<t tx="1.20130426141258.2902">@center.setter
def center(self, p):
    """
        Define the center of the polygon.
        Arguments 'x' and 'y' should be float values.
    """
    if self.value[0] and p ==None:
        return
    if isinstance(p, Point):
        self.value[0] = p
    else:
        raise TypeError("p must be a of type Point")
</t>
<t tx="1.20130426141258.2903">def getCoord(self, i):
    """
        Get one of the coordinates of the polygon corners.
        Argument "i" should be an integer value such that:
        0 &lt;= i &lt;= number of polygon sides
    """
    _x = self.__xpts[i]
    _y = self.__ypts[i]
    return _x, _y
</t>
<t tx="1.20130426141258.2904">def CalculatePoint(self):
    """
        This method calculates the polygon
        points.
    """
    if self.value[3].upper()=="C":
        _offset = self.__increment/2.0
    elif self.value[3].upper()=="I":
        _offset = 0.0
    _cx, _cy = self.center.getCoords()
    _x, _y = self.externalPick.getCoords()
    _xsep = _x - _cx
    _ysep = _y - _cy
    _angle = math.atan2(_ysep, _xsep) + _offset
    _rad = math.hypot(_xsep, _ysep)/math.cos(_offset)
    _xp = self.__xpts
    _yp = self.__ypts
    for _i in range(self.side):
        _xp[_i] = _cx + (_rad * math.cos(_angle))
        _yp[_i] = _cy + (_rad * math.sin(_angle))
        _angle = _angle + self.__increment
    self.__xpts=_xp
    self.__ypts=_yp
</t>
<t tx="1.20130426141258.2905">def getEntsToSave(self):
    """
        return a list of segment
    """
    objEnt=[]
    self.CalculatePoint()
    if len(self.__xpts):
        # find starting point ...
        _p0 = Point(self.__xpts[0],self.__ypts[0])
        # make segments for all the points ...
        _p1 = _p0
        for _i in range(1, self.side):
            _x = self.__xpts[_i]
            _y = self.__ypts[_i]
            _pi = Point(_x, _y)
            segArg={"SEGMENT_0":_p1, "SEGMENT_1":_pi}
            objEnt.append(Segment(segArg))
            _p1 = _pi
        # now add closing segment ...
        segArg={"SEGMENT_0":_p1, "SEGMENT_1":_p0}
        objEnt.append(Segment(segArg))
    return  objEnt   
</t>
<t tx="1.20130426141258.2906">def applyCommand(self):
    """
        Create a Polygon from Segments and add it to the kernel.
    """
    self.updateSide()
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2907">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the polyline command
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2908">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.polyline         import Polyline
from Kernel.GeoEntity.point            import Point
</t>
<t tx="1.20130426141258.2909">class PolylineCommand(BaseCommand):
    """
        this class rappresent the polyline command
    """
    @others
</t>
<t tx="1.20130426141258.2910">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint]
    self.defaultValue=[None]
    self.message=["Give Me A Point: "]
    self.raiseStop=False
    self.automaticApply=False #In case of polyline we need to stop the automatic apply
</t>
<t tx="1.20130426141258.2911">def __setitem__(self, key, value):
    """
        overwrite the command to perform the stop operation
    """
    value=self.translateCmdValue(value)
    if isinstance(value, Point):
        self.value.append(value)
        self.exception.append(ExcPoint)
        self.message.append("Give Me A Point")
        self.defaultValue.append(None)
    else:
       self.raiseStop=True
</t>
<t tx="1.20130426141258.2912">def applyCommand(self):
    """
        perform the write of the entity
    """
    i=0
    args={}
    for k in self.value:
       args["POLYLINE_%s"%str(i)]=k
       i+=1
    pline=Polyline(args)
    self.document.saveEntity(pline)
</t>
<t tx="1.20130426141258.2913">@first #!/usr/bin/env python

#
# Copyright (c) 2011 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide a class for the property command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2914">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
</t>
<t tx="1.20130426141258.2915">class PropertyCommand(BaseCommand):
    """
        this class represents the property command
    """
    @others
</t>
<t tx="1.20130426141258.2916">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.autorestart=False
    self.exception=[ExcMultiEntity,ExcDicTuple]
    self.defaultValue=[None]
    self.message=["Select Entities: ", 
                    "Give me the property name and value :('color','green') ", 
                    ]
</t>
<t tx="1.20130426141258.2917">def changeProp(self, _id):    
    """
        change the property at the entity 
    """
    entity=self.document.getEntity(_id)
    style=entity.getInnerStyle()
    style.Derived()
    entity.resetProperty()
    for PropName,PropValue in list(self.value[1].get('property',{}).items()):
        entity.addPropertie(PropName,PropValue)
        #style.setStyleProp(stylePropName,stylePropValue)
    entity.style=self.document.saveEntity(style)   
    self.document.saveEntity(entity)
</t>
<t tx="1.20130426141258.2918">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of input parameter")
    try:
        self.document.startMassiveCreation()
        
        for _id in str(self.value[0]).split(','):
            self.changeProp(_id)
    except Exception as ex:
        raise ex
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2919">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Rectangle command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2920">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point            import Point
from Kernel.GeoEntity.segment          import Segment
</t>
<t tx="1.20130426141258.2921">class RectangleCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2922">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.defaultValue=[None, None]
    self.message=["Give Me the First Corner: ","Give Me the Second Corner: "]
</t>
<t tx="1.20130426141258.2923">def getEntsToSave(self):
    """
        get all the segment of the rectangle
    """
    objEnt=[]
    p1=self.value[0]
    p2=self.value[1]
    x1, y1=p1.getCoords()
    x2, y2=p2.getCoords()
    p3=Point(x1, y2)
    p4=Point(x2, y1)
    segArg={"SEGMENT_0":p1, "SEGMENT_1":p4}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p4, "SEGMENT_1":p2}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p2, "SEGMENT_1":p3}
    objEnt.append(Segment(segArg))
    segArg={"SEGMENT_0":p3, "SEGMENT_1":p1}
    objEnt.append(Segment(segArg))
    return objEnt
</t>
<t tx="1.20130426141258.2924">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.getEntsToSave():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2925">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the rotate command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2926">import math

from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2927">class RotateCommand(BaseCommand):
    """
        this class rappresent the rotate command
    """
    @others
</t>
<t tx="1.20130426141258.2928">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcMultiEntity,
                    ExcPoint, 
                    ExcAngle, 
                    ExcText]
    self.defaultValue=[None, None, math.pi/2, "M"]
    self.message=[  "Select Entities: ", 
                    "Give me the Rotation Center Point: ", 
                    "Give me the rotation angle [rad]: ", 
                    "Move or Copy? [M]: "]
</t>
<t tx="1.20130426141258.2929">def performRotation(self):
    """
        perform the mirror of all the entity selected
    """
    copy=True
    if self.value[3]:
        if self.value[3].upper()=='M':
            copy=False
    updEnts=[]
    for id in str(self.value[0]).split(','):
        dbEnt=self.document.getEntity(id)
        geoEnt=self.document.convertToGeometricalEntity(dbEnt)
        geoEnt.rotate(self.value[1], self.value[2])
        if not copy:
            dbEnt.setConstructionElements(geoEnt.getConstructionElements())
            updEnts.append(dbEnt)
        else:
            updEnts.append(geoEnt)
    return updEnts
</t>
<t tx="1.20130426141258.2930">def applyCommand(self):
    """
        perform the write of the entity
    """
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    try:
        self.document.startMassiveCreation()
        for _ent in self.performRotation():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2931">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2932">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.segment       import Segment
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.2933">class SegmentCommand(BaseCommand):
    """
        this class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2934">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcPoint]
    self.message=["Give Me the First Point: ","Give Me The Second Point: "]
    self.defaultValue=[None, None]
</t>
<t tx="1.20130426141258.2935">def applyCommand(self):
    if len(self.value)!=2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    segArg={"SEGMENT_0":self.value[0], "SEGMENT_1":self.value[1]}
    seg=Segment(segArg)
    self.document.saveEntity(seg)
</t>
<t tx="1.20130426141258.2936">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2937">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity.text             import Text
</t>
<t tx="1.20130426141258.2938">class TextCommand(BaseCommand):
    """
        This class rappresent the segment command
    """
    @others
</t>
<t tx="1.20130426141258.2939">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcPoint, ExcText, ExcAngle,ExcText ]
    self.defaultValue=[None, "Dummy Text", 0, "sw"]
    self.message=["Give Me the Insert Point: ",
                    "Type The Text String: ",
                    "Give Me The Rotation Angle [0]: ", 
                    "Give me a Point to Justify Text [sw]: "]
</t>
<t tx="1.20130426141258.2940">def applyCommand(self):
    if len(self.value)!=4:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    textArgs={"TEXT_0":self.value[0], "TEXT_1":self.value[1], "TEXT_2":self.value[2], "TEXT_3":self.value[3]}
    text=Text(textArgs)
    self.document.saveEntity(text)
</t>
<t tx="1.20130426141258.2941">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the Trim command
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2942">from Kernel.exception               import *
from Kernel.Command.basecommand     import *
from Kernel.GeoEntity               import *
from Kernel.GeoEntity.segment       import Segment
from Kernel.GeoUtil.intersection    import *
from Kernel.GeoUtil.util            import *
</t>
<t tx="1.20130426141258.2943">class TrimCommand(BaseCommand):
    """
        this class represent the Trim command
    """
    @others
</t>
<t tx="1.20130426141258.2944">def __init__(self, document):
    BaseCommand.__init__(self, document)
    self.exception=[ExcEntityPoint,
                    ExcEntityPoint,  
                    ExcText]
    self.defaultValue=[None, None,"BOTH"]
    self.message=[  "Give me the First Entity: ", 
                    "Give me the Second Entity: ",
                    "Give me The Trim Mode (First,Second,Both)[Both]: "]
</t>
<t tx="1.20130426141258.2945">def performTrim(self):
    """
        get the chamfer segments
    """
    id0, p0=self.value[0]
    id1, p1=self.value[1]
    
    updEnts=[]
    geoEnt1=self.document.getEntity(id0)
    seg1=geoEnt1.toGeometricalEntity()
    geoEnt2=self.document.getEntity(id1)
    seg2=geoEnt2.toGeometricalEntity()
    intPoint=findSegmentExtendedIntersectionPoint(seg1, seg2)
    if len(intPoint)&lt;=0:
        raise PythopnCadWarning("No intersection Found") 
    
    def getNearestPoint(pointArray, referencePoint):              
        distance=None
        exitPoint=None
        for p in pointArray:
            if distance==None:
                distance=p.dist(referencePoint)
                exitPoint=p
                continue
            else:
                newDistance=p.dist(exitPoint)
                if newDistance&lt;distance:
                    distance=newDistance
                    exitPoint=p
        return exitPoint 
        
    def getSegmentCelements(obj, pickPoint, intersectionPoint):
        if isinstance(obj, Segment):
            geoEntTrim=None
            geoEntTrim=updateSegment(obj, pickPoint, intersectionPoint)
            _cElements, entityType=self.document._getCelements(geoEntTrim)
            return _cElements
        else:
            return None
        
    if self.value[2].upper()=='FIRST' or self.value[2].upper()=='F' or self.value[2].upper()=='BOTH' or self.value[2].upper()=='B':
        nearestIntersectionPoint=getNearestPoint(intPoint, p0)
        if nearestIntersectionPoint!=None:
            _cElements=getSegmentCelements(seg1, p0,nearestIntersectionPoint)
            if _cElements!= None:
                geoEnt1.setConstructionElements(_cElements)
                updEnts.append(geoEnt1)
        
    if self.value[2].upper()=='SECOND' or self.value[2].upper()=='S' or self.value[2].upper()=='BOTH' or self.value[2].upper()=='B':
        nearestIntersectionPoint=getNearestPoint(intPoint, p1)
        if nearestIntersectionPoint!=None:
            _cElements=getSegmentCelements(seg2, p1,nearestIntersectionPoint)
            if _cElements!= None:
                geoEnt2.setConstructionElements(_cElements)
                updEnts.append(geoEnt2)
    return updEnts
</t>
<t tx="1.20130426141258.2946">def applyCommand(self):
    """
        apply the trim command
    """
    if len(self.value)&lt;2:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    if len(self.value)==2:
        self.value.append("BOTH")   # TODO: MAKE A GLOBAL VARIABLE TO SET THIS VALUE
                                    # AS A SETTING VALUE
    try:
        self.document.startMassiveCreation()
        for _ent in self.performTrim():
            self.document.saveEntity(_ent)
    finally:
        self.document.stopMassiveCreation()
</t>
<t tx="1.20130426141258.2947">#
# Copyright (c) 2010 Matteo Boscolo
#

#
# this file is needed for Python's import mechanism
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2948">from Kernel.GeoEntity.arc               import Arc
from Kernel.GeoEntity.cline             import CLine
from Kernel.GeoEntity.ellipse           import Ellipse
from Kernel.GeoEntity.ccircle           import CCircle
from Kernel.GeoEntity.polyline          import Polyline
from Kernel.GeoEntity.segment           import Segment
from Kernel.GeoEntity.text              import Text
</t>
<t tx="1.20130426141258.2949"></t>
<t tx="1.20130426141258.2950">#encoding: utf-8
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module provide access to the basic operation on pythoncad database
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2951">import os
import sys
import tempfile
import sqlite3 as sql

from Kernel.exception import *
</t>
<t tx="1.20130426141258.2952">class BaseDb(object):
    """
        this class provide base db operation
    """
    commit=True
    @others
</t>
<t tx="1.20130426141258.2953">def __init__(self):
    self.__dbConnection=None
    self.dbPath=None
</t>
<t tx="1.20130426141258.2954">def createConnection(self,dbPath=None):
    """
        create the connection with the database
    """
    if dbPath is None:
        f=tempfile.NamedTemporaryFile(prefix='PyCad_', suffix='.pdr')
        dbPath=f.name
        f.close()
    self.__dbConnection = sql.connect(str(dbPath))
    self.dbPath=dbPath
</t>
<t tx="1.20130426141258.2955">def setConnection(self,dbConnection):
    """
        set the connection with the database
    """
    if not self.__dbConnection is None:
        # Todo fire a warning
        self.__dbConnection.close()
    self.__dbConnection=dbConnection
</t>
<t tx="1.20130426141258.2956">def getConnection(self):
    """
        Get The active connection
    """
    return self.__dbConnection
</t>
<t tx="1.20130426141258.2957">def makeSelect(self,statment):
    """
        perform a select operation
    """
    try:
        _cursor = self.__dbConnection.cursor()
        _rows = _cursor.execute(statment)
    except sql.Error as _e:
        msg="Sql Phrase: %s"%str(statment)+"\nSql Error: %s"%str( _e.args[0] )
        raise StructuralError(msg)
    except :
        for s in sys.exc_info():
            print("Generic Error: %s"%str(s))
        raise StructuralError
    #_cursor.close()
    return _rows
</t>
<t tx="1.20130426141258.2958">def fetchOneRow(self,sqlSelect, tupleArgs=None):
    """
        get the first row of the select
    """
    try:
        _cursor = self.__dbConnection.cursor()
        if tupleArgs:
            _rows = _cursor.execute(sqlSelect,tupleArgs )
        else:
            _rows = _cursor.execute(sqlSelect)
    except sql.Error as _e:
        msg="Sql Phrase: %s"%str(sqlSelect)+"\nSql Error: %s"%str( _e.args[0] )
        raise StructuralError(msg)
    except :
        for s in sys.exc_info():
            print("Generic Error: %s"%str(s))
        raise StructuralError
    _row=_rows.fetchone()
    _cursor.close()
    if _row is None or _row[0] is None:
        return None
    return _row[0]
</t>
<t tx="1.20130426141258.2959">def makeUpdateInsert(self,statment, tupleArgs=None):
    """
        make an update Inster operation
    """
    #print "qui1 : sql ",statment
    try:
        _cursor = self.__dbConnection.cursor()
        if tupleArgs:
            _rows = _cursor.execute(statment,tupleArgs )
        else:
            _rows = _cursor.execute(statment)
        #if self.__commit:
        if BaseDb.commit:
            self.performCommit()
            _cursor.close()
    except sql.Error as _e:
        msg="Sql Phrase: %s"%str(statment)+"\nSql Error: %s"%str( _e.args[0] )
        raise sql.Error(msg)
    except :
        for s in sys.exc_info():
            print("Generic Error: %s"%str(s))
        raise KeyError
</t>
<t tx="1.20130426141258.2960">def close(self):
    """
        close the database connection
    """
    self.__dbConnection.close()
</t>
<t tx="1.20130426141258.2961">def suspendCommit(self):
    """
        suspend the commit in the update\insert
    """
    #self.__commit=False
    BaseDb.commit=False
</t>
<t tx="1.20130426141258.2962">def reactiveCommit(self):
    """
        reactive the commit in the update\insert
    """
    #self.__commit=True
    BaseDb.commit=True
</t>
<t tx="1.20130426141258.2963">def performCommit(self):
    """
        perform a commit
    """
    try:
        self.__dbConnection.commit()
    except:
        print("Error on commit")
</t>
<t tx="1.20130426141258.2964">#encoding: UTF-8
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic operation for the entity in the pythoncad database
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2965">import pickle as pickle

from Kernel.entity              import *
from Kernel.Db.basedb           import BaseDb
from Kernel.initsetting         import *
from Kernel.exception           import *
</t>
<t tx="1.20130426141258.2966">class EntityDb(BaseDb):
    """
        this class provide the besic operation for the entity
    """
    @others
</t>
<t tx="1.20130426141258.2967">def __init__(self,dbConnection):
    BaseDb.__init__(self)
    self._entFields={
                'pycad_id':'INTEGER PRIMARY KEY',
                'pycad_entity_id':'INTEGER',
                'pycad_object_type':'TEXT',
                'pycad_object_definition':'TEXT',
                'pycad_object_style':'TEXT',
                'pycad_security_id':'INTEGER',
                'pycad_undo_id':'INTEGER',
                'pycad_entity_state':'TEXT',
                'pycad_index':'NUMERIC',
                'pycad_visible':'INTEGER',
                'pycad_undo_visible':'INTEGER',
                'pycad_locked':'INTEGER',
                'pycad_bbox_xmin':'REAL',
                'pycad_bbox_ymin':'REAL',
                'pycad_bbox_xmax':'REAL',
                'pycad_bbox_ymax':'REAL',
                'pycad_property':'TEXT'
                     }
    def creationFieldsStr():
        outStr=''
        for fieldName,fieldValue in list(self._entFields.items()):
            outStr+='%s %s,'%(str(fieldName),str(fieldValue))
        return outStr[:-1]
    
    def addTableField(fieldName,fieldType):
        sql="ALTER TABLE pycadent ADD COLUMN %s %s "%(str(fieldName),str(fieldType))
        self.makeUpdateInsert(sql)
        
    if dbConnection is None:
        self.createConnection()
    else:
        self.setConnection(dbConnection)
    _sqlCheck="""select * from sqlite_master where name like 'pycadent'"""
    _table=self.makeSelect(_sqlCheck).fetchone()
    if _table is None:
        _sqlCreation="""CREATE TABLE pycadent(
                %s)"""%creationFieldsStr()
        self.__revisionIndex=0
        self.makeUpdateInsert(_sqlCreation)
    else:
        rows=self.makeSelect("pragma table_info('pycadent')")
        dbColumns=dict([(row[1],row[2]) for row in rows])
        for classColumn in list(self._entFields.keys()):
            if not classColumn in dbColumns:
                addTableField(classColumn,self._entFields[classColumn])
        self.__revisionIndex=self.getRevisionIndex()
</t>
<t tx="1.20130426141258.2968">def getRevisionIndex(self):
    """
        get the revision index from the database
    """
    _sql="""SELECT max(pycad_index) From pycadent"""
    index=self.fetchOneRow(_sql)
    if index is None: return 0
    return index
</t>
<t tx="1.20130426141258.2969">def increaseRevisionIndex(self):
    """
        increase the relesed index
    """
    self.__revisionIndex+=1
</t>
<t tx="1.20130426141258.2970">def decreseRevisionIndex(self):
    """
        decrese the revision index
    """
    self.__revisionIndex-=1
</t>
<t tx="1.20130426141258.2971">def saveEntity(self,entityObj,undoId):
    """
        this method save the entity in the db
        entityObj = object that we whant to store
    """
    _entityId=entityObj.getId()
    _entityDump=pickle.dumps(entityObj.getConstructionElements())
    _entityType=entityObj.getEntityType()
    _property=pickle.dumps(entityObj.properties)
    _entityVisible=entityObj.visible
    _styleObject=pickle.dumps(entityObj.style)
    _xMin,_yMin,_xMax,_yMax=entityObj.getBBox()
    _revisionIndex=self.__revisionIndex
    _revisionState=entityObj.state
    _sqlInsert="""INSERT INTO pycadent (
                pycad_entity_id,
                pycad_object_type,
                pycad_object_definition,
                pycad_object_style,
                pycad_undo_id,
                pycad_undo_visible,
                pycad_bbox_xmin,
                pycad_bbox_ymin,
                pycad_bbox_xmax,
                pycad_bbox_ymax,
                pycad_entity_state,
                pycad_index,
                pycad_visible,
                pycad_property) VALUES
                (?,?,?,?,?,1,?,?,?,?,?,?,?,?)"""
    # _entity_Dump and  _styleObject changed from TEXT to BLOB for py3
    tupleArg=(
                _entityId,
                _entityType,
                _entityDump,
                _styleObject,
                undoId,
                _xMin,
                _yMin,
                _xMax,
                _yMax, 
                _revisionState,
                _revisionIndex, 
                _entityVisible,
                _property)
    self.makeUpdateInsert(_sqlInsert, tupleArg)
</t>
<t tx="1.20130426141258.2972">def getEntityFromTableId(self,entityTableId):
    """
        Get the entity object from the database Univoc id
    """
    _outObj=None
    _sqlGet="""SELECT   pycad_entity_id,
                        pycad_object_type,
                        pycad_object_definition,
                        pycad_object_style,
                        pycad_entity_state,
                        pycad_index,
                        pycad_visible,
                        pycad_property
            FROM pycadent
            WHERE pycad_id=%s"""%str(entityTableId)
    _rows=self.makeSelect(_sqlGet)
    if _rows is not None:
        _row=_rows.fetchone()
        if _row is not None:
            _style=pickle.loads(_row[3])
            _dumpObj=pickle.loads(_row[2])
            _outObj=Entity(_row[1],_dumpObj,_style,_row[0])
            _outObj.state=_row[4]
            _outObj.index=_row[5]
            _outObj.visible=_row[6]
            for name,value in pickle.loads(_row[7]):
                _outObj.addPropertie(name, value)
            _outObj.updateBBox()
    return _outObj
</t>
<t tx="1.20130426141258.2973">def getEntityEntityId(self,entityId):
    """
        get all the entity with the entity id
    """
    _outObj=None
    _sqlGet="""SELECT   pycad_id,
                        pycad_entity_id,
                        pycad_object_type,
                        pycad_object_definition,
                        pycad_object_style,
                        pycad_entity_state,
                        pycad_index,
                        pycad_visible,
                        pycad_property
            FROM pycadent
            WHERE pycad_entity_id=%s ORDER BY  pycad_id DESC"""%str(entityId)
    _dbEntRow=self.makeSelect(_sqlGet)
    if _dbEntRow is not None:
        _row=_dbEntRow.fetchone()
        _style=pickle.loads(_row[4])
        _dumpObj=pickle.loads(_row[3])
        _entObj=Entity(_row[2],_dumpObj,_style,_row[1])       
        _entObj.state=_row[5]
        _entObj.index=_row[6]
        _entObj.visible=_row[7]
        for name,value in pickle.loads(_row[8]):
            _entObj.addPropertie(name, value)
        _entObj.updateBBox()
    return _entObj
</t>
<t tx="1.20130426141258.2974">def getEntitysFromStyle(self,styleId):
    """
        return all the entity that match the styleId
    """
    return
    #
    # This function need to be redefined
    # the new style system is changed
    #
    _outObj=[]
    _sqlGet="""SELECT   pycad_id,
                        pycad_entity_id,
                        pycad_object_type,
                        pycad_object_definition,
                        pycad_object_style,
                        pycad_entity_state,
                        pycad_index,
                        pycad_visible,
                        pycad_property
                FROM pycadent
                WHERE PyCad_Id IN (
                    SELECT max(PyCad_Id) 
                    FROM pycadent  
                    WHERE pycad_undo_visible=1 
                    GROUP BY pycad_entity_id ORDER BY PyCad_Id)
                AND pycad_object_style=%s"""%str(styleId)
    _dbEntRow=self.makeSelect(_sqlGet)
    for _row in _dbEntRow: 
        _style=_row[4]
        _dumpObj=pickle.loads(_row[3])
        _objEnt=Entity(_row[2],_dumpObj,_style,_row[1])
        _objEnt.state=_row[5]
        _objEnt.index=_row[6]
        _objEnt.visible=_dbEntRow[7]
        for name,value in pickle.loads(_row[9]):
            _objEnt.addPropertie(name, value)
        _objEnt.updateBBox()            
        _outObj.append(_objEnt)
    return _outObj
</t>
<t tx="1.20130426141258.2975">def _getEntInVersion(self, versionIndex):
    """
        get entity in version
    """
    #TODO: to be tested
    _sqlGet="""SELECT pycad_id,
                pycad_entity_id,
                pycad_object_type,
                pycad_object_definition,
                pycad_object_style,
                pycad_entity_state,
                pycad_index,
                pycad_visible,
                pycad_property
                FROM pycadent
                WHERE PyCad_Id IN (
                    SELECT max(PyCad_Id) 
                    FROM pycadent  
                    WHERE pycad_undo_visible=1 
                    GROUP BY pycad_entity_id ORDER BY PyCad_Id)
                AND pycad_entity_state NOT LIKE "DELETE"
                AND pycad_index = %s
                """%str(versionIndex)
    return self.makeSelect(_sqlGet)
</t>
<t tx="1.20130426141258.2976">def getMultiFilteredEntity(self, visible=1, entityType='ALL', entityTypeArray=None):
    """
        get all visible entity
    """  
    if entityTypeArray:
        isFirst=1
        for t in entityTypeArray:
            if isFirst:
                entityTypes="""AND (pycad_object_type like '%s'"""%str(t)
                isFirst=0
            else:
                entityTypes="""%s OR pycad_object_type like '%s'"""%(str(entityTypes), str(t))
        else:
            entityTypes=entityTypes+")"
    else:
        if entityType=='ALL':
            entityTypes="""AND pycad_object_type like '%'"""
        else:
            entityTypes="""AND pycad_object_type like '%s'"""%str(entityType)
            if not entityType in PY_CAD_ENT:
                raise TypeError("Entity type %s not supported from the dbEnt"%str(entityType))  
    # object_style 與 object_definition changed from TEXT to BLOB for py3
    _sqlGet="""SELECT pycad_id,
                pycad_entity_id,
                pycad_object_type,
                pycad_object_definition,
                pycad_object_style,
                pycad_entity_state,
                pycad_index,
                pycad_visible,
                pycad_property
                FROM pycadent
                WHERE pycad_id IN (
                    SELECT max(pycad_id) 
                    FROM pycadent  
                    WHERE pycad_undo_visible=1  
                    GROUP BY pycad_entity_id ORDER BY pycad_id)
                AND pycad_entity_state NOT LIKE "DELETE"
                AND pycad_visible =%s
                %s
                """%(str(visible), str(entityTypes))
    return self.makeSelect(_sqlGet)   
</t>
<t tx="1.20130426141258.2977">def getEntityFromType(self,entityType):
    """
        get all the entity from a given type 
    """
    _outObj=[]
    _dbEntRow=self.getMultiFilteredEntity(entityType=entityType)
    for _row in _dbEntRow: 
        _style=pickle.loads(_row[4])
        _dumpObj=pickle.loads(_row[3])
        _objEnt=Entity(_row[2],_dumpObj,_style,_row[1])
        _objEnt.state=_row[5]
        _objEnt.index=_row[6]
        _objEnt.visible=_row[7]
        if _row[8]!=None:
            for name,value in pickle.loads(_row[8]):
                _objEnt.addPropertie(name, value)
            _objEnt.updateBBox()            
        _outObj.append(_objEnt)
    return _outObj            
</t>
<t tx="1.20130426141258.2978">def getEntityFromTypeArray(self, typeArray):
    """
        get entitys from an array of type
    """
    _outObj=[]
    _dbEntRow=self.getMultiFilteredEntity(entityTypeArray=typeArray)
    for _row in _dbEntRow: 
        _objEnt=self.convertRowToDbEnt(_row)            
        _outObj.append(_objEnt)
    return _outObj  
</t>
<t tx="1.20130426141258.2979">def convertRowToDbEnt(self, row):
    """
        this function convert a single db row in a dbEnt Object
        the row mast be a row from the pycadent table with the following column order
        pycad_id,
        pycad_entity_id,
        pycad_object_type,
        pycad_object_definition,
        pycad_object_style,
        pycad_entity_state,
        pycad_index,
        pycad_visible,
        pycad_property
        FROM pycadent
    """
    _style=pickle.loads(row[4])
    _dumpObj=pickle.loads(row[3])
    _objEnt=Entity(row[2],_dumpObj,_style,row[1])
    _objEnt.state=row[5]
    _objEnt.index=row[6]
    _objEnt.visible=row[7]
    if row[8]!=None:
        for name,value in pickle.loads(row[8]):
                _objEnt.addPropertie(name, value)
    _objEnt.updateBBox()  
    return _objEnt
</t>
<t tx="1.20130426141258.2980">def exsisting(self, id):    
    """
        check id the entity is new or is olready in the database
    """
    sqlFrase="""
                SELECT COUNT(*) FROM pycadent 
                WHERE pycad_entity_id=%s"""%str(id)
    _rows=self.makeSelect(sqlFrase)
    if _rows is not None:
        _row=_rows.fetchone()
        if _row is not None:
            return True
    return False
</t>
<t tx="1.20130426141258.2981">def haveDrwEntitys(self, drwEntArray):
    """
        check if there is some drawing entity in the db
        drwArray mast be an erray of type entitys
    """
    isFirst=1
    for ent in drwEntArray:
        if isFirst:
            whereCause="where pycad_object_type like '%s'"%str(ent)    
            isFirst=0
        else:
            whereCause="%s or pycad_object_type like '%s'"%(str(whereCause), str(ent))
    else:
        try:
            sqlSelect="""select count(*) from pycadent %s"""%str(whereCause)
        except:
            return 0
        return self.fetchOneRow(sqlSelect)&gt;0
    return 0
</t>
<t tx="1.20130426141258.2982">def getNewEntId(self):
    """
        get the last id entity 
    """
    _outObj=0
    _sqlSelect="""select max(pycad_entity_id) from pycadent"""
    _rows=self.makeSelect(_sqlSelect)
    if _rows is not None:
        _dbEntRow=_rows.fetchone()
        if _dbEntRow is not None:
            if _dbEntRow[0] is not None:
                _outObj=int(_dbEntRow[0])
    return _outObj
</t>
<t tx="1.20130426141258.2983">def markUndoVisibility(self,undoId,visible):
    """
        set as undo visible all the entity with undoId
    """
    _sqlVisible="""UPDATE pycadent SET pycad_undo_visible=%s
                WHERE pycad_undo_id=%s"""%(str(visible),str(undoId))
    self.makeUpdateInsert(_sqlVisible)
</t>
<t tx="1.20130426141258.2984">def markUndoVisibilityFromEntId(self, entityId, visible):
    """
        set the undo visibility to for all the entity
    """
    _sqlVisible="""UPDATE pycadent SET pycad_undo_visible=%s
                WHERE pycad_entity_id=%s"""%(str(visible),str(entityId))
    try:
        self.makeUpdateInsert(_sqlVisible)
    except:
        # may be the update culd fail in case we create the first entity
        return
</t>
<t tx="1.20130426141258.2985">def markEntVisibility(self,entId,visible):
    """
        mark the visibility of the entity
    """
    _tableId="""SELECT MAX(pycad_id) FROM pycadent 
                WHERE pycad_entity_id=%s"""%str(entId)
    _entId=self.fetchOneRow(_tableId)
    if _entId is None:
        raise EmptyDbSelect("Unable to find the entity with id %s"%str(entId))
    # Update the entity state
    _sqlVisible="""UPDATE pycadent SET pycad_undo_visible=%s
                WHERE pycad_id=%s"""%(str(visible),str(_entId))
    self.makeUpdateInsert(_sqlVisible) 
</t>
<t tx="1.20130426141258.2986">def hideAllEntityIstance(self,entId,visible):
    """
        hide all the row with entId
    """
    _sqlVisible="""UPDATE pycadent SET pycad_undo_visible=%s
                WHERE pycad_entity_id=%s"""%(str(visible),str(entId))
    self.makeUpdateInsert(_sqlVisible)      
</t>
<t tx="1.20130426141258.2987">def delete(self,tableId):
    """
        delete the entity from db
    """
    _sqlDelete="""DELETE FROM pycadent 
                    WHERE pycad_id=%s"""%str(tableId)
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.2988">def uptateEntity(self, entityObj):
    """
        Update an exsisting entity in the database 
        *************************Attention*********************************
        Remarks : using this function you will loose the undo history.
        Remarks : with this function you will force to update all the value
        so you can update value on released entity .
        Remarks : use this function only internaly at the kernel .
        *******************************************************************
    """    
    #toto : test update function
    _entityId=entityObj.getId()
    _entityDump=pickle.dumps(entityObj.getConstructionElements(), protocol=2, fix_imports=True)
    _entityType=entityObj.getEntityType()
    _entityVisible=entityObj.visible
    _styleObject=pickle.dumps(entityObj.style, protocol=2, fix_imports=True)
    _xMin,_yMin,_xMax,_yMax=entityObj.getBBox()
    _revisionIndex=entityObj.index
    _revisionState=entityObj.state
    _property=pickle.dumps(entityObj.property, protocol=2, fix_imports=True)
    _sqlInsert="""UPDATE pycadent set 
                pycad_object_type="%s",
                pycad_object_definition="%s",
                pycad_object_style=%s,
                pycad_bbox_xmin=%s,
                pycad_bbox_ymin=%s,
                pycad_bbox_xmax=%s,
                pycad_bbox_ymax=%s,
                pycad_entity_state="%s",
                pycad_index=%s,
                pycad_visible=%s,
                pycad_property=%s
                WHERE PyCad_Id IN (
                    SELECT max(PyCad_Id) 
                    FROM pycadent  
                    WHERE pycad_undo_visible=1 
                    GROUP BY pycad_entity_id ORDER BY PyCad_Id) 
                AND pycad_entity_id=%s
                """%(
                str(_entityType),
                str(_entityDump),
                str(_styleObject),
                str(_xMin),
                str(_yMin),
                str(_xMax),
                str(_yMax), 
                str(_revisionState),
                str(_revisionIndex), 
                str(_entityVisible), 
                str(_entityId),
                str(_property))
    #**************************************
    #**************Attention***************
    #**************************************
    #if dose not work conver it with ? insted of %s
    #and use the  self.makeUpdateInsert(_sqlInsert,tupleargs)
    self.makeUpdateInsert(_sqlInsert)
</t>
<t tx="1.20130426141258.2989">def clearEnt(self):
    """
        perform the clear of all the entity that are not in the release state
    """
    _sql="""
            SELECT pycad_id 
            FROM pycadent
            WHERE pycad_entity_state NOT LIKE "RELEASED"
        """
    _rows=self.makeSelect(_sql)   
    for _row in _rows: 
        self.delete(_row[0])
</t>
<t tx="1.20130426141258.2990">#encoding: utf-8
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic pythoncadObject
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.2991">from Kernel.GeoEntity.style             import Style
from Kernel.exception                   import EntityMissing
</t>
<t tx="1.20130426141258.2992">class PyCadObject(object):
    """
        This class provide basic information for all the pythoncad object 
    """
    @others
    eType=property(getEntityType,setEntType,None,"Get/Set the etity type ")
</t>
<t tx="1.20130426141258.2993">def __init__(self,objId,style,eType,properties={}):
    from Kernel.initsetting import OBJECT_STATE
    self.OBJECT_STATE=OBJECT_STATE
    self.__entityId=objId
    self.__state="MODIFIE"
    self._index=0
    self.__visible=1
    self.__style=style
    self.__entType=eType
    self.__properties=properties
</t>
<t tx="1.20130426141258.2994">def addPropertie(self,name,value):
    """
        add a properties to the object
    """
    self.__properties[name]=value
</t>
<t tx="1.20130426141258.2995">def getPropertie(self,name):
    """
        get the properties with a given name
    """
    if name in self.__properties:
        return self.__properties[name]
    raise EntityMissing("No entity with name %s"%str(name))
</t>
<t tx="1.20130426141258.2996">def resetProperty(self):
    """
        reset the property 
    """
    self.__properties={}
</t>
<t tx="1.20130426141258.2997">@property
def properties(self):
    """
        get all the properties from the entity
    """
    return self.__properties
</t>
<t tx="1.20130426141258.2998">def setVisible(self, visible):
    """
        set the visible value
    """
    self.__visible=visible
</t>
<t tx="1.20130426141258.2999">def getVisible(self):
    """
        get the visible value
    """
    return self.__visible
</t>
<t tx="1.20130426141258.3000">visible=property(getVisible, setVisible, None,"Set/Get the entity visibiolity")

def getId(self):
    """
        get the entity id
    """
    return self.__entityId
</t>
<t tx="1.20130426141258.3001">def getState(self):
    """
        get the active entity state
    """
    return self.__state
</t>
<t tx="1.20130426141258.3002">def setState(self, state):
    """
        set the active state
    """ 
    if state in self.OBJECT_STATE:
        self.__state=state
    else:
        print("Wrong argunent")
        raise 
</t>
<t tx="1.20130426141258.3003">state=property(getState, setState, None, "Get/Set the state of the entity")

def getIndex(self):
    """
        get the index of the revision index of the current object
    """
    return self._index
</t>
<t tx="1.20130426141258.3004">def getNewIndex(self):
    """
        Get the new index of the current entity
    """
    if self._index:
        self._index+=self._index
        self.__state=self.OBJECT_STATE[0]
    else: 
        self._index=0
        self.__state=self.OBJECT_STATE[0]
</t>
<t tx="1.20130426141258.3005">def setIndex(self,index):
    """
        Set The index of the entity
    """
    if index:
        self._index=index
</t>
<t tx="1.20130426141258.3006">index=property(getIndex, setIndex, "Get The new index of the current entity")

def delete(self):
    """
        mark the entity to delete
    """
    self.__state='DELETE'
</t>
<t tx="1.20130426141258.3007">def relese(self):
    """
        mark the entity as released
    """
    self.__state='RELEASED'
</t>
<t tx="1.20130426141258.3008">def getStyle(self):
    """
        get the object EntityStyle
    """
    return self.__style
</t>
<t tx="1.20130426141258.3009">def setStyle(self,style):
    """
        set/update the entitystyle
    """
    self.__style=style
</t>
<t tx="1.20130426141258.3010">style=property(getStyle,setStyle,None,"Get/Set the entity style")

def getInnerStyle(self):
    """
        return the inner style of type Style
    """
    if self.style!=None:
        styleEnt=self.style.getConstructionElements() 
        return styleEnt[list(styleEnt.keys())[0]]
    else:
        return None
</t>
<t tx="1.20130426141258.3011">def setEntType(self, type):
    """
        Set the entity type
    """
    self.__entType=type
</t>
<t tx="1.20130426141258.3012">def getEntityType(self):
    """
        Get the entity type
    """
    return self.__entType
</t>
<t tx="1.20130426141258.3013">#encoding: utf-8
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic operation for the Relation in the pythoncad database
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
"""
    TODO TEST deleteFromChild
    TODO TEST deleteRelation
"""
</t>
<t tx="1.20130426141258.3014">import pickle as pickle

from Kernel.entity          import Entity
from Kernel.Db.basedb       import BaseDb
</t>
<t tx="1.20130426141258.3015">class RelationDb(BaseDb):
    """
        this class provide the besic operation for the relation
    """
    @others
</t>
<t tx="1.20130426141258.3016">def __init__(self,dbConnection=None):
    BaseDb.__init__(self)
    if dbConnection is None:
        self.createConnection()
    else:
        self.setConnection(dbConnection)

    _sqlCheck="""select * from sqlite_master where name like 'pycadrel'"""
    _table=self.makeSelect(_sqlCheck).fetchone()
    if _table is None:
        _sqlCreation="""CREATE TABLE pycadrel(
                "pycad_id" INTEGER PRIMARY KEY,
                "pycad_parent_id" INTEGER,
                "pycad_child_id" INTEGER
                )"""
        self.makeUpdateInsert(_sqlCreation)
</t>
<t tx="1.20130426141258.3017">def saveRelation(self,parentEntObj,childEntObj):
    """
        This method save the Relation in the db
        TODO  : THE RELATION MAST BE UNIVOC ...
    """
    _parentEntityId=parentEntObj.getId()
    _childEntityId=childEntObj.getId()
    _sqlInsert="""INSERT INTO pycadrel (
                  pycad_parent_id,
                  pycad_child_id
                  ) VALUES
                  (%s,"%s")"""%(
                str(_parentEntityId),
                str(_childEntityId))
    self.makeUpdateInsert(_sqlInsert)
</t>
<t tx="1.20130426141258.3018">def getChildrenIds(self,entityParentId):
    """
        Get the children id of a relation
    """
    _outObj=[]
    _sqlGet="""SELECT pycad_child_id
            FROM pycadrel
            WHERE pycad_parent_id=%s"""%str(entityParentId)
    _rows=self.makeSelect(_sqlGet)
    _dbEntRow=self.makeSelect(_sqlGet)
    if _dbEntRow is not None:
        for _row in _dbEntRow:
            _outObj.append(_row[0])
    return _outObj
</t>
<t tx="1.20130426141258.3019">def getAllChildrenType(self, parent, childrenType=None):
    """
        get all the children entity of type childrenType
    """
    _outObj=[]
    if not childrenType:
        childrenType='%'
    if childrenType=='ALL':
        childrenType='%' # TODO : controllare questa select pycad_id,
    _sqlSelect="""SELECT 
                        pycad_entity_id,
                        pycad_object_type,
                        pycad_object_definition,
                        pycad_object_style,
                        pycad_entity_state,
                        pycad_index,
                        pycad_visible,
                        pycad_id
                        FROM pycadent
                        WHERE pycad_entity_id IN
                            (
                                SELECT pycad_child_id
                                FROM pycadrel
                                WHERE pycad_parent_id =%s
                            )
                        AND pycad_id IN (
                            SELECT max(pycad_id) 
                            FROM pycadent  
                            WHERE pycad_undo_visible=1  
                            GROUP BY pycad_entity_id ORDER BY pycad_id)
                        AND pycad_entity_state NOT LIKE "DELETE"
                        AND pycad_object_type LIKE '%s'
                        AND pycad_undo_visible=1
                        """%(str(parent.getId()), str(childrenType))
    _dbEntRow=self.makeSelect(_sqlSelect)
    for _row in _dbEntRow:
        _style=pickle.loads(_row[3])
        _dumpObj=pickle.loads(_row[2])
        _objEnt=Entity(_row[1],_dumpObj,_style,_row[0])
        _objEnt.state=_row[4]
        _objEnt.index=_row[5]
        _objEnt.visible=_row[6]
        _objEnt.updateBBox()
        _outObj.append(_objEnt)

    return _outObj
</t>
<t tx="1.20130426141258.3020">def getParentEnt(self,entity):
    """
        get the parent entity
        TODO: To be tested
    """
    _sqlSelect="""SELECT pycad_entity_id,
                        pycad_object_type,
                        pycad_object_definition,
                        pycad_object_style,
                        pycad_entity_state,
                        pycad_index,
                        pycad_visible
                        FROM pycadent
                        WHERE pycad_entity_id IN
                            (
                                SELECT pycad_parent_id
                                FROM pycadrel
                                WHERE pycad_child_id =%s
                            )
                        AND pycad_entity_state NOT LIKE "DELETE"
                        AND pycad_object_type LIKE '%s'
                        AND pycad_undo_visible=1
                        """%(str(entity.getId()), str(entity.eType))

    _dbEntRow=self.makeSelect(_sqlSelect)
    for _row in _dbEntRow:
        _style=pickle.loads(_row[3])
        _dumpObj=pickle.loads(_row[2])
        _objEnt=Entity(_row[1],_dumpObj,_style,_row[0])
        _objEnt.state=_row[4]
        _objEnt.index=_row[5]
        _objEnt.visible=_row[6]
        _objEnt.updateBBox()
        return _objEnt
    return None
</t>
<t tx="1.20130426141258.3021">def deleteFromParent(self,entityObj):
    """
        Delete the entity from db
    """
    _entityId=entityObj.getId()
    _sqlDelete="""DELETE FROM pycadrel
        WHERE pycad_parent_id='%s'"""%str(_entityId)
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.3022">def deleteFromChild(self,entityObj):
    """
        Delete the entity from db
    """
    _entityId=entityObj.getId()
    _sqlDelete="""DELETE FROM pycadrel
        WHERE pycad_child_id='%s'"""%str(_entityId)
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.3023">def deleteRelation(self,entityObjParent,entityObjChild):
    """
        delete the relation from parent and child
    """
    _parentId=entityObjParent.getId()
    _childId=entityObjChild.getId()
    _sqlDelete="""DELETE FROM pycadrel
        WHERE pycad_parent_id='%s' and pycad_child_id='%s'and """%(str(_parentId),str(_childId))
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.3024">def relationExsist(self, parentId, childId):
    """
        check if the given parent child id exsist or not
    """
    _sqlSelect="""SELECT COUNT(*)
                FROM pycadrel
                WHERE pycad_parent_id='%s' and pycad_child_id='%s'
                """%(str(parentId),str(childId))
    res=self.fetchOneRow(_sqlSelect)
    return res
</t>
<t tx="1.20130426141258.3025">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module provide access to the undo part of the pythoncad database
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3026">import sys

from Kernel.Db.basedb           import BaseDb
from Kernel.exception           import UndoDbExc
</t>
<t tx="1.20130426141258.3027">class UndoDb(BaseDb):
    """
        this Class Provide all the basic operation to be made on the
        undo
    """
    @others
</t>
<t tx="1.20130426141258.3028">def __init__(self,dbConnection):
    BaseDb.__init__(self)
    if dbConnection is None:
        self.createConnection()
    else:
        self.setConnection(dbConnection)
    _sqlCheck="""select * from sqlite_master where name like 'pycadundo'"""
    _pycadundoTableRow=self.fetchOneRow(_sqlCheck)
    if _pycadundoTableRow is None:
        _sqlCreation="""CREATE TABLE "pycadundo" (
                            "pycad_id" INTEGER PRIMARY KEY,
                            "pycad_incremental_id" INTEGER
                            )
                            """
        self.makeUpdateInsert(_sqlCreation)
        self.__lastUndo=1
    else:
        self.__lastUndo=self.getMaxUndoIndex()
    self.__activeUndo=self.getLastUndoIndex()
</t>
<t tx="1.20130426141258.3029">def getMaxUndoIndex(self):
    """
        get the gretest undo index from database
    """
    _sqlCheck="select max(pycad_incremental_id) from pycadundo"
    _row=self.fetchOneRow(_sqlCheck)
    if _row is None:            # no entity in the table
        _sqlInser="""INSERT INTO pycadundo (pycad_incremental_id) VALUES (1)"""
        self.makeUpdateInsert(_sqlInser)
        return 1
    return _row # get the max index of the table
</t>
<t tx="1.20130426141258.3030">def getLastUndoIndex(self):
    """
        get the active undo index from database
    """
    _sqlCheck="select pycad_incremental_id from pycadundo where pycad_id=(select max(pycad_id) from pycadundo)"
    _row=self.fetchOneRow(_sqlCheck)
    if _row is None:            # no entity in the table
        _sqlInser="""INSERT INTO pycadundo (pycad_incremental_id) VALUES (1)"""
        self.makeUpdateInsert(_sqlInser)
        return 1
    return _row # get the max index of the table
</t>
<t tx="1.20130426141258.3031">def dbUndo(self):
    """
        performe the undo operation
    """
    _id=self.__activeUndo-1
    while _id&gt;0:
        if self.undoIdExsist(_id):
            self.__activeUndo =_id
            break
        else:
            _id-=1
    if _id&gt;0:
        _sqlInsert="""INSERT INTO pycadundo
                    (pycad_incremental_id) VALUES (%s)"""%str(_id)
        self.makeUpdateInsert(_sqlInsert)
        self.__activeUndo=_id
        return self.__activeUndo
    else:
        raise UndoDbExc("The undo are finished Unable to perform the undo")
</t>
<t tx="1.20130426141258.3032">def dbRedo(self):
    """
        perform the redo operation
    """
    _id=self.__activeUndo+1
    while _id&lt;self.__lastUndo:
        if self.undoIdExsist(_id):
            self.__activeUndo =_id
            break
        else:
            _id+=1
    if _id&lt;=self.__lastUndo:
        _sqlInsert="""INSERT INTO pycadundo
                    (pycad_incremental_id) VALUES (%s)"""%str(_id)
        self.makeUpdateInsert(_sqlInsert)
        self.__activeUndo=_id
        return self.__activeUndo
    else:
        raise UndoDbExc("The undo are finished Unable to perform the redo")
</t>
<t tx="1.20130426141258.3033">def undoIdExsist(self,undoId):
    """
        check is the undo id exsist
    """
    _sqlSelect="""SELECT pycad_incremental_id FROM pycadundo
                  WHERE pycad_incremental_id =%s"""%str(undoId)
    return not self.fetchOneRow(_sqlSelect) is None
</t>
<t tx="1.20130426141258.3034">def getNewUndo(self):
    """
        get the next undo index pycadundo
    """
    try:
        self.suspendCommit()        #suspend commit operation
        self.__lastUndo+=1
        self.__activeUndo=self.__lastUndo
        _sqlInser="""INSERT INTO pycadundo
                    (pycad_incremental_id) VALUES (%s)"""  %str(self.__lastUndo)
        self.makeUpdateInsert(_sqlInser)
        self.performCommit()
        return self.__lastUndo
    except:
        self.reactiveCommit()
        print("Unable to make insert into pycadundo:", sys.exc_info()[0])
        raise
    finally:
        self.reactiveCommit()
</t>
<t tx="1.20130426141258.3035">def clearUndoTable(self):
    """
        Clear all the undo created
    """
    _sqlDelete="""DELETE FROM pycadundo"""
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.3036">def deleteUndo(self,undoId):
    """
        delete the undo index
    """
    _sqlDelete="""DELETE FROM pycadundo WHERE
                (pycad_incremental_id) VALUES (%s)"""%str(undoId)
    self.makeUpdateInsert(_sqlDelete)
</t>
<t tx="1.20130426141258.3037">def getMaxUndoId(self):
    """
        return the undo id
    """
    return self.__lastUndo
</t>
<t tx="1.20130426141258.3038">def getActiveUndoId(self):
    """
        return the active undo id
    """
    return self.__activeUndo
</t>
<t tx="1.20130426141258.3039">def test():
    print("*"*10)
    _undo=PyCadUndoDb(None)
    print("Clear db Table")
    _undo.clearUndoTable()
    print("create 10 undo ")
    for i in range(10):
        _undo.getNewUndo()
    print("Undo")
    for i in range(11):
        _undo.dbUndo()
    print("redo")
    _undo.dbRedo()
</t>
<t tx="1.20130426141258.3040"></t>
<t tx="1.20130426141258.3041"></t>
<t tx="1.20130426141258.3042">#
# Copyright (c) 2009,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the termscl_bo of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3043">import os.path
#
from Kernel.ExternalFormat.Dxf.dxf import Dxf
from Kernel.exception import *
</t>
<t tx="1.20130426141258.3044">#
class ExtFormat(object):
    """
        This class provide base class for hendly different drawing format in pythoncad
    """
    @others
</t>
<t tx="1.20130426141258.3045">def __init__(self,kernel):
    """
        Default Constructor
    """
    self.__kernel=kernel
    self.__errorList=[]
</t>
<t tx="1.20130426141258.3046">def openFile(self,fileName):
    """
       Open a generic file
    """
    path,exte=os.path.splitext( fileName )
    if( exte.upper()==".dxf".upper()):
        dxf=Dxf(self.__kernel,fileName)
        dxf.importEntitis()
        if not dxf.getError() is None:
            self.__errorList=dxf.getError()
            raise DxfReport("Dxf report have to be shown some error/warning in import dxf")
    else:
        raise  DxfUnsupportedFormat("Format %s not supported"%str(exte))
</t>
<t tx="1.20130426141258.3047">def saveFile(self,fileName):
    """
        save the current file in a non pythoncad Format
    """
    path,exte=os.path.splitext( fileName )
    if( exte.upper()==".dxf".upper()):
        dxf=Dxf(self.__kernel,fileName)
        dxf.exportEntitis()
</t>
<t tx="1.20130426141258.3048">def getErrorList(self):
    """
        get the error warning generated
    """
    return self.__errorList
</t>
<t tx="1.20130426141258.3049"></t>
<t tx="1.20130426141258.3050"></t>
<t tx="1.20130426141258.3051">#
# Copyright (c) 2009,2010,2011 Matteo Boscolo,Yagnesh Desai
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the termscl_bo of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3052">dxfDebug=False

import math         # added to handle arc start and end point defination
import re           # added to handle Mtext
import os, sys
from Kernel.initsetting               import cgcol
from Kernel.layer                     import Layer
from Kernel.GeoEntity.point           import Point
from Kernel.GeoEntity.segment         import Segment
from Kernel.GeoEntity.arc             import Arc
from Kernel.GeoEntity.text            import Text
from Kernel.GeoEntity.ellipse         import Ellipse
from Kernel.GeoEntity.polyline        import Polyline
</t>
<t tx="1.20130426141258.3053">def ChangeColor(x):
    try:
        newcolor = cgcol[x]
    except:
        newcolor = 256
    return newcolor
</t>
<t tx="1.20130426141258.3054">def changeColorFromDxf(col):
    if col == '256':
        newcol = layerColor[col]#Work in progress layerColor captured under readLayer needs to be used
    else:
        newcol = ChangeColor(col)
    return newcol
</t>
<t tx="1.20130426141258.3055">class DrawingFile(object):
    """
        This Class provide base capability to read write a  file
    """
    @others
</t>
<t tx="1.20130426141258.3056">def __init__(self,fileName):
    """
        Base Constructor
    """
    dPrint( "Debug: DrawingFile constructor")
    self.__fn=fileName
    self.__fb=None
    self.__errors=[]
    self.__reading=False
    self.__writing=False
    self.__lineNumber=0
</t>
<t tx="1.20130426141258.3057">def readAsci(self):
    """
        Read a generic file
    """
    dPrint("Debug: Read asci File")
    self.__fb=open(self.__fn,'r')
    self.__reading=True
    self.__writing=False
</t>
<t tx="1.20130426141258.3058">def createAsci(self):
    """
        create the new file
    """
    self.__fb=open(self.__fn,'w')
    self.__reading=False
    self.__writing=True
</t>
<t tx="1.20130426141258.3059">def fileObject(self):
    """
        Return the file opened
    """
    dPrint( "Debug: GetFileObject")
    if self.__fb is not None:
      dPrint( "Debug: Return file object")
      return self.__fb
    else:
      dPrint( "Debug: None")
      return None
</t>
<t tx="1.20130426141258.3060">def readLine(self):
    """
        read a line and return it
    """
    if self.__reading:
        self.__lineNumber=self.__lineNumber+1
        return self.__fb.readline()
    else:
        raise ("Unable to perfor reading operation")
</t>
<t tx="1.20130426141258.3061">def writeLine(self,line):
    """
        write a line to the file
    """
    if self.__writing:
        self.__fb.write(line)
    else:
        raise ("Unable to perfor writing operation")
</t>
<t tx="1.20130426141258.3062">def writeError(self,functionName,msg):
    """
        Add an Error to the Collection
    """
    _msg='Error on line %s function Name: %s Message %s \n'%(
        str(self.__lineNumber, 'ASCII'),functionName,msg)
    self.__errors.append(_msg)
</t>
<t tx="1.20130426141258.3063">def getError(self):
    """
    get the import export error
    """
    if len(self.__errors)&gt;0:
        return self.__errors
    else:
        return None
</t>
<t tx="1.20130426141258.3064">def close(self):
    """
    close the active fileObject
    """
    if not self.__fb is None:
        self.__fb.close()
</t>
<t tx="1.20130426141258.3065">def getFileName(self):
    """
        Return The active file Name
    """
    return self.__fn
</t>
<t tx="1.20130426141258.3066">class Dxf(DrawingFile):
    """
        this class provide dxf reading/writing capability
    """
    @others
</t>
<t tx="1.20130426141258.3067">def __init__(self,kernel,fileName):
    """
        Default Constructor
    """
    dPrint( "Debug: Dxf constructor")
    DrawingFile.__init__(self,fileName)
    self.__kernel=kernel
    self.__dxfLayer=None
</t>
<t tx="1.20130426141258.3068">def exportEntitis(self):
    """
        export The current file in dxf format
    """
    _fo=self.createAsci()               #open the file for writing
    _layersEnts=self.getAllEntitis()    #get all the entities from the file
    self.writeLine("999\nExported from Pythoncad\nSECTION\n  2\nENTITIES\n")#header section for entities
    for _key in _layersEnts:            #Looping at all layer
        #create header section#
        for _obj in _layersEnts[_key]:  #looping at all entities in the layer
            obj=_obj.toGeometricalEntity()
            if isinstance(obj,Segment):#if it's segment
                self.writeSegment(obj, _obj.getInnerStyle()) # ad it at the dxf drawing
                continue
            if isinstance(obj,Arc):
                self.writeArc(obj, _obj.getInnerStyle())
                continue
            if isinstance(obj,Polyline):
                self.writePolyline(obj, _obj.getInnerStyle())
                continue
            if isinstance(obj,Text):
                self.writeText(obj, _obj.getInnerStyle())
                continue
            # go on end implements the other case arc circle ...
    self.writeLine("  0\nENDSEC\n  0\nEOF")#writing End Of File
    self.close()
</t>
<t tx="1.20130426141258.3069">def getAllEntitis(self):
    """
        retrive all the entitys from the drawing
    """
    _outLayers={}
    getChildrenEnt=self.__kernel.getTreeLayer.getLayerChildren
    layerNodes=self.__kernel.getTreeLayer.getLayerdbTree()
    def populateDxfStructure(layers):
        for key in layers:
            _layerEnts=[]
            layer, childs=layers[key]
            for ent in getChildrenEnt(layer):
                _layerEnts.append(ent)
            l=self.__kernel.getTreeLayer._getLayerConstructionElement(layer)
            _outLayers[l.name]=_layerEnts
            populateDxfStructure(childs)
    populateDxfStructure(layerNodes)
    return _outLayers
</t>
<t tx="1.20130426141258.3070">def writeSegment(self,e, style):
    """
       write segment to the dxf file
    """
    x1,y1=e.getP1().getCoords()
    x2,y2=e.getP2().getCoords()
    _c=style.getStyleProp('entity_color')
    _c = ChangeColor(_c)
    dPrint("debug line color are %s"%str( _c)) # TODO : replace the dprint with the logging
    self.writeLine("  0\nLINE\n100\nAcdbLine\n")
    self.writeLine(" 62\n" + str(_c) +"\n")
    self.writeLine(" 10\n" +str(x1) +"\n")
    self.writeLine(" 20\n" +str(y1) +"\n 30\n0.0\n")
    self.writeLine(" 11\n" +str(x2) +"\n")
    self.writeLine(" 21\n" +str(y2) +"\n 31\n0.0\n")
</t>
<t tx="1.20130426141258.3071">def writeArc(self,e, style):
    """
       Write Arc to the dxf file
    """
    x1,y1 = e.getCenter().getCoords()
    r = e.getRadius()
    sa = e.getStartAngle()
    ea = e.getEndAngle()
    _c = str(style.getStyleProp('entity_color'), 'ASCII')
    _c = ChangeColor(_c)
    dPrint("debug Arc color are %s "%str( _c, 'ASCII'))
    self.writeLine("  0\nARC\n100\nAcDbCircle\n")
    self.writeLine(" 62\n" +str(_c, 'ASCII') +"\n")
    self.writeLine(" 10\n" +str(x1, 'ASCII') +"\n")
    self.writeLine(" 20\n" +str(y1, 'ASCII') +"\n 30\n0.0\n")
    self.writeLine(" 40\n" +str(r, 'ASCII') +"\n")
    self.writeLine(" 50\n" +str(sa, 'ASCII') +"\n 51\n"+str(ea, 'ASCII')+"\n")
</t>
<t tx="1.20130426141258.3072">def writePolyline(self,e, style):
    """
       Write Polyline to the dxf file
    """
    _c = str(style.getStyleProp('entity_color'), 'ASCII')
    _c = ChangeColor(_c)
    dPrint( "debug Arc color are %s"%str(_c, 'ASCII'))
    self.writeLine("  0\nLWPOLYLINE\n100\nAcDbPolyline\n")
    self.writeLine(" 62\n" +str(_c, 'ASCII') +"\n")
    count = e.getNumPoints()
    self.writeLine(" 90\n" +str(count, 'ASCII')+ "\n")
    self.writeLine(" 70\n0\n")
    self.writeLine(" 43\n0\n")
    c = 0
    points = []
    while c &lt; count:
        x1,y1 = e.getPoint(c).getCoords()
        self.writeLine(" 10\n" +str(x1, 'ASCII') +"\n")
        self.writeLine(" 20\n" +str(y1, 'ASCII') +"\n")
        c = c + 1
</t>
<t tx="1.20130426141258.3073">def writeText(self,e, style):
    """
       Write Text to the dxf file
    """
    x1,y1=e.location.getCoords()
    h = style.getStyleProp('text_height')
    _c = str(style.getStyleProp('entity_color'), 'ASCII')
    _c = ChangeColor(_c)
    dPrint("debug Text color are %s "%str( _c, 'ASCII'))
    txt = e.text
    txt = txt.replace(' ', '\~')
    txt = txt.replace('\n', '\P')
    self.writeLine("  0\nMTEXT\n100\nAcDbMText\n")
    self.writeLine(" 62\n" +str(_c, 'ASCII') +"\n")
    self.writeLine(" 10\n" +str(x1, 'ASCII') +"\n")
    self.writeLine(" 20\n" +str(y1, 'ASCII') +"\n 30\n0.0\n")
    self.writeLine(" 40\n" +str(h, 'ASCII') +"\n")
    self.writeLine("  1\n" +str(txt, 'ASCII') +"\n")
</t>
<t tx="1.20130426141258.3074">def importEntitis(self):
    """
        Open The file and create The entity in pythonCad
    """
    dPrint( "Debug: import entitys")
    self.readAsci();
    _layerName,_ext=os.path.splitext(os.path.basename(self.getFileName()))
    _layerName="Imported_"+_layerName
    parentLayer=self.__kernel.getTreeLayer.getActiveLater()
    newLayer=self.__kernel.saveEntity(Layer(_layerName))
    self.__kernel.getTreeLayer.insert(newLayer, parentLayer)

    try:
        self.__kernel.startMassiveCreation()
        while True:
            _k = self.readLine()
            if not _k: break
            else:
                ##print  "debug: readline", _k # TODO : replace the dprint with the logging
                #dPrint( "Debug: Read Line line = [%s]"%str(_k)) # TODO : replace the dprint with the logging
                if _k[0:5] == 'TABLE':
                    _k = self.readLine() # for tag "  2"
                    _k = self.readLine() # for table name
                    ##print "debug TABLE found" # TODO : replace the dprint with the logging
                    if _k[0:5] == 'LAYER':
                        self.readLayer()
                        #print "debug LAYER found" # TODO : replace the dprint with the logging
                    continue
                if _k[0:4] == 'LINE':
                    self.createLineFromDxf()
                    ##print "debug line found" # TODO : replace the dprint with the logging
                    continue
                if _k[0:6] == 'CIRCLE':
                    self.createCircleFromDxf()
                    continue
                if _k[0:5] == 'MTEXT':
                    self.createTextFromDxf()
                    continue
                if _k[0:4] == 'TEXT':
                    #self.createTextFromDxf()
                    continue
                if _k[0:3] == 'ARC':
                    self.createArcFromDxf()
                    ##print "debug arc found"
                    continue
                if _k[0:10] == 'LWPOLYLINE':
                    #self.createPolylineFromDxf()
                    continue
                if _k[0:8] == 'POLYLINE':
                    #self.createPolylineFromDxf()
                    continue
                if not _k : break
        self.__kernel.performCommit()
    finally:
        self.__kernel.stopMassiveCreation()
</t>
<t tx="1.20130426141258.3075">def readLayer(self):
    """
    Reading the data in the dxf file under TABLE section
    it collects the information regarding the
    Layers, Colors and Linetype
    WORK IN PROGRESS
    """
    ##print 'debug Layer found !'
    layerColor = {}
    dxfColor = 0
    layerName = '0'
    #_k = self.readLine()
    while True:
        _k = self.readLine()
        if _k[0:6] == 'ENDTAB':
            break
        if _k[0:3] == '  2':
            _k = self.readLine()
            layerName = _k.replace('\n', '')
            #print "Debug New LayerName=", layerName
        if _k[0:3] == ' 62':
            _k = self.readLine()
            dxfColor = _k.replace('\n', '')
            #print "Debug new dxfColor = ", dxfColor
        layerColor[layerName] = dxfColor
    return layerColor
</t>
<t tx="1.20130426141258.3076">def createLineFromDxf(self):
    """
        read the line dxf section and create the line
    """
    dPrint( "Debug createLineFromDxf" )# TODO : replace the dprint with the logging
    x1 = None
    y1 = None
    x2 = None
    y2 = None
    g = 0 # start counter to read lines
    c = 0
    while g &lt; 18:
        ##print "Debug g =", g
        ##print "Debug: Read line  g = %s Value = %s "%(str(g),str(line))
        _k = self.readLine()
        ##print "Debug: Read line g = %s k =  %s "%(str(g),str(k))
        #dPrint( "line value k="+_k)
        if _k[0:3] == ' 62':# COLOR
            _k = self.readLine()
            c = (int(_k[0:-1]))
        if _k[0:3] == ' 10':
            dPrint( "debug 10"+ _k)
            # this line of file contains start point"X" co ordinate
            ##print "Debug: Convert To flot x1: %s" % str(k[0:-1])
            _k = self.readLine()
            x1 = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 20':# this line of file contains start point "Y" co ordinate
            ##print "Debug: Convert To flot y1: %s" % str(k[0:-1])
            _k = self.readLine()
            y1 = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 30':# this line of file contains start point "Z" co ordinate
            ##print "Debug: Convert To flot z1: %s" % str(k[0:-1])
            _k = self.readLine()
            z1 = (float(_k[0:-1]))
            continue
            # Z co ordinates are not used in PythonCAD we can live without this line
        if _k[0:3] == ' 11':# this line of file contains End point "X" co ordinate
            ##print "Debug: Convert To flot x2: %s" % str(k[0:-1])
            _k = self.readLine()
            x2 = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 21':# this line of file contains End point "Y" co ordinate
            ##print "Debug: Convert To flot y2: %s" % str(k[0:-1])
            _k = self.readLine()
            y2 = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 31':# this line of file contains End point "Z" co ordinate
            ##print "Debug: Convert To flot z2: %s" % str(k[0:-1])
            _k = self.readLine()
            z2 = (float(_k[0:-1]))
            g = 119
            continue
            #Z coordinates are not used in PythonCAD we can live without this line
    if c == None:
        c = 7
    if not ( x1==None or y1 ==None or
       x2==None or y2 ==None ):
        self.createLine(x1,y1,x2,y2,c)
    else:
        _msg='Read parameter from file x1: [%s] y1: [%s] x2: [%s] y2: [%s]'%(
                    str(x1, 'ASCII'),str(y1, 'ASCII'),str(x2, 'ASCII'),str(y2, 'ASCII'))
        self.writeError('createLineFromDxf',_msg)
</t>
<t tx="1.20130426141258.3077">def createLine(self,x1,y1,x2,y2,c):
    """
      Create the line into the current drawing
    """
    args={"SEGMENT_0":Point(x1, y1), "SEGMENT_1":Point(x2, y2)}
    _seg = Segment(args)
    self.__kernel.saveEntity(_seg)
</t>
<t tx="1.20130426141258.3078">def createCircleFromDxf(self):
    """
        Read and create the Circle into drawing
    """
    dPrint( "Debug createCircleFromDxf" )
    g = 0 # reset g
    c = 0
    while g &lt; 1:
        _k = self.readLine()
        dPrint( "line value k="+ _k)
        if _k[0:3] == ' 62':# COLOR
            _k = self.readLine()
            c = (int(_k[0:-1]))
        if _k[0:3] == ' 10':
            _k = self.readLine()
            x = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 20':
            _k = self.readLine()
            y = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 30':
            _k = self.readLine()
            z = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 40':
            _k = self.readLine()
            r = (float(_k[0:-1]))
            g = 10 # g &gt; 1 for break
            'I need a "create Circle code" here to append the segment to image'
    if c == None:
        c = 7
    self.createArc(x,y,r,c)
</t>
<t tx="1.20130426141258.3079">def createTextFromDxf(self):
    """
        Read and create the Text into drawing
    """
    dPrint( "Debug createTextFromDxf" )
    g = 0 # reset g
    x = None
    y = None
    h = None
    _t= ''
    while g &lt; 1:
        _k = self.readLine()
        try:
            dPrint("line value k="+ _k)
            #if _k[0:3] == ' 62':# COLOR
            #    _k = self.readLine()
            #    c = (int(_k[0:-1]))
            if _k[0:3] == ' 10':
                _k = self.readLine()
                x = (float(_k[0:-1]))
                ##print "Text Loc x =", x
                continue
            if _k[0:3] == ' 20':
                _k = self.readLine()
                y = (float(_k[0:-1]))
                #rint "Text Loc y =", y
                continue
            if _k[0:3] == ' 30':
                _k = self.readLine()
                z = (float(_k[0:-1]))
                ##print "Text Loc z =", z
                continue
            if _k[0:3] == ' 40':
                _k = self.readLine()
                h = (float(_k[0:-1]))
                dPrint("Text Height =%s"%str(h, 'ASCII'))
                continue
            if _k[0:3] == '  1':
                _k = self.readLine()
                _t = _k.replace('\~', ' ')
                _t = _t.replace('\P', '\n')
                ##print "Text itself is ", x, y, z, 'height', h, _t#
                g = 10 # g &gt; 1 for break
                continue
        except:
            print("Error on reading "+str(_k, 'ASCII'))
    if not (x is None or y is None or h is None):
        self.createText(x,y,h,_t)
    else:
        _msg="Read parameter from file x: [%s] y: [%s] h: [%s] t: [%s]"%(
                    str(x, 'ASCII'),str(y, 'ASCII'),str(h, 'ASCII'),str(_t, 'ASCII'))
        self.writeError("createTextFromDxf",_msg)
</t>
<t tx="1.20130426141258.3080">def createArcFromDxf(self):
    """
        Read and create the ARC into drawing
    """
    g = 0 # reset g
    c = 0
    while g &lt; 1:
        _k = self.readLine()
        if _k[0:3] == ' 62':# COLOR
            _k = self.readLine()
            c = (int(_k[0:-1]))
        if _k[0:3] == ' 10':
            _k = self.readLine()
            x = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 20':
            _k = self.readLine()
            y = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 30':
            _k = self.readLine()
            z = (float(_k[0:-1]))
        if _k[0:3] == ' 40':
            _k = self.readLine()
            r = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 50':
            _k = self.readLine()
            sa = (float(_k[0:-1]))
            continue
        if _k[0:3] == ' 51':
            _k = self.readLine()
            ea = (float(_k[0:-1]))
            g = 10 # g &gt; 1 for break\\
            continue
    if c == None:
            c = 7
    self.createArc(x,y,r,c,sa,ea)
</t>
<t tx="1.20130426141258.3081">def createArc(self,x,y,r,color=None,sa=None,ea=None):
    """
        Create a Arc entitys into the current drawing
    """
    _center = Point(x, y)
    if sa is None or ea is None:
        sa=ea=0 #This is the case of circle
    else:
        sa=(sa*math.pi)/180
        ea=(ea*math.pi)/180
        ea=ea-sa
    args={"ARC_0":_center, "ARC_1":r, "ARC_2":sa, "ARC_3":ea}
    _arc = Arc(args)
    self.__kernel.saveEntity(_arc)
</t>
<t tx="1.20130426141258.3082">def createText(self,x,y,h,t):
    """
        Create a Text entitys into the current drawing
    """
    try:
        _text = t.replace('\x00', '').decode('utf8', 'ignore').encode('utf8')
    except:
        self.writeError("createText","Debug Error Converting in unicode [%s]"%t)
        _text ='Unable to convert in unicode'
    _p = Point(x, y)
    args={"TEXT_0":_p,"TEXT_1":_text, "TEXT_2":0.0, "TEXT_3":""}
    _tb = Text(args)
    self.__kernel.saveEntity(_tb)
</t>
<t tx="1.20130426141258.3083">def createPolylineFromDxf(self):
    """
    Polyline creation read the line dxf section and create the line
    """
    dPrint("Exec createPolylineFromDxf")
    c = 0
    while True:
        _k = self.readLine()
        if _k[0:3] == ' 62':# COLOR
            _k = self.readLine()
            c = (int(_k[0:-1]))
        if _k[0:3] == ' 10':
            break
    points=[]
    p = ()
    t = 0
    while True:
        # this line of file contains start point"X" co ordinate
        # #print "Debug: Convert To flot x1: %s" % str(k[0:-1])
        _k = self.readLine()
        x = (float(_k[0:-1]))
        _k = self.readLine()#pass for k[0:3] == ' 20'
        _k = self.readLine()
        y = (float(_k[0:-1]))
        p = (x,y)
        points.append(p)
        dPrint( str(points, 'ASCII'))
        _k = self.readLine()
        if _k[0:3] == ' 30':
            _k = self.readLine()
            z1 = (float(_k[0:-1]))
            _k = self.readLine()
            continue
        if _k[0:3] != ' 10':
            break
        continue
    if c == None:
            c = 7
    if len(points)&gt;1:
        self.createPolyline(points,c)
</t>
<t tx="1.20130426141258.3084">def createPolyline(self,points,c):
    """
        Crate poliline into Pythoncad
    """
    pass #TODO: must be implemented

    dPrint("Exec createPolyline")
    i=0
    args={}
    for _x, _y in points:
        _p = Point(_x, _y)
        args["POLYLINE_%s"%str(i, 'ASCII')]=_p
        i+=1
    pline=Polyline(args)
    self.__kernel.saveEntity(pline)
</t>
<t tx="1.20130426141258.3085">def dPrint(msg):
    """
        Debug function for the dxf file
    """
    if dxfDebug :
        print("Debug: %s " %str(msg, 'ASCII'))
</t>
<t tx="1.20130426141258.3086"></t>
<t tx="1.20130426141258.3087"></t>
<t tx="1.20130426141258.3088">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code for base for Bisector
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3089">from Kernel.GeoComposedEntity.objoint import *
from Kernel.GeoUtil.geolib import Vector
import math
</t>
<t tx="1.20130426141258.3090">class Bisector(ObjectJoint):
    """
        A Bisector class 
    """
    @others
</t>
<t tx="1.20130426141258.3091">def __init__(self, kw):
    """
        "OBJECTJOINT_0" obj1             :(Segment ,ACLine,Arc,CCircle)
        "OBJECTJOINT_1" obj2             :(Segment ,ACLine,Arc,CCircle)
        "OBJECTJOINT_2" pointClick1      :Clicked point from the u.i near the obj1
        "OBJECTJOINT_3" pointClick2      :Clicked point from the u.i near the obj2
        "OBJECTJOINT_4" str              :Fixed Value "NO_TRIM" not needed
        "OBJECTJOINT_5" lengh            :Bisector lengh from intersection point
    """
    kw["OBJECTJOINT_4"]="NO_TRIM"
    argDes={"OBJECTJOINT_5":(float, int, None)}
    ObjectJoint.__init__(self, kw, argDes)
    if not kw["OBJECTJOINT_5"]:
        self["OBJECTJOINT_5"]=self.getDefaultLeng()
    self._UpdateBisector()
</t>
<t tx="1.20130426141258.3092">def _UpdateBisector(self):
    """
        Update the segment base on the imput value
    """
    v1=self.getAngledVector(self.obj1, self.pointClick1)
    v2=self.getAngledVector(self.obj2, self.pointClick2)
    ang=v1.ang(v2)/2.0
    if v1.absAng==0 or v2.absAng==0:
        if v2.point.y&lt;0:
            bisecVector=v2.mag()
        elif v1.point.y&lt;0:
            bisecVector=v1.mag()
        else:
            if v1.absAng&gt;v2.absAng:
                bisecVector=v2.mag()
            else:
                bisecVector=v1.mag()
    else:
        v1v2Ang=abs(v1.absAng-v2.absAng)
        if v1.absAng&gt;v2.absAng:
            if v1v2Ang&gt;math.pi:
                bisecVector=v1.mag()
            else:
                bisecVector=v2.mag()
        else:
            if v1v2Ang&gt;math.pi:
                bisecVector=v2.mag()
            else:
                bisecVector=v1.mag()
    bisecVector.mult(self.lengh)
    bisecVector.rotate(ang)
    newPoint=self.intersection[0]+bisecVector.point
    arg={"SEGMENT_0":self.intersection[0], "SEGMENT_1":newPoint}
    self.bisector=Segment(arg)
</t>
<t tx="1.20130426141258.3093">@property
def lengh(self):
    """
        Second object of the bisector
    """
    return self['OBJECTJOINT_5']
</t>
<t tx="1.20130426141258.3094">@lengh.setter
def lengh(self, value):
    if value:
        self['OBJECTJOINT_5'] = value
    else:
        self.getDefaultLeng()
</t>
<t tx="1.20130426141258.3095">@property
def bisector(self):
    """
        Bisector segment object
    """
    return self.__bisector
</t>
<t tx="1.20130426141258.3096">@bisector.setter
def bisector(self, value):
    self.__bisector=value
</t>
<t tx="1.20130426141258.3097">def getDefaultLeng(self):
    """
        get the default bisector lengh
    """
    pp1=obj1.projection(pointClick1.getSympy())
    pp2=obj2.projection(pointClick2.getSympy())
    ppi.self.intersection[0].getSympy()
    import sympy.geometry   as geoSympy
    t=geoSympy.Triangle(pp1,pp1,ppi)
    return float(t.bisectors[ppi].length)
</t>
<t tx="1.20130426141258.3098">def clone(self):
    """
        Clone the Chamfer .. 
        I do not why somone whant to clone a chamfer ..
        But Tis is the functionality .. :-)
    """
    newChamfer=Chamfer(self._obj1 , 
                self._obj2 ,

                self.pointClick1, 
                self.pointClick2)
    return newChamfer
</t>
<t tx="1.20130426141258.3099">def getReletedComponent(self):
    """
        return the element to be written in the db and used for renderin
    """
    return self.bisector
</t>
<t tx="1.20130426141258.3100">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code for base for Chamfer
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3101">from Kernel.GeoComposedEntity.objoint import *
</t>
<t tx="1.20130426141258.3102">class Chamfer(ObjectJoint):
    """
        A Chamfer class 
    """
    @others
</t>
<t tx="1.20130426141258.3103">def __init__(self, kw):
    """
        obj1, obj2, distance1, distance2, pointClick1=None, pointClick2=None
        "OBJECTJOINT_0" obj1        :(Segment ,ACLine)
        "OBJECTJOINT_1" obj2        :(Segment ,ACLine)
        "OBJECTJOINT_2" pointClick1 :Clicked point from the u.i near the obj1
        "OBJECTJOINT_3" pointClick2 :Clicked point from the u.i near the obj2
        "OBJECTJOINT_4" chamfer trim Mode :Trim Mode (FIRST,SECOND,BOTH,NO_TRIM)
        "OBJECTJOINT_5" distance1   :Real distance from intersection point to chamfer
        "OBJECTJOINT_6" distance2   :Real distance from intersection point to chamfer
    """
    argDes={"OBJECTJOINT_5":(float, int), 
            "OBJECTJOINT_6":(float, int)}
    ObjectJoint.__init__(self, kw, argDes)
    
    for dis in (self.distance1, self.distance2):
        if dis&lt;0.0:
            raise StructuralError("Distance parameter must be greater then 0")
    self.segment=self._UpdateChamferSegment()
</t>
<t tx="1.20130426141258.3104">def setConstructionElements(self, kw):    
    """
        set the construction elements
    """
    for k in kw:
        self[k]=kw[k]
</t>
<t tx="1.20130426141258.3105">def _UpdateChamferSegment(self):           
    """
        Recompute the Chamfer segment
    """
    obj1, pc1=self._updateSegment(self.obj1,self.distance1, self.pointClick1 )
    obj2, pc2=self._updateSegment(self.obj2,self.distance2, self.pointClick2 )
    if self.trimModeKey[self.trimMode]!=self.trimModeKey["NO_TRIM"]:
        if self.trimModeKey[self.trimMode]==self.trimModeKey["FIRST"] or self.trimModeKey[self.trimMode]==self.trimModeKey["BOTH"]:
            self.obj1=obj1
        if self.trimModeKey[self.trimMode]==self.trimModeKey["SECOND"] or self.trimModeKey[self.trimMode]==self.trimModeKey["BOTH"]:
            self.obj2=obj2
    arg={"SEGMENT_0":pc1, "SEGMENT_1":pc2}
    seg=Segment(arg)
    return seg
</t>
<t tx="1.20130426141258.3106">def _updateSegment(self, obj,distance,  clickPoint=None):
    """
        recalculate the segment for the chamfer
        and give the point for the chamfer
    """
    ip=self._intersectionPoints[0]
    if isinstance(obj, Segment):
        p1, p2=obj.getEndpoints()
        if p1==ip:
            mvPoint=p1
            stPoint=p2
        elif p2==ip:
            mvPoint=p2
            stPoint=p1
        elif clickPoint:
            dist1=clickPoint.dist(p1)
            dist2=clickPoint.dist(p2)
            if dist1&lt;dist2:
                mvPoint=p1
                stPoint=p2  
            else:
                mvPoint=p2
                stPoint=p1           
        else:
            dist1=ip.dist(p1)
            dist2=ip.dist(p2)
            if dist1&lt;dist2:
                mvPoint=p1
                stPoint=p2  
            else:
                mvPoint=p2
                stPoint=p1   
                
        v=Vector(mvPoint,stPoint).mag()
        v.mult(distance)
        ePoint=ip+v.point
        arg={"SEGMENT_0":ePoint, "SEGMENT_1":stPoint}
        return Segment(arg), ePoint
</t>
<t tx="1.20130426141258.3107">def getConstructionElements(self):
    """
        retutn the construction element of the object
    """
    outElement=(self._obj1 , 
                self._obj2 ,
                self.distance1, 
                self.distance2, 
                self.pointClick1, 
                self.pointClick2
                )
    return outElement
</t>
<t tx="1.20130426141258.3108">def getLength(self):
    """
        Return the Chamfer length.
    """
    if self.__segment:
        return self.__segment.length()
    else:
        return 0.0
</t>
<t tx="1.20130426141258.3109">def setDistance1(self, distance):
    """
        change the value of the distance1
    """
    if distance&lt;=TOL:
        raise StructuralError("Distance could be greater then 0")
    self["OBJECTJOINT_5"]=distance
    self._UpdateChamferSegment()
</t>
<t tx="1.20130426141258.3110">def getDistance1(self):
    """
        return the distance from intersection point to chanfer start
    """
    return self["OBJECTJOINT_5"]
</t>
<t tx="1.20130426141258.3111">def setDistance2(self, distance):
    """
        change the value of the distance1
    """
    if distance&lt;=TOL:
        raise StructuralError("Distance could be greater then 0")
    self["OBJECTJOINT_6"]=distance
    self._UpdateChamferSegment()
</t>
<t tx="1.20130426141258.3112">def getDistance2(self):
    """
        return the distance from intersection point to chanfer start
    """
    return self["OBJECTJOINT_6"]
</t>
<t tx="1.20130426141258.3113">distance1=property(getDistance1, setDistance1, None, "set the first distance") 
distance2=property(getDistance2, setDistance2, None, "set the second distance") 

def clone(self):
    """
        Clone the Chamfer .. 
        I do not why somone whant to clone a chamfer ..
        But Tis is the functionality .. :-)
    """
    newChamfer=Chamfer(self._obj1 , 
                self._obj2 ,
                self.distance1, 
                self.distance2, 
                self.pointClick1, 
                self.pointClick2)
    return newChamfer
</t>
<t tx="1.20130426141258.3114">def getReletedComponent(self):
    """
        return the element to be written in the db and used for renderin
    """
    return self.obj1 , self.obj2 ,self.segment
</t>
<t tx="1.20130426141258.3115">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code for base for Fillet
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3116">from Kernel.GeoComposedEntity.objoint import *
from Kernel.GeoComposedEntity.bisector import Bisector
from Kernel.exception           import *
from Kernel.GeoUtil.util import *

_dtr = 180.0/pi
</t>
<t tx="1.20130426141258.3117">class Fillet(ObjectJoint):
    """
        A fillet is a curved joining of two Entity Object. For a filleted
        joint to be valid, the radius must fall within some distance
        determined by the segment endpoints and segment intersection
        point, and the two Entity Object must be extendable so they can
        share a common endpoint.
    """
    DEFAULT_RADIUS=10.0
    @others
</t>
<t tx="1.20130426141258.3118">def __init__(self, kw):
    """
        "OBJECTJOINT_0" obj1             :(Segment ,ACLine,Arc,CCircle)
        "OBJECTJOINT_1" obj2             :(Segment ,ACLine,Arc,CCircle)
        "OBJECTJOINT_2" pointClick1      :Clicked point from the u.i near the obj1
        "OBJECTJOINT_3" pointClick2      :Clicked point from the u.i near the obj2
        "OBJECTJOINT_4" str              :Fillet Trim Mode (FIRST,SECOND,BOTH,NO_TRIM)
        "OBJECTJOINT_5" radius           :Radius of the Fillet
    """
    argDes={"OBJECTJOINT_5":(float, int)}
    ObjectJoint.__init__(self, kw, argDes)
    self._UpdateFilletArc()
</t>
<t tx="1.20130426141258.3119">def _calculateCenter(self):
    """
        Calculate the center point of the filler arc
        This method is private to the Fillet object.
    """
    if self.angle==0:
        raise StructuralError("angle betwin the two line is 0 ")
    if math.pi-self.angle==0:
        raise StructuralError("angle betwin the two line is pi ")
    tan=math.tan(self.angle/2.0)
    bisectorLengh=math.sqrt(self.radius**2*(1+1/tan**2))
    arg={"OBJECTJOINT_0":self.obj1,
        "OBJECTJOINT_1":self.obj2,
        "OBJECTJOINT_2":self.pointClick1, 
        "OBJECTJOINT_3":self.pointClick2, 
        "OBJECTJOINT_5":bisectorLengh}
    bisect=Bisector(arg)
    p1, p2=bisect.bisector.getEndpoints() #bisector is a segment so the getEndPoints is made on segment object
    if self.intersection[0].dist(p1)&gt;self.intersection[0].dist(p2):
        self.__center=p1
    else:
        self.__center=p2
</t>
<t tx="1.20130426141258.3120">def _UpdateFilletArc(self):           
    """
        Recompute the Fillet segment
    """
    #
    # Calculate the center of the filet
    #
    self._calculateCenter()
    obj1, pc1=self._updateSegment(self.obj1, self.pointClick1 )
    obj2, pc2=self._updateSegment(self.obj2, self.pointClick2 )
    if not self.trimMode:
        self.trimMode="BOTH"    
    if self.trimModeKey[self.trimMode]!=self.trimModeKey["NO_TRIM"]:
        if self.trimModeKey[self.trimMode]==self.trimModeKey["FIRST"] or self.trimModeKey[self.trimMode]==self.trimModeKey["BOTH"]:
            self.obj1=obj1
        if self.trimModeKey[self.trimMode]==self.trimModeKey["SECOND"] or self.trimModeKey[self.trimMode]==self.trimModeKey["BOTH"]:
            self.obj2=obj2
    self._UpdateAngle(pc1, pc2)
    arg={"ARC_0":self.center, "ARC_1":self.radius, "ARC_2":self.startAngle, "ARC_3":self.endAngle}
    self.filletArc=Arc(arg)
</t>
<t tx="1.20130426141258.3121">def _UpdateAngle(self, pc1, pc2):
    """
        update the Fillet arc angle
    """
    v1=Vector(self.center, pc1)
    v2=Vector(self.center, pc2)
    ang1=v1.absAng
    ang2=v2.absAng
    self.endAngle=v1.ang(v2)
    angC=Vector(self.center, self.intersection[0]).absAng
    if make_c_angle_rad(abs(((ang1+self.endAngle/2.0)-angC)))&lt;0.0001:
        self.startAngle=ang1
    elif make_c_angle_rad(abs(((ang2+self.endAngle/2.0)-angC)))&lt;0.0001:
        self.startAngle=ang2
    else:
        raise StructuralError("_UpdateAngle Unable to upgrade the angle")
</t>
<t tx="1.20130426141258.3122">def _updateSegment(self,objSegment,objPoint):
    """
        Get the point used for the trim
    """
    objProjection=objSegment.getProjection(self.center)
    objInterPoint=self.intersection[0]
    _p1 , _p2 = objSegment.getEndpoints()       
    _objPoint=Point(objSegment.getProjection(objPoint))
    if not (_p1==objInterPoint or _p2==objInterPoint):
        pickIntVect=Vector(objInterPoint,_objPoint).mag()                    
        p1IntVect=Vector(objInterPoint,_p1).mag()            
        if(pickIntVect==p1IntVect):
            arg={"SEGMENT_0":_p1,"SEGMENT_1":objProjection}
            return Segment(arg), objProjection
        p2IntVect=Vector(objInterPoint,_p2).mag()
        if(pickIntVect==p2IntVect):
            arg={"SEGMENT_0":objProjection,"SEGMENT_1":_p2}
            return Segment(arg), objProjection
    ldist=_objPoint.dist(_p1)
    if ldist&gt;_objPoint.dist(_p2):
        arg={"SEGMENT_0":_p1,"SEGMENT_1":objProjection}
        return Segment(arg), objProjection
    else:
        arg={"SEGMENT_0":objProjection,"SEGMENT_1":_p2}
        return Segment(arg), objProjection  
</t>
<t tx="1.20130426141258.3123">@property
def startAngle(self):
    """
        start fillet angle
    """
    return self.__StartAngle
</t>
<t tx="1.20130426141258.3124">@startAngle.setter
def startAngle(self, value):
    self.__StartAngle=value
</t>
<t tx="1.20130426141258.3125">@property
def endAngle(self):
    """
        start fillet angle
    """
    return self.__EndAngle
</t>
<t tx="1.20130426141258.3126">@endAngle.setter
def endAngle(self, value):
    self.__EndAngle=value
</t>
<t tx="1.20130426141258.3127">@property
def radius(self):
    """
        Return the Fillet radius.
    """
    return self['OBJECTJOINT_5']
</t>
<t tx="1.20130426141258.3128">@radius.setter
def radius(self, r):
    """
        Set the Fillet radius.
        The radius should be a positive float value.
    """
    _r = get_float(r)
    if _r &lt; 0.0:
        _r=Fillet.DEFAULT_RADIUS #TODO : THIS VALUE
    self._calculateLimits()
    _rmin, _rmax = self.getRadialLimits()
    if _r &lt; _rmin or _r &gt; _rmax:
        raise ValueError("Invalid radius: %g" % _r)
    _or = self.radius
    if abs(_r - _or) &gt; 1e-10:
        self.radius = _r
        self._calculateCenter()
        self._moveSegmentPoints()
</t>
<t tx="1.20130426141258.3129">@property
def center(self):
    """
        Return the center location of the Fillet.
        return: Point
    """
    return self.__center
</t>
<t tx="1.20130426141258.3130">def clone(self):
    return Fillet(self)
</t>
<t tx="1.20130426141258.3131">def getReletedComponent(self):
    """
        get the releted componet from the fillet
        usually the entity to save
    """
    return self.obj1, self.obj2, self.filletArc
</t>
<t tx="1.20130426141258.3132">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code for base composed object
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3133">from math import hypot, pi, sin, cos, tan, atan2

from Kernel.GeoEntity.geometricalentity    import *
from Kernel.GeoUtil.util                   import *
from Kernel.GeoUtil.intersection           import *
from Kernel.GeoEntity.segment              import Segment
#from Kernel.GeoEntity.acline               import ACLine
from Kernel.GeoEntity.arc                  import Arc
from Kernel.GeoEntity.ccircle              import CCircle
from Kernel.GeoUtil.geolib                 import Vector
</t>
<t tx="1.20130426141258.3134">#ALLOW_CHAMFER_ENTITY=(Segment, ACLine)

class ObjectJoint(GeometricalEntityComposed):
    """
        A base class for chamfers and fillets
        A ObjectJoint object has the following methods:
    """
    @others
</t>
<t tx="1.20130426141258.3135">def __init__(self, kw, argDes=None):
    from Kernel.initsetting import DRAWIN_ENTITY
    classNames=tuple(DRAWIN_ENTITY.keys())
    argDescription={"OBJECTJOINT_0":classNames, 
                    "OBJECTJOINT_1":classNames, 
                    "OBJECTJOINT_2":(Point,None), 
                    "OBJECTJOINT_3":(Point,None), 
                    "OBJECTJOINT_4":(str, str)
                    }
    if argDes:
        for k in argDes:
            argDescription[k]=argDes[k]
            
    self.trimModeKey={"FIRST":0, "SECOND":1, "BOTH":2, "NO_TRIM":3}
    GeometricalEntityComposed.__init__(self, kw, argDescription)
    self._externalIntersectio=False
    spoolIntersection=[Point(x, y) for x, y in find_intersections(self.obj1, self.obj2)]
    if len(spoolIntersection)&lt;=0: #if not intesection is found extend it on cLine
        spoolIntersection=findSegmentExtendedIntersectionPoint(self.obj1, self.obj2)
        self._externalIntersectio=True
    self._intersectionPoints=spoolIntersection
</t>
<t tx="1.20130426141258.3136">@property
def angle(self):
    """
        angle betwin the two entity
    """
    v1=self.getAngledVector(self.obj1, self.pointClick1)
    v2=self.getAngledVector(self.obj2, self.pointClick2)
    ang=v1.ang(v2)
    return ang
</t>
<t tx="1.20130426141258.3137">@property
def trimMode(self):
    """
        trim mode for the entity
    """
    return self["OBJECTJOINT_4"]
</t>
<t tx="1.20130426141258.3138">@trimMode.setter
def trimMode(self, value):
    if value in self.trimModeKey:
        self["OBJECTJOINT_4"]=value
    else:
        raise AttributeError("Bad trim mode use FIRST SECOND BOTH NO_TRIM") 
</t>
<t tx="1.20130426141258.3139">@property
def obj1(self):    
    """
        First object
    """
    return self["OBJECTJOINT_0"]
</t>
<t tx="1.20130426141258.3140">@obj1.setter
def obj1(self, value):
    self["OBJECTJOINT_0"]=value
</t>
<t tx="1.20130426141258.3141">@property
def obj2(self):    
    """
       second object
    """
    return self["OBJECTJOINT_1"]
</t>
<t tx="1.20130426141258.3142">@obj2.setter
def obj2(self, value):
    self["OBJECTJOINT_1"]=value
</t>
<t tx="1.20130426141258.3143">@property    
def pointClick1(self):
    """
        get the clicked point
    """
    return self["OBJECTJOINT_2"]
</t>
<t tx="1.20130426141258.3144">@pointClick1.setter
def pointClick1(self, value):
    self["OBJECTJOINT_2"]=value
</t>
<t tx="1.20130426141258.3145">@property  
def pointClick2(self):
    """
        get the clicked point
    """
    return self["OBJECTJOINT_3"]
</t>
<t tx="1.20130426141258.3146">@pointClick2.setter
def pointClick2(self, value):
    self["OBJECTJOINT_3"]=value
</t>
<t tx="1.20130426141258.3147">@property    
def intersection(self):
    """
        Return the intersection points of the ObjectJoint Entity Object.

        This method returns an array of intersection point 
        [] no intersection
    """
    return self._intersectionPoints
</t>
<t tx="1.20130426141258.3148">def getConstructionElements(self):
    """
        Return the two Entity Object joined by the ObjectJoint.
        This method returns a tuple holding the two Entity Object joined
        by the ObjectJoint.
    """
    return self
</t>
<t tx="1.20130426141258.3149">def getReletedComponent(self):
    """
        return the releted compont of the ObjectJoint
    """
    return self.getConstructionElements()
</t>
<t tx="1.20130426141258.3150">def getAngledVector(self, segment,  point):
    """
        calculate the vector use
    """
    pi=self.intersection[0]
    p1, p2=segment.getEndpoints()
    vs1=Vector(pi, p1)
    vs2=Vector(pi, p2)
    if abs(vs1.absAng-vs2.absAng)&lt;0.00001:
        if pi.dist(p1)&gt;pi.dist(p2):
            return Vector(pi, p1)
        else:
            return Vector(pi, p2)
    else:
        jp=segment.getProjection(point)
        vj=Vector(pi, jp)
        if abs(vj.absAng-vs1.absAng)&lt;0.00001:
            return Vector(pi, p1)
        else:
            return Vector(pi, p2)  
</t>
<t tx="1.20130426141258.3151"></t>
<t tx="1.20130426141258.3152"></t>
<t tx="1.20130426141258.3153">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
# Copyright (c) 2009,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# arc class
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3154">import math

from Kernel.GeoEntity.point                import Point
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoEntity.cline                import CLine
from Kernel.GeoUtil.geolib                 import Vector
from Kernel.GeoEntity.geometricalentity    import *
from Kernel.GeoUtil.util                   import *

_dtr = math.pi/180.0
_rtd = 180.0/math.pi

pi_2=math.pi*2.0
pi2=math.pi/2.0
</t>
<t tx="1.20130426141258.3155">class Arc(GeometricalEntity):
    """
        A class for Arcs.
        An Arc has four attributes:
        center: A Point object
        radius: The Arc's radius
        startAngle: The start angle
        endAngle: The end angle

        An Arc has the following methods:
    """
    @others
</t>
<t tx="1.20130426141258.3156">def __init__(self,kw):
    """
        Initialize a Arc/Circle.
        kw['ARC_0'] center must be a point 
        kw['ARC_1'] radius must be a valid float
        kw['ARC_2'] startAngle must be a valid radiant float value
        kw['ARC_3'] endAngle   must be a valid radiant float value
    """
    argDescription={
                    "ARC_0":Point,
                    "ARC_1":(float, int), 
                    "ARC_2":(float, int), 
                    "ARC_3":(float, int)
                    }
    GeometricalEntity.__init__(self,kw, argDescription)
    __isCircle=False
    if self.startAngle ==None or self.endAngle==None:
        self.startAngle=0
        self.endAngle=pi_2
        __isCircle=True
    if not get_float(self.radius) &gt; 0.0:
        raise ValueError("Invalid radius") 
    
    #self.startAngle = self.startAngle
    #self.endAngle= self.endAngle
</t>
<t tx="1.20130426141258.3157">def isCircle(self):
    """
        return if the arc isa circle
    """
    return self.__isCircle
</t>
<t tx="1.20130426141258.3158">@property
def info(self):
    return "Arc: Center: %s, Radius:%s ,StartAngle: %s,EndAngle: %s"%(str(self.center), str(self.radius), str(self.startAngle), str(self.endAngle))
</t>
<t tx="1.20130426141258.3159">def __eq__(self, obj):
    """
        Compare a Arc to another for equality.
    """
    if not isinstance(obj, Arc):
        return False
    if obj is self:
        return True
    return ((self.center == obj.center) and
            (abs(self.radius - obj.radius) &lt; 1e-10) and
            (abs(self.startAngle - obj.startAngle) &lt; 1e-10) and
            (abs(self.endAngle - obj.endAngle) &lt; 1e-10))
</t>
<t tx="1.20130426141258.3160">def __ne__(self, obj):
    """
        Compare a Arc to another for inequality.
    """
    if not isinstance(obj, Arc):
        return True
    if obj is self:
        return False
    return ((self.center != obj.center) or
            (abs(self.radius - obj.radius) &gt; 1e-10) or
            (abs(self.startAngle - obj.startAngle) &gt; 1e-10) or
            (abs(self.endAngle - obj.endAngle) &gt; 1e-10))                   
</t>
<t tx="1.20130426141258.3161">def getCenter(self):
    """
        Return the center Point of the Arc.
    """
    return self['ARC_0']
</t>
<t tx="1.20130426141258.3162">def setCenter(self, point):
    """
        Set the center Point of the Arc.
    """
    if not isinstance(point, self.arguments['ARC_0'] ):
        raise TypeError("Wrong argument type Need a Point")
    self['ARC_0']=point
</t>
<t tx="1.20130426141258.3163">center = property(getCenter, setCenter, None, "Arc center")

def getRadius(self):
    """
        Return the radius of the the Arc.
    """
    return self['ARC_1']
</t>
<t tx="1.20130426141258.3164">def setRadius(self, radius):
    """
        Set the radius of the Arc.
        The argument must be float value greater than 0.
    """
    _r = get_float(radius)
    if not _r &gt; 0.0:
        raise ValueError("Invalid radius: %g" % _r)
    self['ARC_1']=_r
</t>
<t tx="1.20130426141258.3165">radius = property(getRadius, setRadius, None, "Arc radius")

def getStartAngle(self):
    """
        Return the startAngle for the Arc.
    """
    return self['ARC_2']
</t>
<t tx="1.20130426141258.3166">def setStartAngle(self, angle):
    """
        Set the startAngle for the Arc.
        The argument angle should be a float.
    """
    self['ARC_2'] = angle
</t>
<t tx="1.20130426141258.3167">startAngle = property(getStartAngle, setStartAngle, None,
                       "Start angle for the Arc.")

def getEndAngle(self):
    """
        Return the endAngle for the Arc.
    """
    return self['ARC_3']
</t>
<t tx="1.20130426141258.3168">def setEndAngle(self, angle):
    """
        Set the endAngle for the Arc.
        The argument angle should be a float.
    """
    self['ARC_3'] = angle
</t>
<t tx="1.20130426141258.3169">endAngle = property(getEndAngle, setEndAngle, None,
                     "End angle for the Arc.")

def getAngle(self):
    """
        Return the angular sweep of the Arc.
    """
    if abs(self.endAngle - self.startAngle) &lt; 1e-10:
        _angle = pi_2
    elif self.endAngle &gt; self.startAngle:
        _angle =self.endAngle - self.startAngle
    else:
        _angle = pi_2 - self.startAngle + self.endAngle
    return _angle
</t>
<t tx="1.20130426141258.3170">def throughAngle(self, angle):
    """
        Return True if an arc passes through some angle
        The argument angle should be a float value. This method returns
        True if the arc exists at that angle, otherwise the method returns False.
    """
    _angle = math.fmod(get_float(angle), pi_2)
    if _angle &lt; 0.0:
        _angle = _angle + pi_2
    _sa = self.__sa
    _ea = self.__ea
    _val = True
    if abs(_sa - _ea) &gt; 1e-10:
        if _sa &gt; _ea:
            if _angle &gt; _ea and _angle &lt; _sa:
                _val = False
        else:
            if _angle &gt; _ea or _angle &lt; _sa:
                _val = False
    return _val
</t>
<t tx="1.20130426141258.3171">def getEndpoints(self):
    """
        Return where the two endpoints for the arc-segment lie.
        This function returns two Points, each containing the x-y coordinates
        of the arc endpoints. The first Point corresponds to the endpoint at
        the startAngle, the second to the endpoint at the endAngle.
    """
    _cx, _cy = self.center.getCoords()
    _r = self.radius
    _sa = self.startAngle
    _sax = _cx + _r * math.cos(_sa )
    _say = _cy + _r * math.sin(_sa)
    _ea = self.endAngle+_sa
    
    _eax = _cx + _r * math.cos(_ea )
    _eay = _cy + _r * math.sin(_ea )
    return Point(_sax, _say), Point(_eax, _eay)
</t>
<t tx="1.20130426141258.3172">def length(self):
    """
        Return the length of the Arc.
    """
    
    return self.radius*self.getAngle()
</t>
<t tx="1.20130426141258.3173">def area(self):
    """
        Return the area enclosed by the Arc.
    """
    return pow(self.radius, 2) * (self.getAngle()/2)
</t>
<t tx="1.20130426141258.3174">def getProjection(self,fromPoint):
    """
        get Projection of the point x,y on the arc
    """
    c=self.center
    v=Vector(fromPoint,c)
    if  v.norm&gt;self.radius:
        a=v.absAng
        pj1=Point((v.X+fromPoint.getx()-self.radius*math.cos(a)), (v.Y+fromPoint.gety()-self.radius*math.sin(a)))
        pj2=Point((v.X+fromPoint.getx()+self.radius*math.cos(a)), (v.Y+fromPoint.gety()+self.radius*math.sin(a)))
        return pj1 # ######################## adding return value for pj2
    else:
        return None
</t>
<t tx="1.20130426141258.3175">def GetTangentPoint(self,x,y,outx,outy):
    """
        Get the tangent from an axternal point
        args:
            x,y is a point near the circle
            xout,yout is a point far from the circle
        return:
            a tuple(x,y,x1,xy) that define the tangent line
    """
    firstPoint=Point(x,y)
    fromPoint=Point(outx,outy)
    twoPointDistance=self.center.dist(fromPoint)
    if(twoPointDistance&lt;self.radius):
        return None,None
    originPoint=Point(0.0,0.0)
    tanMod=math.sqrt(pow(twoPointDistance,2)-pow(self.radius,2))
    tgAngle=math.asin(self.radius/twoPointDistance)
    #Compute the x versor
    xPoint=Point(1.0,0.0)
    xVector=Vector(originPoint,xPoint)
    twoPointVector=Vector(fromPoint,self.center)
    rightAngle=twoPointVector.ang(xVector)
    cx,cy=self.center.getCoords()
    if(outy&gt;cy): # stupid situation
        rightAngle=-rightAngle
    posAngle=rightAngle+tgAngle
    negAngle=rightAngle-tgAngle
    # Compute the Positive Tangent
    xCord=math.cos(posAngle)
    yCord=math.sin(posAngle)
    dirPoint=Point(xCord,yCord) # Versor that point at the tangentPoint
    ver=Vector(originPoint,dirPoint)
    ver.mult(tanMod)
    tangVectorPoint=ver.Point()
    posPoint=Point(tangVectorPoint+(outx,outy))
    # Compute the Negative Tangent
    xCord=math.cos(negAngle)
    yCord=math.sin(negAngle)
    dirPoint=Point(xCord,yCord)#Versor that point at the tangentPoint
    ver=Vector(originPoint,dirPoint)
    ver.mult(tanMod)
    tangVectorPoint=ver.point()
    negPoint=Point(tangVectorPoint+(outx,outy))
    if(firstPoint.dist(posPoint)&lt;firstPoint.dist(negPoint)):
        return posPoint.getCoords()
    else:
        return negPoint.getCoords()
</t>
<t tx="1.20130426141258.3176">def GetRadiusPointFromExt(self,x,y):
    """
        get The intersecrion point from the line(x,y,cx,cy) and the circle
    """
    _cx, _cy = self.center.getCoords()
    _r = self.radius
    centerPoint=Point(_cx,_cy)
    outPoint=Point(x,y)
    vector=Vector(outPoint,centerPoint)
    vNorm=vector.norm()
    newNorm=abs(vNorm-_r)
    magVector=vector.mag()
    magVector.mult(newNorm)
    newPoint=magVector.point()
    intPoint=Point(outPoint+newPoint)
    return intPoint.getCoords()
</t>
<t tx="1.20130426141258.3177">def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
    """
        Return whether or not an Arc exists within a region.
        The first four arguments define the boundary. The optional
        fifth argument fully indicates whether or not the Arc
        must be completely contained within the region or just pass
        through it.
    """
    #TODO : May be we need to delete this ...
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    test_boolean(fully)
    _xc, _yc = self.center.getCoords()
    _r = self.radius
    #
    # cheap test to see if arc cannot be in region
    #
    _axmin, _aymin, _axmax, _aymax = self.getBounds()
    if ((_axmin &gt; _xmax) or
        (_aymin &gt; _ymax) or
        (_axmax &lt; _xmin) or
        (_aymax &lt; _ymin)):
        return False
    _val = False
    _bits = 0
    #
    # calculate distances from center to region boundary
    #
    if abs(_xc - _xmin) &lt; _r: _bits = _bits | 1 # left edge
    if abs(_xc - _xmax) &lt; _r: _bits = _bits | 2 # right edge
    if abs(_yc - _ymin) &lt; _r: _bits = _bits | 4 # bottom edge
    if abs(_yc - _ymax) &lt; _r: _bits = _bits | 8 # top edge
    if _bits == 0:
        #
        # arc must be visible - the center is in
        # the region and is more than the radius from
        # each edge
        #
        _val = True
    else:
        #
        # calculate distance to corners of region
        #
        if math.hypot((_xc - _xmin), (_yc - _ymax)) &lt; _r:
            _bits = _bits | 0x10 # upper left
        if math.hypot((_xc - _xmax), (_yc - _ymin)) &lt; _r:
            _bits = _bits | 0x20 # lower right
        if math.hypot((_xc - _xmin), (_yc - _ymin)) &lt; _r:
            _bits = _bits | 0x40 # lower left
        if math.hypot((_xc - _xmax), (_yc - _ymax)) &lt; _r:
            _bits = _bits | 0x80 # upper right
        #
        # if all bits are set then distance from arc center
        # to region endpoints is less than radius - arc
        # entirely outside the region
        #
        _val = not ((_bits == 0xff) or fully)
        #
        # if the test value is still true, check that the
        # arc boundary can overlap with the region
        #
        if _val:
            _ep1, _ep2 = self.getEndpoints()
            _axmin = min(_xc, _ep1[0], _ep2[0])
            if self.throughAngle(180.0):
                _axmin = _xc - _r
            if _axmin &gt; _xmax:
                return False
            _aymin = min(_yc, _ep1[1], _ep2[1])
            if self.throughAngle(270.0):
                _aymin = _yc - _r
            if _aymin &gt; _ymax:
                return False
            _axmax = max(_xc, _ep1[0], _ep2[0])
            if self.throughAngle(0.0):
                _axmax = _xc + _r
            if _axmax &lt; _xmin:
                return False
            _aymax = max(_yc, _ep1[1], _ep2[1])
            if self.throughAngle(90.0):
                _aymax = _yc + _r
            if _aymax &lt; _ymin:
                return False
    return _val
</t>
<t tx="1.20130426141258.3178">def getBounds(self):
    _ep1, _ep2 = self.getEndpoints()
    _xc, _yc = self.center.getCoords()
    _r = self.radius
    _xmin = min(_xc, _ep1[0], _ep2[0])
    _ymin = min(_yc, _ep1[1], _ep2[1])
    _xmax = max(_xc, _ep1[0], _ep2[0])
    _ymax = max(_yc, _ep1[1], _ep2[1])
    if self.throughAngle(0.0):
        _xmax = _xc + _r
    if self.throughAngle(90.0):
        _ymax = _yc + _r
    if self.throughAngle(180.0):
        _xmin = _xc - _r
    if self.throughAngle(270.0):
        _ymin = _yc - _r
    return _xmin, _ymin, _xmax, _ymax
</t>
<t tx="1.20130426141258.3179">def clone(self):
    """
        Create an identical copy of a Arc
        clone()
    """
    return Arc(self.getConstructionElements())
</t>
<t tx="1.20130426141258.3180">def getSympy(self):
    """
        get the sympy object in this case a circle
    """
    _cp=self.center.getSympy()
    return geoSympy.Circle(_cp, mainSympy.Rational(str(self.radius)))
</t>
<t tx="1.20130426141258.3181">def setFromSympy(self, sympyCircle):    
    """
        update the points cord from a sympyobject only avaiable for circle
    """
    self.center.setFromSympy(sympyCircle.center)
    self.radius=float(sympyCircle.radius)
</t>
<t tx="1.20130426141258.3182">def __str__(self):
    msg="Arc\Circle: Center %s , Radius %s , StartAngle=%s, EndAngle=%s"%(
        str(self.center), str(self.radius), str(self.startAngle), str(self.endAngle))
    return msg
</t>
<t tx="1.20130426141258.3183">def test_angle(self,s, e, a):
    """
        Returns if an angle lies between the start and end angle of an arc.
        s: arc start angle
        e: arc end angle
        a: angle being tested
    """
    _val = False
    if ((abs(e - s) &lt; 1e-10) or
        ((s &gt; e) and
         ((s &lt;= a &lt;= math.pi) or (0.0 &lt;= a &lt;= e))) or
        (s &lt;= a &lt;= e)):
        _val = True
    return _val
</t>
<t tx="1.20130426141258.3184">def rotate(self, rotationPoint, angle):
    """
        rotate the arc
    """
    self.startAngle+=angle
    self.center.rotate(rotationPoint, angle)
</t>
<t tx="1.20130426141258.3185">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    startPoint, endPoint=self.getEndpoints()
    self.center.mirror(mirrorRef)
    endMirror=mirrorRef.getProjection(endPoint)
    vEnd=Vector( endPoint, endMirror)
    newStart=endMirror+vEnd.point
    self.startAngle=Vector(self.center, newStart).absAng
</t>
<t tx="1.20130426141258.3186">def getQuadrant(self):
    """
        Return the circle intersection with the line x,y passing through the
        center
    """
    x, y=self.center.getCoords()
    p1=Point(x, y+self.radius)
    p2=Point(x-self.radius, y)
    p3=Point(x, y-self.radius)
    p4=Point(x+self.radius, y)
    return [p1, p2, p3, p4]
</t>
<t tx="1.20130426141258.3187">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# construction circle class
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3188">import math

from Kernel.GeoUtil.tolerance              import *
from Kernel.GeoUtil.util                   import *
from Kernel.GeoEntity.geometricalentity    import *
from Kernel.GeoEntity.point                import Point
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoEntity.cline                import CLine
from Kernel.GeoUtil.geolib                 import Vector
</t>
<t tx="1.20130426141258.3189">class CCircle(GeometricalEntity):
    """
        A class for contruction circles

        center: A Point object
        radius: The CCircle's radius
    """
    @others
</t>
<t tx="1.20130426141258.3190">def __init__(self,kw):
    """
        Initialize a CCircle.
        kw['ARC_0'] center must be a point 
        kw['ARC_1'] radius must be a valid float
    """
    argDescription={
                    "CCIRCLE_0":Point,
                    "CCIRCLE_1":(float, int)
                    }
    GeometricalEntity.__init__(self,kw, argDescription)
    
    if not get_float(self.radius) &gt; 0.0:
        raise ValueError("Invalid radius") 
</t>
<t tx="1.20130426141258.3191">@property
def info(self):
    return "CCircle: Center: %s, Radius:%ss"%(str(self.center), str(self.radius))
</t>
<t tx="1.20130426141258.3192">def __eq__(self, obj):
    """
        Compare a CCircle to another for equality.
    """
    if not isinstance(obj, CCircle):
        return False
    if obj is self:
        return True
    _val = False
    if self.center == obj.center:
        if abs(self.radius - obj.radius) &lt; 1e-10:
            _val = True
    return _val
</t>
<t tx="1.20130426141258.3193">def __ne__(self, obj):
    """
        Compare a CCircle to another for inequality.
    """
    if not isinstance(obj, CCircle):
        return True
    if obj is self:
        return False
    _val = True
    if self.center == obj.center:
        if abs(self.radius - obj.radius) &lt; 1e-10:
            _val = False
    return _val
</t>
<t tx="1.20130426141258.3194">def getConstructionElements(self):
    """
        get construction elements
    """
    return (self.center, self.radius)
</t>
<t tx="1.20130426141258.3195">def getCenter(self):
    """
        Return the center Point of the CCircle.
    """
    return self['CCIRCLE_0']
</t>
<t tx="1.20130426141258.3196">def setCenter(self, point):
    """
        Set the center Point of the CCircle.
        The argument must be a Point or a tuple containing
        two float values.
    """
    if not isinstance(point, Point):
        raise TypeError("Invalid center point: " + repr(type(point)))
   
    self['CCIRCLE_0'] = point
</t>
<t tx="1.20130426141258.3197">center = property(getCenter, setCenter, None, "CCircle center")

def getRadius(self):
    """
        Return the radius of the the CCircle.
    """
    return self['CCIRCLE_1']
</t>
<t tx="1.20130426141258.3198">def setRadius(self, radius):
    """
        Set the radius of the CCircle.
        The argument must be float value greater than 0.
    """
    _r = get_float(radius)
    if not _r &gt; 0.0:
        raise ValueError("Invalid radius: %g" % _r)
    self['CCIRCLE_1'] = _r
</t>
<t tx="1.20130426141258.3199">radius = property(getRadius, setRadius, None, "CCircle radius")

def circumference(self):
    """
        Return the circumference of the CCircle.
    """
    return 2.0 * math.pi * self.radius
</t>
<t tx="1.20130426141258.3200">def area(self):
    """
        Return the area enclosed by the CCircle.
    """
    return math.pi * pow(self.radius, 2)
</t>
<t tx="1.20130426141258.3201">def mapCoords(self, x, y, tol=TOL):
    """
        Return the nearest Point on the CCircle to a coordinate pair.
        The function has two required arguments:

        x: A Float value giving the x-coordinate
        y: A Float value giving the y-coordinate

        There is a single optional argument:

        tol: A float value equal or greater than 0.0

        This function is used to map a possibly near-by coordinate pair to
        an actual Point on the CCircle. If the distance between the actual
        Point and the coordinates used as an argument is less than the tolerance,
        the actual Point is returned. Otherwise, this function returns None.
    """
    _x = get_float(x)
    _y = get_float(y)
    _t = toltest(tol)
    _cx, _cy = self.center.getCoords()
    _r = self.radius
    _dist = math.hypot((_x - _cx), (_y - _cy))
    if abs(_dist - _r) &lt; _t:
        _angle = math.atan2((_y - _cy),(_x - _cx))
        _xoff = _r * math.cos(_angle)
        _yoff = _r * math.sin(_angle)
        return (_cx + _xoff), (_cy + _yoff)
    return None
</t>
<t tx="1.20130426141258.3202">def GetTangentPoint(self,x,y,outx,outy):
    """
        Get the tangent from an axternal point
        args:
            x,y is a point near the circle
            xout,yout is a point far from the circle
        return:
            a tuple(x,y,x1,xy) that define the tangent line
    """
    firstPoint=Point(x,y)
    fromPoint=Point(outx,outy)
    twoPointDistance=self.center.Dist(fromPoint)
    if(twoPointDistance&lt;self.radius):
        return None,None
    originPoint=Point(0.0,0.0)        
    tanMod=math.sqrt(pow(twoPointDistance,2)-pow(self.radius,2))
    tgAngle=math.asin(self.radius/twoPointDistance)
    #Compute the x versor
    xPoint=point.Point(1.0,0.0)
    xVector=Vector(originPoint,xPoint)
    twoPointVector=Vector(fromPoint,self.center)
    rightAngle=twoPointVector.Ang(xVector)                
    cx,cy=self.center.getCoords()        
    if(outy&gt;cy): #stupid situation 
        rightAngle=-rightAngle
    posAngle=rightAngle+tgAngle
    negAngle=rightAngle-tgAngle
    #Compute the Positive Tangent
    xCord=math.cos(posAngle)
    yCord=math.sin(posAngle)
    dirPoint=Point(xCord,yCord)#Versor that point at the tangentPoint
    ver=Vector(originPoint,dirPoint)
    ver.Mult(tanMod)
    tangVectorPoint=ver.Point()
    posPoint=Point(tangVectorPoint+(outx,outy))
    #Compute the Negative Tangent
    xCord=math.cos(negAngle)
    yCord=math.sin(negAngle)
    dirPoint=Point(xCord,yCord)#Versor that point at the tangentPoint
    ver=Vector(originPoint,dirPoint)
    ver.Mult(tanMod)
    tangVectorPoint=ver.Point()
    negPoint=Point(tangVectorPoint+(outx,outy))
    if firstPoint.Dist(posPoint)&lt;firstPoint.Dist(negPoint):
        return posPoint.getCoords()     
    else:
        return negPoint.getCoords() 
</t>
<t tx="1.20130426141258.3203">def GetRadiusPointFromExt(self,x,y):
    """
        get The intersecrion point from the line(x,y,cx,cy) and the circle
    """
    _cx, _cy = self.center.getCoords()
    _r = self.radius
    centerPoint=Point(_cx,_cy)
    outPoint=Point(x,y)
    vector=Vector(outPoint,centerPoint)
    vNorm=vector.Norm()
    newNorm=abs(vNorm-_r)
    magVector=vector.Mag()
    magVector.Mult(newNorm)
    newPoint=magVector.Point()
    intPoint=Point(outPoint+newPoint)
    return intPoint.getCoords()  
</t>
<t tx="1.20130426141258.3204">def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
    """
        Return whether or not an CCircle exists within a region.

    The first four arguments define the boundary. The optional
    fifth argument 'fully' indicates whether or not the CCircle
    must be completely contained within the region or just pass
    through it.
    """
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    util.test_boolean(fully)
    _xc, _yc = self.center.getCoords()
    _r = self.radius
    #
    # cheap test to see if ccircle cannot be in region
    #
    if (((_xc - _r) &gt; _xmax) or
        ((_yc - _r) &gt; _ymax) or
        ((_xc + _r) &lt; _xmin) or
        ((_yc + _r) &lt; _ymin)):
        return False
    _val = False
    _bits = 0        
    #
    # calculate distances from center to region boundary
    #
    if abs(_xc - _xmin) &lt; _r: _bits = _bits | 1 # left edge
    if abs(_xc - _xmax) &lt; _r: _bits = _bits | 2 # right edge
    if abs(_yc - _ymin) &lt; _r: _bits = _bits | 4 # bottom edge
    if abs(_yc - _ymax) &lt; _r: _bits = _bits | 8 # top edge
    if _bits == 0:
        #
        # if the ccircle center is in region then the entire
        # ccircle is visible since the distance from the center
        # to any edge is greater than the radius. If the center
        # is not in the region then the ccircle is not visible in
        # the region because the distance to any edge is greater
        # than the radius, and so one of the bits should have been
        # set ...
        #
        if ((_xmin &lt; _xc &lt; _xmax) and (_ymin &lt; _yc &lt; _ymax)):
            _val = True
    else:
        _val = True
        #
        # calculate distance to corners of region
        #
        if math.hypot((_xc - _xmin), (_yc - _ymax)) &lt; _r:
            _bits = _bits | 0x10 # upper left
        if math.hypot((_xc - _xmax), (_yc - _ymin)) &lt; _r:
            _bits = _bits | 0x20 # lower right
        if math.hypot((_xc - _xmin), (_yc - _ymin)) &lt; _r:
            _bits = _bits | 0x40 # lower left
        if math.hypot((_xc - _xmax), (_yc - _ymax)) &lt; _r:
            _bits = _bits | 0x80 # upper right
        #
        # if all bits are set then distance from ccircle center
        # to region endpoints is less than radius - ccircle
        # entirely outside the region
        #
        if _bits == 0xff or fully:
            _val = False
    return _val
</t>
<t tx="1.20130426141258.3205">def clone(self):
    """
        Create an identical copy of a CCircle
    """
    return CCircle(self.getConstructionElements())
</t>
<t tx="1.20130426141258.3206">def getSympy(self):
    """
        get the sympy object in this case a circle
    """
    _cp=self.center.getSympy()
    return geoSympy.Circle(_cp, mainSympy.Rational(self.radius))
</t>
<t tx="1.20130426141258.3207">def setFromSympy(self, sympyCircle):    
    """
        update the points cord from a sympyobject only avaiable for circle
    """
    self.center.setFromSympy(sympyCircle[0])
    self.radius=float(sympyCircle[1])
</t>
<t tx="1.20130426141258.3208">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    self.center.mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3209">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# single point construction lines at an arbitrary angle
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3210">import math


from Kernel.GeoEntity.geometricalentity    import *
from Kernel.GeoUtil.tolerance              import *
from Kernel.GeoUtil.util                   import *
from Kernel.GeoEntity.point                import Point
from Kernel.GeoUtil.geolib                 import Vector
</t>
<t tx="1.20130426141258.3211">class CLine(GeometricalEntity):
    """
        A class for single point construction lines From Two points.
    """
    @others
</t>
<t tx="1.20130426141258.3212">def __init__(self, kw):
    """
        Initialize an CLine object.
        kw must be a dict with 2 argument 
        CLINE_0=Point: First Point object where the line passes through
        CLINE_1=Point: Second Point object where the line passes through
    """
    argDescription={"CLINE_0":Point, "CLINE_1":Point}
    GeometricalEntity.__init__(self,kw, argDescription)
</t>
<t tx="1.20130426141258.3213">def __str__(self):
    return "Construction line through point %s at %s " % (self.p1, self.p2)   
</t>
<t tx="1.20130426141258.3214">@property
def info(self):
    return "CLine: %s, %s"%(str(self.p1), str(self.p2))
</t>
<t tx="1.20130426141258.3215">def rotate(self, rotationPoint, angle):
    """
        rotate the acline for a given angle
    """    
    self.p1=GeometricalEntity.rotate(self, rotationPoint,self.p1, angle )
    self.p2=GeometricalEntity.rotate(self, rotationPoint,self.p2, angle )
</t>
<t tx="1.20130426141258.3216">def isVertical(self):
    x1, y1=self.p1.getCoords()
    x2, y2=self.p1.getCoords()
    return abs(y1 - y2) &lt; 1e-10
</t>
<t tx="1.20130426141258.3217">def isHorizontal(self):
    x1, y1=self.p1.getCoords()
    x2, y2=self.p1.getCoords()
    return abs(x1 - x2) &lt; 1e-10
</t>
<t tx="1.20130426141258.3218">def getP1(self):
    return self['CLINE_0']
</t>
<t tx="1.20130426141258.3219">def setP1(self, p):
    if not isinstance(p, Point):
        raise TypeError("Unexpected type for point: " + repr(type(p)))
    self['CLINE_0']=p
</t>
<t tx="1.20130426141258.3220">p1=property(getP1, setP1, None, "Set the location of the first point of the line")

def getP2(self):
    return self['CLINE_1']
</t>
<t tx="1.20130426141258.3221">def setP2(self, p):
    if not isinstance(p, Point):
        raise TypeError("Unexpected type for point: " + repr(type(p)))
    self['CLINE_1']=p
</t>
<t tx="1.20130426141258.3222">p2=property(getP2, setP2, None, "Set the location of the first point of the line")

def getKeypoints(self):
    """
        Return the 2 construction point 
    """
    return p1, p2
</t>
<t tx="1.20130426141258.3223">def getAngle(self):
    """
        get the getAngle 
    """
    return float(mainSympy.atan(getSympy.slope))
</t>
<t tx="1.20130426141258.3224">def clone(self):
    """
        Create an identical copy of an CLine.
    """
    return CLine(self)
</t>
<t tx="1.20130426141258.3225">def getSympy(self):
    """
        get the sympy object
    """
    _sp1=self.p1.getSympy()
    _sp2=self.p2.getSympy()
    return geoSympy.Line(_sp1, _sp2)
</t>
<t tx="1.20130426141258.3226">def setFromSympy(self, sympySegment):    
    """
        update the points cord from a sympyobject
    """
    self.p1.setFromSympy(sympySegment.p1)
    self.p2.setFromSympy(sympySegment.p2)
</t>
<t tx="1.20130426141258.3227">@property
def vector(self):
    """
        Get The vector of the CLine
    """
    return Vector(self.p1, self.p2)
</t>
<t tx="1.20130426141258.3228">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    from Kernel.GeoEntity.segment              import Segment
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    self.p1.mirror(mirrorRef)
    self.p2.mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3229">def intersect_region(acl, xmin, ymin, xmax, ymax):
    if not isinstance(acl, CLine):
        raise TypeError("Argument not an CLine: " + repr(type(acl)))
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    _x, _y = acl.getLocation().getCoords()
    _x1 = _y1 = _x2 = _y2 = None
    if acl.isVertical() and _xmin &lt; _x &lt; _xmax:
        _x1 = _x
        _y1 = _ymin
        _x2 = _x
        _y2 = _ymax
    elif acl.isHorizontal() and _ymin &lt; _y &lt; _ymax:
        _x1 = _xmin
        _y1 = _y
        _x2 = _xmax
        _y2 = _y
    else:
        _angle = acl.getAngle()
        _slope = math.tan(_angle )
        _yint = _y - (_x * _slope)
        _xt = _x + math.cos(_angle)
        _yt = _y + math.sin(_angle)
        #
        # find y for x = xmin
        #
        _yt = (_slope * _xmin) + _yint
        if _ymin &lt; _yt &lt; _ymax:
            # print "hit at y for x=xmin"
            _x1 = _xmin
            _y1 = _yt
        #
        # find y for x = xmax
        #
        _yt = (_slope * _xmax) + _yint
        if _ymin &lt; _yt &lt; _ymax:
            # print "hit at y for x=xmax"
            if _x1 is None:
                _x1 = _xmax
                _y1 = _yt
            else:
                _x2 = _xmax
                _y2 = _yt
        if _x2 is None:
            #
            # find x for y = ymin
            #
            _xt = (_ymin - _yint)/_slope
            if _xmin &lt; _xt &lt; _xmax:
                # print "hit at x for y=ymin"
                if _x1 is None:
                    _x1 = _xt
                    _y1 = _ymin
                else:
                    _x2 = _xt
                    _y2 = _ymin
        if _x2 is None:
            #
            # find x for y = ymax
            #
            _xt = (_ymax - _yint)/_slope
            if _xmin &lt; _xt &lt; _xmax:
                # print "hit at x for y=ymax"
                if _x1 is None:
                    _x1 = _xt
                    _y1 = _ymax
                else:
                    _x2 = _xt
                    _y2 = _ymax
    return _x1, _y1, _x2, _y2
</t>
<t tx="1.20130426141258.3230">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 - 2013 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# generic dimension classes
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
#class DimString(text.TextBlock):
#    """A class for the visual presentation of the dimensional value.
#
#The DimString class is used to present the numerical display for
#the dimension. A DimString object is derived from the text.TextBlock
#class, so it shares all of that classes methods and attributes.
#
#The DimString class has the following additional properties:
#
#prefix: A prefix prepended to the dimension text
#suffix: A suffix appended to the dimension text
#units: The units the dimension text will display
#precision: The displayed dimension precision
#print_zero: Displayed dimensions will have a leading 0 if needed
#print_decimal: Displayed dimensions will have a trailing decimal point
#
#The DimString class has the following additional methods:
#
#{get/set}Prefix(): Get/Set the text preceding the dimension value.
#{get/set}Suffix(): Get/Set the text following the dimension value.
#{get/set}Units(): Define what units the dimension will be in.
#{get/set}Precision(): Get/Set how many fractional digits are displayed.
#{get/set}PrintZero(): Get/Set whether or not a dimension less than one
#                      unit long should have a leading 0 printed
#{get/set}PrintDecimal(): Get/Set whether or not a dimension with 0
#                         fractional digits prints out the decimal point.
#{get/set}Dimension(): Get/Set the dimension using the DimString
#
#The DimString class has the following classmethods:
#
#{get/set}DefaultTextStyle(): Get/Set the default TextStyle for the class.
#    """
#
#    __defstyle = None
#
#    __messages = {
#        'prefix_changed' : True,
#        'suffix_changed' : True,
#        'units_changed' : True,
#        'precision_changed' : True,
#        'print_zero_changed' : True,
#        'print_decimal_changed' : True,
#        'dimension_changed' : True,
#        }
#
#    def __init__(self, x, y, **kw):
#        """Initialize a DimString object
#
#ds = DimString(x, y, **kw)
#
#Arguments 'x' and 'y' should be floats. Various keyword arguments can
#also be used:
#
#text: Displayed text
#textstyle: The default textstyle
#family: Font family
#style: Font style
#weight: Font weight
#color: Text color
#size: Text size
#angle: Text angle
#align: Text alignment
#prefix: Default prefix
#suffix: Default suffix
#units: Displayed units
#precision: Displayed precision of units
#print_zero: Boolean to print a leading '0'
#print_decimal: Boolean to print a leading '.'
#
#By default, a DimString object has the following values ...
#
#prefix: Empty string
#suffix: Empty string
#unit: Millimeters
#precision: 3 decimal places
#print zero: True
#print decimal: True
#        """
#        _text = u''
#        if 'text' in kw:
#            _text = kw['text']
#        _tstyle = self.getDefaultTextStyle()
#        if 'textstyle' in kw:
#            _tstyle = kw['textstyle']
#            del kw['textstyle']
#        _prefix = u''
#        if 'prefix' in kw:
#            _prefix = kw['prefix']
#            if not isinstance(_prefix, types.StringTypes):
#                raise TypeError, "Invalid prefix type: " + `type(_prefix)`
#        _suffix = u''
#        if 'suffix' in kw:
#            _suffix = kw['suffix']
#            if not isinstance(_suffix, types.StringTypes):
#                raise TypeError, "Invalid suffix type: " + `type(_suffix)`
#        _unit = units.MILLIMETERS
#        if 'units' in kw:
#            _unit = kw['units']
#        _prec = 3
#        if 'precision' in kw:
#            _prec = kw['precision']
#            if not isinstance(_prec, int):
#                raise TypeError, "Invalid precision type: " + `type(_prec)`
#            if _prec &lt; 0 or _prec &gt; 15:
#                raise ValueError, "Invalid precision: %d" % _prec
#        _pz = True
#        if 'print_zero' in kw:
#            _pz = kw['print_zero']
#            util.test_boolean(_pz)
#        _pd = True
#        if 'print_decimal' in kw:
#            _pd = kw['print_decimal']
#            util.test_boolean(_pd)
#        super(DimString, self).__init__(x, y, _text, textstyle=_tstyle, **kw)
#        self.__prefix = _prefix
#        self.__suffix = _suffix
#        self.__unit = units.Unit(_unit)
#        self.__precision = _prec
#        self.__print_zero = _pz
#        self.__print_decimal = _pd
#        self.__dim = None
#
#    def getDefaultTextStyle(cls):
#        if cls.__defstyle is None:
#            _s = text.TextStyle(u'Default Dimension Text Style',
#                                color=color.Color(0xffffff),
#                                align=text.TextStyle.ALIGN_CENTER)
#            cls.__defstyle = _s
#        return cls.__defstyle
#
#    getDefaultTextStyle = classmethod(getDefaultTextStyle)
#
#    def setDefaultTextStyle(cls, s):
#        if not isinstance(s, text.TextStyle):
#            raise TypeError, "Invalid TextStyle: " + `type(s)`
#        cls.__defstyle = s
#
#    setDefaultTextStyle = classmethod(setDefaultTextStyle)
#
#    def finish(self):
#        """Finalization for  DimString instances.
#
#finish()
#        """
#        if self.__dim is not None:
#            self.__dim = None
#        super(DimString, self).finish()
#
#    def getValues(self):
#        """Return values comprising the DimString.
#
#getValues()
#
#This method extends the TextBlock::getValues() method.
#        """
#        _data = super(DimString, self).getValues()
#        _data.setValue('type', 'dimstring')
#        _data.setValue('prefix', self.__prefix)
#        _data.setValue('suffix', self.__suffix)
#        _data.setValue('units', self.__unit.getStringUnit())
#        _data.setValue('precision', self.__precision)
#        _data.setValue('print_zero', self.__print_zero)
#        _data.setValue('print_decimal', self.__print_decimal)
#        return _data
#
#    def getParent(self):
#        """Get the entity containing the DimString.
#
#getParent()
#
#This method overrides the Entity::getParent() call.
#        """
#        _parent = None
#        if self.__dim is not None:
#            _parent = self.__dim.getParent()
#        return _parent
#    
#    def setLocation(self, x, y):
#        """Set the location of the DimString.
#
#setLocation(x, y)
#
#Arguments 'x' and 'y' should be floats. This method extends
#the TextBlock::setLocation() method.
#        """
#        #
#        # the DimString location is defined in relation to
#        # the position defined by the Dimension::setLocation()
#        # call, so don't bother sending out 'moved' or 'modified'
#        # messages
#        #
#        self.mute()
#        try:
#            super(DimString, self).setLocation(x, y)
#        finally:
#            self.unmute()
#
#    def getPrefix(self):
#        """Return the prefix for the DimString object.
#
#getPrefix()
#        """
#        return self.__prefix
#
#    def setPrefix(self, prefix=None):
#        """Set the prefix for the DimString object.
#
#setPrefix([prefix])
#
#Invoking this method without arguments sets the prefix
#to an empty string, or to the DimStyle value in the associated
#Dimension if one is set for the DimString. When an argument
#is passed, the argument should be a Unicode string.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting prefix not allowed - object locked."
#        _p = prefix
#        if _p is None:
#            _p = u''
#            if self.__dim is not None:
#                _p = self.__dim.getStyleValue(self, 'prefix')
#        if not isinstance(_p, unicode):
#            _p = unicode(prefix)
#        _op = self.__prefix
#        if _op != _p:
#            self.startChange('prefix_changed')
#            self.__prefix = _p
#            self.endChange('prefix_changed')
#            self.setBounds()
#            self.sendMessage('prefix_changed', _op)
#            self.modified()
#
#    prefix = property(getPrefix, setPrefix, None, 'Dimension string prefix')
#
#    def getSuffix(self):
#        """Return the suffix for the DimString object.
#
#getSuffix()
#        """
#        return self.__suffix
#
#    def setSuffix(self, suffix=None):
#        """Set the suffix for the DimString object.
#
#setSuffix([suffix])
#
#Invoking this method without arguments sets the suffix
#to an empty string, or to the DimStyle value in the associated
#Dimension if one is set for the DimString.. When an argument
#is passed, the argument should be a Unicode string.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting suffix not allowed - object locked."
#        _s = suffix
#        if _s is None:
#            _s = u''
#            if self.__dim is not None:
#                _s = self.__dim.getStyleValue(self, 'suffix')
#        if not isinstance(_s, unicode):
#            _s = unicode(suffix)
#        _os = self.__suffix
#        if _os != _s:
#            self.startChange('suffix_changed')
#            self.__suffix = _s
#            self.endChange('suffix_changed')
#            self.setBounds()
#            self.sendMessage('suffix_changed', _os)
#            self.modified()
#
#    suffix = property(getSuffix, setSuffix, None, 'Dimension string suffix')
#
#    def getPrecision(self):
#        """Return the number of decimal points used for the DimString.
#
#getPrecision()
#        """
#        return self.__precision
#
#    def setPrecision(self, precision=None):
#        """Set the number of decimal points used for the DimString.
#
#setPrecision([p])
#
#The valid range of p is 0 &lt;= p &lt;= 15. Invoking this method without
#arguments sets the precision to 3, or to the DimStyle value in the
#associated Dimension if one is set for the DimString..
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting precision not allowed - object locked."
#        _p = precision
#        if _p is None:
#            _p = 3
#            if self.__dim is not None:
#                _p = self.__dim.getStyleValue(self, 'precision')
#        if not isinstance(_p, int):
#            raise TypeError, "Invalid precision type: " + `type(_p)`
#        if _p &lt; 0 or _p &gt; 15:
#            raise ValueError, "Invalid precision: %d" % _p
#        _op = self.__precision
#        if _op != _p:
#            self.startChange('precision_changed')
#            self.__precision = _p
#            self.endChange('precision_changed')
#            self.setBounds()
#            self.sendMessage('precision_changed', _op)
#            self.modified()
#
#    precision = property(getPrecision, setPrecision, None,
#                         'Dimension precision')
#
#    def getUnits(self):
#        """Return the current units used in the DimString().
#
#getUnits()
#        """
#        return self.__unit.getUnit()
#
#    def setUnits(self, unit=None):
#        """The the units for the DimString.
#
#setUnits([unit])
#
#The value units are given in the units module. Invoking this
#method without arguments sets the units to millimeters, or
#to the DimStyle value of the associated Dimension if one
#is set for the DimString.
#        """
#        _u = unit
#        if _u is None:
#            _u = units.MILLIMETERS
#            if self.__dim is not None:
#                _u = self.__dim.getStyleValue(self, 'units')
#        _ou = self.__unit.getUnit()
#        if _ou != _u:
#            self.startChange('units_changed')
#            self.__unit.setUnit(_u)
#            self.endChange('units_changed')
#            self.setBounds()
#            self.sendMessage('units_changed', _ou)
#            self.modified()
#
#    units = property(getUnits, setUnits, None, 'Dimensional units.')
#
#    def getPrintZero(self):
#        """Return whether or not a leading 0 is printed for the DimString.
#
#getPrintZero()
#        """
#        return self.__print_zero
#
#    def setPrintZero(self, print_zero=None):
#        """Set whether or not a leading 0 is printed for the DimString.
#
#setPrintZero([pz])
#
#Invoking this method without arguments sets the value to True,
#or to the DimStyle value of the associated Dimension if one is
#set for the DimString. If called with an argument, the argument
#should be either True or False.
#        """
#        _pz = print_zero
#        if _pz is None:
#            _pz = True
#            if self.__dim is not None:
#                _pz = self.__dim.getStyleValue(self, 'print_zero')
#        util.test_boolean(_pz)
#        _flag = self.__print_zero
#        if _flag is not _pz:
#            self.startChange('print_zero_changed')
#            self.__print_zero = _pz
#            self.endChange('print_zero_changed')
#            self.setBounds()
#            self.sendMessage('print_zero_changed', _flag)
#            self.modified()
#
#    print_zero = property(getPrintZero, setPrintZero, None,
#                          'Print a leading 0 for decimal dimensions')
#
#    def getPrintDecimal(self):
#        """Return whether or not the DimString will print a trailing decimal.
#
#getPrintDecimal()
#        """
#        return self.__print_decimal
#
#    def setPrintDecimal(self, print_decimal=None):
#        """Set whether or not the DimString will print a trailing decimal.
#
#setPrintDecimal([pd])
#
#Invoking this method without arguments sets the value to True, or
#to the DimStyle value of the associated Dimension if one is set
#for the DimString. If called with an argument, the argument should
#be either True or False.
#        """
#        _pd = print_decimal
#        if _pd is None:
#            _pd = True
#            if self.__dim is not None:
#                _pd = self.__dim.getStyleValue(self, 'print_decimal')
#        util.test_boolean(_pd)
#        _flag = self.__print_decimal
#        if _flag is not _pd:
#            self.startChange('print_decimal_changed')
#            self.__print_decimal = _pd
#            self.endChange('print_decimal_changed')
#            self.setBounds()
#            self.sendMessage('print_decimal_changed', _flag)
#            self.modified()
#
#    print_decimal = property(getPrintDecimal, setPrintDecimal, None,
#                             'Print a decimal point after the dimension value')
#
#    def getDimension(self):
#        """Return the dimension using the Dimstring.
#
#getDimension()
#
#This method can return None if there is not Dimension association set
#for the DimString.
#        """
#        return self.__dim
#
#    def setDimension(self, dim, adjust):
#        """Set the dimension using this DimString.
#
#setDimension(dim, adjust)
#
#Argument 'dim' must be a Dimension or None, and argument
#'adjust' must be a Boolean. Argument 'adjust' is only used
#if a Dimension is passed for the first argument.
#        """
#        _dim = dim
#        if _dim is not None and not isinstance(_dim, Dimension):
#            raise TypeError, "Invalid dimension: " + `type(_dim)`
#        util.test_boolean(adjust)
#        _d = self.__dim
#        if _d is not _dim:
#            self.startChange('dimension_changed')
#            self.__dim = _dim
#            self.endChange('dimension_changed')
#            if _dim is not None and adjust:
#                self.setPrefix()
#                self.setSuffix()
#                self.setPrecision()
#                self.setUnits()
#                self.setPrintZero()
#                self.setPrintDecimal()
#                self.setFamily()
#                self.setStyle()
#                self.setWeight()
#                self.setColor()
#                self.setSize()
#                self.setAngle()
#                self.setAlignment()
#            self.sendMessage('dimension_changed', _d)
#            self.modified()
#        if self.__dim is not None:
#            self.setParent(self.__dim.getParent())
#
##
## extend the TextBlock set methods to use the values
## found in a DimStyle if one is available
##
#
#    def setFamily(self, family=None):
#        """Set the font family for the DimString.
#
#setFamily([family])
#
#Calling this method without an argument will set the
#family to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _family = family
#        if _family is None and self.__dim is not None:
#            _family = self.__dim.getStyleValue(self, 'font_family')
#        super(DimString, self).setFamily(_family)
#
#    def setStyle(self, style=None):
#        """Set the font style for the DimString.
#
#setStyle([style])
#
#Calling this method without an argument will set the
#font style to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _style = style
#        if _style is None and self.__dim is not None:
#            _style = self.__dim.getStyleValue(self, 'font_style')
#        super(DimString, self).setStyle(_style)
#
#    def setWeight(self, weight=None):
#        """Set the font weight for the DimString.
#
#setWeight([weight])
#
#Calling this method without an argument will set the
#font weight to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _weight = weight
#        if _weight is None and self.__dim is not None:
#            _weight = self.__dim.getStyleValue(self, 'font_weight')
#        super(DimString, self).setWeight(_weight)
#
#    def setColor(self, color=None):
#        """Set the font color for the DimString.
#
#setColor([color])
#
#Calling this method without an argument will set the
#font color to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _color = color
#        if _color is None and self.__dim is not None:
#            _color = self.__dim.getStyleValue(self, 'color')
#        super(DimString, self).setColor(_color)
#
#    def setSize(self, size=None):
#        """Set the text size for the DimString.
#
#setSize([size])
#
#Calling this method without an argument will set the
#text size to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _size = size
#        if _size is None and self.__dim is not None:
#            _size = self.__dim.getStyleValue(self, 'size')
#        super(DimString, self).setSize(_size)
#
#    def setAngle(self, angle=None):
#        """Set the text angle for the DimString.
#
#setAngle([angle])
#
#Calling this method without an argument will set the
#text angle to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _angle = angle
#        if _angle is None and self.__dim is not None:
#            _angle = self.__dim.getStyleValue(self, 'angle')
#        super(DimString, self).setAngle(_angle)
#
#    def setAlignment(self, align=None):
#        """Set the text alignment for the DimString.
#
#setAlignment([align])
#
#Calling this method without an argument will set the
#text alignment to that given in the DimStyle of the associated
#Dimension if one is set for this DimString.
#        """
#        _align = align
#        if _align is None and self.__dim is not None:
#            _align = self.__dim.getStyleValue(self, 'alignment')
#        super(DimString, self).setAlignment(_align)
#
#    def setText(self, text):
#        """Set the text in the DimString.
#
#This method overrides the setText method in the TextBlock.
#        """
#        pass
#
#    def formatDimension(self, dist):
#        """Return a formatted numerical value for a dimension.
#
#formatDimension(dist)
#
#The argument 'dist' should be a float value representing the
#distance in millimeters. The returned value will have the
#prefix prepended and suffix appended to the numerical value
#that has been formatted with the precision.
#        """
#        _d = abs(util.get_float(dist))
#        _fmtstr = u"%%#.%df" % self.__precision
#        _dstr = _fmtstr % self.__unit.fromMillimeters(_d)
#        if _d &lt; 1.0 and self.__print_zero is False:
#            _dstr = _dstr[1:]
#        if _dstr.endswith('.') and self.__print_decimal is False:
#            _dstr = _dstr[:-1]
#        _text = self.__prefix + _dstr + self.__suffix
#        #
#        # don't send out 'text_changed' or 'modified' messages
#        #
#        self.mute()
#        try:
#            super(DimString, self).setText(_text)
#        finally:
#            self.unmute()
#        return _text
#
#    def sendsMessage(self, m):
#        if m in DimString.__messages:
#            return True
#        return super(DimString, self).sendsMessage(m)
#
#class DimBar(entity.Entity):
#    """The class for the dimension bar.
#
#A dimension bar leads from the point the dimension references
#out to, and possibly beyond, the point where the dimension
#text bar the DimBar to another DimBar. Linear,
#horizontal, vertical, and angular dimension will have two
#dimension bars; radial dimensions have none.
#
#The DimBar class has the following methods:
#
#getEndpoints(): Get the x/y position of the DimBar start and end
#{get/set}FirstEndpoint(): Get/Set the starting x/y position of the DimBar.
#{get/set}SecondEndpoint(): Get/Set the ending x/y position of the DimBar.
#getAngle(): Get the angle at which the DimBar slopes
#getSinCosValues(): Get trig values used for transformation calculations.
#    """
#
#    __messages = {
#        'attribute_changed' : True,
#        }
#        
#    def __init__(self, x1=0.0, y1=0.0, x2=0.0, y2=0.0, **kw):
#        """Initialize a DimBar.
#
#db = DimBar([x1, y1, x2, y2])
#
#By default all the arguments are 0.0. Any arguments passed to this
#method should be float values.
#        """
#        _x1 = util.get_float(x1)
#        _y1 = util.get_float(y1)
#        _x2 = util.get_float(x2)
#        _y2 = util.get_float(y2)
#        super(DimBar, self).__init__(**kw)
#        self.__ex1 = _x1
#        self.__ey1 = _y1
#        self.__ex2 = _x2
#        self.__ey2 = _y2
#
#    def getEndpoints(self):
#        """Return the coordinates of the DimBar endpoints.
#
#getEndpoints()
#
#This method returns two tuples, each containing two float values.
#The first tuple gives the x/y coordinates of the DimBar start,
#the second gives the coordinates of the DimBar end.
#        """
#        _ep1 = (self.__ex1, self.__ey1)
#        _ep2 = (self.__ex2, self.__ey2)
#        return _ep1, _ep2
#
#    def setFirstEndpoint(self, x, y):
#        """Set the starting coordinates for the DimBar
#
#setFirstEndpoint(x, y)
#
#Arguments x and y should be float values.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting endpoint not allowed - object locked."
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _sx = self.__ex1
#        _sy = self.__ey1
#        if abs(_sx - _x) &gt; 1e-10 or abs(_sy - _y) &gt; 1e-10:
#            self.__ex1 = _x
#            self.__ey1 = _y
#            self.sendMessage('attribute_changed', 'endpoint', _sx, _sy,
#                             self.__ex2, self.__ey2)
#            self.modified()
#
#    def getFirstEndpoint(self):
#        """Return the starting coordinates of the DimBar.
#
#getFirstEndpoint()
#
#This method returns a tuple giving the x/y coordinates.
#        """
#        return self.__ex1, self.__ey1
#
#    def setSecondEndpoint(self, x, y):
#        """Set the ending coordinates for the DimBar
#
#setSecondEndpoint(x, y)
#
#Arguments x and y should be float values.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting endpoint not allowed - object locked."
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _sx = self.__ex2
#        _sy = self.__ey2
#        if abs(_sx - _x) &gt; 1e-10 or abs(_sy - _y) &gt; 1e-10:
#            self.__ex2 = _x
#            self.__ey2 = _y
#            self.sendMessage('attribute_changed', 'endpoint',
#                             self.__ex1, self.__ey1, _sx, _sy)
#            self.modified()
#
#    def getSecondEndpoint(self):
#        """Return the ending coordinates of the DimBar.
#
#getSecondEndpoint()
#
#This method returns a tuple giving the x/y coordinates.
#        """
#        return self.__ex2, self.__ey2
#
#    def getAngle(self):
#        """Return the angle at which the DimBar lies.
#
#getAngle()
#
#This method returns a float value giving the angle of inclination
#of the DimBar.
#
#The value returned will be a positive value less than 360.0.
#        """
#        _x1 = self.__ex1
#        _y1 = self.__ey1
#        _x2 = self.__ex2
#        _y2 = self.__ey2
#        if abs(_x2 - _x1) &lt; 1e-10 and abs(_y2 - _y1) &lt; 1e-10:
#            raise ValueError, "Endpoints are equal"
#        if abs(_x2 - _x1) &lt; 1e-10: # vertical
#            if _y2 &gt; _y1:
#                _angle = 90.0
#            else:
#                _angle = 270.0
#        elif abs(_y2 - _y1) &lt; 1e-10: # horizontal
#            if _x2 &gt; _x1:
#                _angle = 0.0
#            else:
#                _angle = 180.0
#        else:
#            _angle = _rtd * math.atan2((_y2 - _y1), (_x2 - _x1))
#            if _angle &lt; 0.0:
#                _angle = _angle + 360.0
#        return _angle
#
#    def getSinCosValues(self):
#        """Return sin()/cos() values based on the DimBar slope
#
#getSinCosValues()
#
#This method returns a tuple of two floats. The first value is
#the sin() value, the second is the cos() value.
#        """
#        _x1 = self.__ex1
#        _y1 = self.__ey1
#        _x2 = self.__ex2
#        _y2 = self.__ey2
#        if abs(_x2 - _x1) &lt; 1e-10: # vertical
#            _cosine = 0.0
#            if _y2 &gt; _y1:
#                _sine = 1.0
#            else:
#                _sine = -1.0
#        elif abs(_y2 - _y1) &lt; 1e-10: # horizontal
#            _sine = 0.0
#            if _x2 &gt; _x1:
#                _cosine = 1.0
#            else:
#                _cosine = -1.0
#        else:
#            _angle = math.atan2((_y2 - _y1), (_x2 - _x1))
#            _sine = math.sin(_angle)
#            _cosine = math.cos(_angle)
#        return _sine, _cosine
#
#    def sendsMessage(self, m):
#        if m in DimBar.__messages:
#            return True
#        return super(DimBar, self).sendsMessage(m)
#
#class DimCrossbar(DimBar):
#    """The class for the Dimension crossbar.
#
#The DimCrossbar class is drawn between two DimBar objects for
#horizontal, vertical, and generic linear dimensions. The dimension
#text is place over the DimCrossbar object. Arrow heads, circles, or
#slashes can be drawn at the intersection of the DimCrossbar and
#the DimBar if desired. These objects are called markers.
#
#The DimCrossbar class is derived from the DimBar class so it shares
#all the methods of that class. In addition the DimCrossbar class has
#the following methods:
#
#{set/get}FirstCrossbarPoint(): Set/Get the initial location of the crossbar.
#{set/get}SecondCrossbarPoint(): Set/Get the ending location of the crossbar.
#getCrossbarPoints(): Get the location of the crossbar endpoints.
#clearMarkerPoints(): Delete the stored coordintes of the dimension markers.
#storeMarkerPoint(): Save a coordinate pair of the dimension marker.
#getMarkerPoints(): Return the coordinates of the dimension marker.
#    """
#    __messages = {}
#    
#    def __init__(self, **kw):
#        """Initialize a DimCrossbar object.
#
#dcb = DimCrossbar()
#
#This method takes no arguments.
#        """
#        super(DimCrossbar, self).__init__(**kw)
#        self.__mx1 = 0.0
#        self.__my1 = 0.0
#        self.__mx2 = 0.0
#        self.__my2 = 0.0
#        self.__mpts = []
#
#    def setFirstCrossbarPoint(self, x, y):
#        """Store the initial endpoint of the DimCrossbar.
#
#setFirstCrossbarPoint(x, y)
#
#Arguments x and y should be floats.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting crossbar point not allowed - object locked."
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _sx = self.__mx1
#        _sy = self.__my1
#        if abs(_sx - _x) &gt; 1e-10 or abs(_sy - _y) &gt; 1e-10:
#            self.__mx1 = _x
#            self.__my1 = _y
#            self.sendMessage('attribute_changed', 'barpoint', _sx, _sy,
#                             self.__mx2, self.__my2)
#            self.modified()
#
#    def getFirstCrossbarPoint(self):
#        """Return the initial coordinates of the DimCrossbar.
#
#getFirstCrossbarPoint()
#
#This method returns a tuple of two floats giving the x/y coordinates.
#        """
#        return self.__mx1, self.__my1
#
#    def setSecondCrossbarPoint(self, x, y):
#        """Store the terminal endpoint of the DimCrossbar.
#
#setSecondCrossbarPoint(x, y)
#
#Arguments 'x' and 'y' should be floats.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting crossbar point not allowed - object locked"
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _sx = self.__mx2
#        _sy = self.__my2
#        if abs(_sx - _x) &gt; 1e-10 or abs(_sy - _y) &gt; 1e-10:
#            self.__mx2 = _x
#            self.__my2 = _y
#            self.sendMessage('attribute_changed', 'barpoint',
#                             self.__mx1, self.__my1, _sx, _sy)
#            self.modified()
#
#    def getSecondCrossbarPoint(self):
#        """Return the terminal coordinates of the DimCrossbar.
#
#getSecondCrossbarPoint()
#
#This method returns a tuple of two floats giving the x/y coordinates.
#        """
#        return self.__mx2, self.__my2
#
#    def getCrossbarPoints(self):
#        """Return the endpoints of the DimCrossbar.
#
#getCrossbarPoints()
#
#This method returns two tuples, each tuple containing two float
#values giving the x/y coordinates.
#        """
#        _mp1 = (self.__mx1, self.__my1)
#        _mp2 = (self.__mx2, self.__my2)
#        return _mp1, _mp2
#
#    def clearMarkerPoints(self):
#        """Delete the stored location of any dimension markers.
#
#clearMarkerPoints()
#        """
#        del self.__mpts[:]
#
#    def storeMarkerPoint(self, x, y):
#        """Save a coordinate pair of the current dimension marker.
#
#storeMarkerPoint(x, y)
#
#Arguments 'x' and 'y' should be floats. Each time this method is invoked
#the list of stored coordinates is appended with the values given as
#arguments.
#        """
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        self.__mpts.append((_x, _y))
#
#    def getMarkerPoints(self):
#        """Return the stored marker coordinates.
#
#getMarkerPoints()
#
#This method returns a list of coordinates stored with storeMarkerPoint().
#Each item in the list is a tuple holding two float values - the x/y
#coordinate of the point.
#        """
#        return self.__mpts[:]
#
#    def sendsMessage(self, m):
#        if m in DimCrossbar.__messages:
#            return True
#        return super(DimCrossbar, self).sendsMessage(m)
#
#class DimCrossarc(DimCrossbar):
#    """The class for specialized crossbars for angular dimensions.
#
#The DimCrossarc class is meant to be used only with angular dimensions.
#As an angular dimension has two DimBar objects that are connected
#with an arc. The DimCrossarc class is derived from the DimCrossbar
#class so it shares all the methods of that class. The DimCrossarc
#class has the following additional methods:
#
#{get/set}Radius(): Get/Set the radius of the arc.
#{get/set}StartAngle(): Get/Set the arc starting angle.
#{get/set}EndAngle(): Get/Set the arc finishing angle.
#    """
#
#    __messages = {
#        'arcpoint_changed' : True,
#        'radius_changed' : True,
#        'start_angle_changed' : True,
#        'end_angle_changed' : True,
#        }
#        
#    def __init__(self, radius=0.0, start=0.0, end=0.0, **kw):
#        """Initialize a DimCrossarc object.
#
#dca = DimCrossarc([radius, start, end])
#
#By default the arguments are all 0.0. Any arguments passed to
#this method should be floats.
#        """
#        super(DimCrossarc, self).__init__(**kw)
#        _r = util.get_float(radius)
#        if _r &lt; 0.0:
#            raise ValueError, "Invalid radius: %g" % _r
#        _start = util.make_c_angle(start)
#        _end = util.make_c_angle(end)
#        self.__radius = _r
#        self.__start = _start
#        self.__end = _end
#
#    def getRadius(self):
#        """Return the radius of the arc.
#
#getRadius()
#
#This method returns a float value.
#        """
#        return self.__radius
#
#    def setRadius(self, radius):
#        """Set the radius of the arc.
#
#setRadius(radius)
#
#Argument 'radius' should be a float value greater than 0.0.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting radius not allowed - object locked."
#        _r = util.get_float(radius)
#        if _r &lt; 0.0:
#            raise ValueError, "Invalid radius: %g" % _r
#        _sr = self.__radius
#        if abs(_sr - _r) &gt; 1e-10:
#            self.startChange('radius_changed')
#            self.__radius = _r
#            self.endChange('radius_changed')
#            self.sendMessage('radius_changed', _sr)
#            self.modified()
#
#    def getStartAngle(self):
#        """Return the arc starting angle.
#
#getStartAngle()
#
#This method returns a float.
#        """
#        return self.__start
#
#    def setStartAngle(self, angle):
#        """Set the starting angle of the arc.
#
#setStartAngle(angle)
#
#Argument angle should be a float value.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting start angle not allowed - object locked."
#        _sa = self.__start
#        _angle = util.make_c_angle(angle)
#        if abs(_sa - _angle) &gt; 1e-10:
#            self.startChange('start_angle_changed')
#            self.__start = _angle
#            self.endChange('start_angle_changed')
#            self.sendMessage('start_angle_changed', _sa)
#            self.modified()
#
#    def getEndAngle(self):
#        """Return the arc ending angle.
#
#getEndAngle()
#
#This method returns a float.
#        """
#        return self.__end
#
#    def setEndAngle(self, angle):
#        """Set the ending angle of the arc.
#
#setEndAngle(angle)
#
#Argument angle should be a float value.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting end angle not allowed - object locked."
#        _ea = self.__end
#        _angle = util.make_c_angle(angle)
#        if abs(_ea - _angle) &gt; 1e-10:
#            self.startChange('end_angle_changed')
#            self.__end = _angle
#            self.endChange('end_angle_changed')
#            self.sendMessage('end_angle_changed', _ea)
#            self.modified()
#
#    def getAngle(self):
#        pass # override the DimBar::getAngle() method
#
#    def getSinCosValues(self):
#        pass # override the DimBar::getSinCosValues() method
#
#    def sendsMessage(self, m):
#        if m in DimCrossarc.__messages:
#            return True
#        return super(DimCrossarc, self).sendsMessage(m)
#
#class Dimension(entity.Entity):
#    """The base class for Dimensions
#
#A Dimension object is meant to be a base class for specialized
#dimensions.
#
#Every Dimension object holds two DimString objects, so any
#dimension can be displayed with two separate formatting options
#and units.
#
#A Dimension has the following methods
#
#{get/set}DimStyle(): Get/Set the DimStyle used for this Dimension.
#getPrimaryDimstring(): Return the DimString used for formatting the
#                       Primary dimension.
#getSecondaryDimstring(): Return the DimString used for formatting the
#                         Secondary dimension.
#{get/set}EndpointType(): Get/Set the type of endpoints used in the Dimension
#{get/set}EndpointSize(): Get/Set the size of the dimension endpoints
#{get/set}DualDimMode(): Get/Set whether or not to display both the Primary
#                        and Secondary DimString objects
#{get/set}Offset(): Get/Set how far from the dimension endpoints to draw
#                   dimension lines at the edges of the dimension.
#{get/set}Extension(): Get/Set how far past the dimension crossbar line
#                      to draw.
#{get/set}Position(): Get/Set where the dimensional values are placed on the
#                     dimension cross bar.
#{get/set}Color(): Get/Set the color used to draw the dimension lines.
#{get/set}Location(): Get/Set where to draw the dimensional values.
#{get/set}PositionOffset(): Get/Set the dimension text offset when the text is
#                           above or below the crossbar/crossarc
#{get/set}DualModeOffset(): Get/Set the text offset for spaceing the two
#                           dimension strings above and below the bar
#                           separating the two dimensions
#{get/set}Thickness(): Get/Set the Dimension thickness.
#{get/set}Scale(): Get/Set the Dimension scaling factor.
#getStyleValue(): Return the DimStyle value for some option
#getDimensions(): Return the formatted dimensional values in this Dimension.
#inRegion(): Return if the dimension is visible within some are.
#calcDimValues(): Calculate the dimension lines endpoints.
#mapCoords(): Return the coordinates on the dimension within some point.
#onDimension(): Test if an x/y coordinate pair hit the dimension lines.
#getBounds(): Return the minma and maximum locations of the dimension.
#
#The Dimension class has the following classmethods:
#
#{get/set}DefaultDimStyle(): Get/Set the default DimStyle for the class.
#getEndpointTypeAsString(): Return the endpoint type as a string for a value.
#getEndpointTypeFromString(): Return the endpoint type value given a string.
#getEndpointTypeStrings(): Get the endpoint types values as strings.
#getEndpointTypeValues(): Get the endpoint type values.
#getPositionAsString(): Return the text position as a string for a value.
#getPositionFromString(): Return the text postion value given a string.
#getPositionStrings(): Get the text position values as strings.
#getPositionValues(): Get the text position values.
#
#    """
#    #
#    # Endpoint
#    #
#    DIM_ENDPT_NONE= 0
#    DIM_ENDPT_ARROW = 1
#    DIM_ENDPT_FILLED_ARROW = 2
#    DIM_ENDPT_SLASH = 3
#    DIM_ENDPT_CIRCLE = 4
#
#    #
#    # Dimension position on dimline
#    #
#    DIM_TEXT_POS_SPLIT = 0
#    DIM_TEXT_POS_ABOVE = 1
#    DIM_TEXT_POS_BELOW = 2
#
#    __defstyle = None
#
#    __messages = {
#        'dimstyle_changed' : True,
#        'endpoint_type_changed' : True,
#        'endpoint_size_changed' : True,
#        'dual_mode_changed' : True,
#        'offset_changed' : True,
#        'extension_changed' : True,
#        'position_changed' : True,
#        'position_offset_changed' : True,
#        'dual_mode_offset_changed' : True,
#        'color_changed' :  True,
#        'thickness_changed' : True,
#        'scale_changed' : True,
#        'location_changed' : True,
#        'dimstring_changed' : True,
#        'moved' : True,
#        }
#        
#    def __init__(self, x, y, dimstyle=None, **kw):
#        """Initialize a Dimension object
#
#dim = Dimension(x, y[, ds])
#
#Arguments 'x' and 'y' should be float values. Optional argument
#'ds' should be a DimStyle instance. A default DimStyle is used
#of the optional argument is not used.
#        """
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _ds = dimstyle
#        if _ds is None:
#            _ds = self.getDefaultDimStyle()
#        if not isinstance(_ds, DimStyle):
#            raise TypeError, "Invalid DimStyle type: " + `type(_ds)`
#        _ddm = None
#        if 'dual-mode' in kw:
#            _ddm = kw['dual-mode']
#        if _ddm is not None:
#            util.test_boolean(_ddm)
#            if _ddm is _ds.getValue('DIM_DUAL_MODE'):
#                _ddm = None
#        _offset = None
#        if 'offset' in kw:
#            _offset = util.get_float(kw['offset'])
#        if _offset is not None:
#            if _offset &lt; 0.0:
#                raise ValueError, "Invalid dimension offset: %g" % _offset
#            if abs(_offset - _ds.getValue('DIM_OFFSET')) &lt; 1e-10:
#                _offset = None
#        _extlen = None
#        if 'extlen' in kw:
#            _extlen = util.get_float(kw['extlen'])
#            if _extlen &lt; 0.0:
#                raise ValueError, "Invalid dimension extension: %g" % _extlen
#            if abs(_extlen - _ds.getValue('DIM_EXTENSION')) &lt; 1e-10:
#                _extlen = None
#        _textpos = None
#        if 'textpos' in kw:
#            _textpos = kw['textpos']
#            if (_textpos != Dimension.DIM_TEXT_POS_SPLIT and
#                _textpos != Dimension.DIM_TEXT_POS_ABOVE and
#                _textpos != Dimension.DIM_TEXT_POS_BELOW):
#                raise ValueError, "Invalid dimension text position: '%s'" % str(_textpos)
#            if _textpos == _ds.getValue('DIM_POSITION'):
#                _textpos = None
#        _poffset = None
#        if 'poffset' in kw:
#            _poffset = util.get_float(kw['poffset'])
#            if _poffset &lt; 0.0:
#                raise ValueError, "Invalid text offset length %g" % _poffset
#            if abs(_poffset - _ds.getValue('DIM_POSITION_OFFSET')) &lt; 1e-10:
#                _poffset = None
#        _dmoffset = None
#        if 'dmoffset' in kw:
#            _dmoffset = util.get_float(kw['dmoffset'])
#            if _dmoffset &lt; 0.0:
#                raise ValueError, "Invalid dual mode offset length %g" % _dmoffset
#            if abs(_dmoffset - _ds.getValue('DIM_DUAL_MODE_OFFSET')) &lt; 1e-10:
#                _dmoffset = None
#        _eptype = None
#        if 'eptype' in kw:
#            _eptype = kw['eptype']
#            if (_eptype != Dimension.DIM_ENDPT_NONE and
#                _eptype != Dimension.DIM_ENDPT_ARROW and
#                _eptype != Dimension.DIM_ENDPT_FILLED_ARROW and
#                _eptype != Dimension.DIM_ENDPT_SLASH and
#                _eptype != Dimension.DIM_ENDPT_CIRCLE):
#                raise ValueError, "Invalid endpoint: '%s'" % str(_eptype)
#            if _eptype == _ds.getValue('DIM_ENDPOINT'):
#                _eptype = None
#        _epsize = None
#        if 'epsize' in kw:
#            _epsize = util.get_float(kw['epsize'])
#            if _epsize &lt; 0.0:
#                raise ValueError, "Invalid endpoint size %g" % _epsize
#            if abs(_epsize - _ds.getValue('DIM_ENDPOINT_SIZE')) &lt; 1e-10:
#                _epsize = None
#        _color = None
#        if 'color' in kw:
#            _color = kw['color']
#            if not isinstance(_color, color.Color):
#                raise TypeError, "Invalid color type: " + `type(_color)`
#            if _color == _ds.getValue('DIM_COLOR'):
#                _color = None
#        _thickness = None
#        if 'thickness' in kw:
#            _thickness = util.get_float(kw['thickness'])
#            if _thickness &lt; 0.0:
#                raise ValueError, "Invalid thickness: %g" % _thickness
#            if abs(_thickness - _ds.getValue('DIM_THICKNESS')) &lt; 1e-10:
#                _thickness = None
#        _scale = 1.0
#        if 'scale' in kw:
#            _scale = util.get_float(kw['scale'])
#            if not _scale &gt; 0.0:
#                raise ValueError, "Invalid scale: %g" % _scale
#        #
#        # dimstrings
#        #
#        # the setDimension() call will adjust the values in the
#        # new DimString instances if they get created
#        #
#        _ds1 = _ds2 = None
#        _ds1adj = _ds2adj = True
#        if 'ds1' in kw:
#            _ds1 = kw['ds1']
#            if not isinstance(_ds1, DimString):
#                raise TypeError, "Invalid DimString type: " + `type(_ds1)`
#            _ds1adj = False
#        if _ds1 is None:
#            _ds1 = DimString(_x, _y)
#        #
#        if 'ds2' in kw:
#            _ds2 = kw['ds2']
#            if not isinstance(_ds2, DimString):
#                raise TypeError, "Invalid DimString type: " + `type(_ds2)`
#            _ds2adj = False
#        if _ds2 is None:
#            _ds2 = DimString(_x, _y)
#        #
#        # finally ...
#        #
#        super(Dimension, self).__init__(**kw)
#        self.__dimstyle = _ds
#        self.__ddm = _ddm
#        self.__offset = _offset
#        self.__extlen = _extlen
#        self.__textpos = _textpos
#        self.__poffset = _poffset
#        self.__dmoffset = _dmoffset
#        self.__eptype = _eptype
#        self.__epsize = _epsize
#        self._color = _color
#        self.__thickness = _thickness
#        self.__scale = _scale
#        self.__dimloc = (_x, _y)
#        self.__ds1 = _ds1
#        self.__ds2 = _ds2
#        self.__ds1.setDimension(self, _ds1adj)
#        self.__ds2.setDimension(self, _ds2adj)
#        _ds1.connect('change_pending', self.__dimstringChangePending)
#        _ds1.connect('change_complete', self.__dimstringChangeComplete)
#        _ds2.connect('change_pending', self.__dimstringChangePending)
#        _ds2.connect('change_complete', self.__dimstringChangeComplete)
#
#    def getDefaultDimStyle(cls):
#        if cls.__defstyle is None:
#            cls.__defstyle = DimStyle(u'Default DimStyle')
#        return cls.__defstyle
#
#    getDefaultDimStyle = classmethod(getDefaultDimStyle)
#
#    def setDefaultDimStyle(cls, s):
#        if not isinstance(s, DimStyle):
#            raise TypeError, "Invalid DimStyle: " + `type(s)`
#        cls.__defstyle = s
#
#    setDefaultDimStyle = classmethod(setDefaultDimStyle)
#
#    def finish(self):
#        self.__ds1.disconnect(self)
#        self.__ds2.disconnect(self)
#        self.__ds1.finish()
#        self.__ds2.finish()
#        self.__ds1 = self.__ds2 = None
#        super(Dimension, self).finish()
#
#    def getValues(self):
#        """Return values comprising the Dimension.
#
#getValues()
#
#This method extends the Entity::getValues() method.
#        """
#        _data = super(Dimension, self).getValues()
#        _data.setValue('location', self.__dimloc)
#        if self.__offset is not None:
#            _data.setValue('offset', self.__offset)
#        if self.__extlen is not None:
#            _data.setValue('extension', self.__extlen)
#        if self.__textpos is not None:
#            _data.setValue('position', self.__textpos)
#        if self.__eptype is not None:
#            _data.setValue('eptype', self.__eptype)
#        if self.__epsize is not None:
#            _data.setValue('epsize', self.__epsize)
#        if self._color is not None:
#            _data.setValue('color', self._color.getColors())
#        if self.__ddm is not None:
#            _data.setValue('dualmode', self.__ddm)
#        if self.__poffset is not None:
#            _data.setValue('poffset', self.__poffset)
#        if self.__dmoffset is not None:
#            _data.setValue('dmoffset', self.__dmoffset)
#        if self.__thickness is not None:
#            _data.setValue('thickness', self.__thickness)
#        _data.setValue('ds1', self.__ds1.getValues())
#        _data.setValue('ds2', self.__ds2.getValues())
#        _data.setValue('dimstyle', self.__dimstyle.getValues())
#        return _data
#
#    def getDimStyle(self):
#        """Return the DimStyle used in this Dimension.
#
#getDimStyle()
#        """
#        return self.__dimstyle
#
#    def setDimStyle(self, ds):
#        """Set the DimStyle used for this Dimension.
#
#setDimStyle(ds)
#
#After setting the DimStyle, the values stored in it
#are applied to the DimensionObject.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Changing dimstyle not allowed - object locked."
#        if not isinstance(ds, DimStyle):
#            raise TypeError, "Invalid DimStyle type: " + `type(ds)`
#        _sds = self.__dimstyle
#        if ds is not _sds:
#            _opts = self.getValues()
#            self.startChange('dimstyle_changed')
#            self.__dimstyle = ds
#            self.endChange('dimstyle_changed')
#            #
#            # call the various methods without arguments
#            # so the values given in the new DimStyle are used
#            #
#            self.setOffset()
#            self.setExtension()
#            self.setPosition()
#            self.setEndpointType()
#            self.setEndpointSize()
#            self.setColor()
#            self.setThickness()
#            self.setDualDimMode()
#            self.setPositionOffset()
#            self.setDualModeOffset()
#            #
#            # set the values in the two DimString instances
#            #
#            _d = self.__ds1
#            _d.setPrefix(ds.getValue('DIM_PRIMARY_PREFIX'))
#            _d.setSuffix(ds.getValue('DIM_PRIMARY_SUFFIX'))
#            _d.setPrecision(ds.getValue('DIM_PRIMARY_PRECISION'))
#            _d.setUnits(ds.getValue('DIM_PRIMARY_UNITS'))
#            _d.setPrintZero(ds.getValue('DIM_PRIMARY_LEADING_ZERO'))
#            _d.setPrintDecimal(ds.getValue('DIM_PRIMARY_TRAILING_DECIMAL'))
#            _d.setFamily(ds.getValue('DIM_PRIMARY_FONT_FAMILY'))
#            _d.setWeight(ds.getValue('DIM_PRIMARY_FONT_WEIGHT'))
#            _d.setStyle(ds.getValue('DIM_PRIMARY_FONT_STYLE'))
#            _d.setColor(ds.getValue('DIM_PRIMARY_FONT_COLOR'))
#            _d.setSize(ds.getValue('DIM_PRIMARY_TEXT_SIZE'))
#            _d.setAngle(ds.getValue('DIM_PRIMARY_TEXT_ANGLE'))
#            _d.setAlignment(ds.getVaue('DIM_PRIMARY_TEXT_ALIGNMENT'))
#            _d = self.__ds2
#            _d.setPrefix(ds.getValue('DIM_SECONDARY_PREFIX'))
#            _d.setSuffix(ds.getValue('DIM_SECONDARY_SUFFIX'))
#            _d.setPrecision(ds.getValue('DIM_SECONDARY_PRECISION'))
#            _d.setUnits(ds.getValue('DIM_SECONDARY_UNITS'))
#            _d.setPrintZero(ds.getValue('DIM_SECONDARY_LEADING_ZERO'))
#            _d.setPrintDecimal(ds.getValue('DIM_SECONDARY_TRAILING_DECIMAL'))
#            _d.setFamily(ds.getValue('DIM_SECONDARY_FONT_FAMILY'))
#            _d.setWeight(ds.getValue('DIM_SECONDARY_FONT_WEIGHT'))
#            _d.setStyle(ds.getValue('DIM_SECONDARY_FONT_STYLE'))
#            _d.setColor(ds.getValue('DIM_SECONDARY_FONT_COLOR'))
#            _d.setSize(ds.getValue('DIM_SECONDARY_TEXT_SIZE'))
#            _d.setAngle(ds.getValue('DIM_SECONDARY_TEXT_ANGLE'))
#            _d.setAlignment(ds.getVaue('DIM_SECONDARY_TEXT_ALIGNMENT'))
#            self.sendMessage('dimstyle_changed', _sds, _opts)
#            self.modified()
#
#    dimstyle = property(getDimStyle, setDimStyle, None,
#                        "Dimension DimStyle object.")
#
#    def getEndpointTypeAsString(cls, ep):
#        """Return a text string for the dimension endpoint type.
#
#getEndpointTypeAsString(ep)
#
#This classmethod returns 'none', 'arrow', or 'filled-arrow', 'slash',
#or 'circle'.
#        """
#        if not isinstance(ep, int):
#            raise TypeError, "Invalid argument type: " + `type(ep)`
#        if ep == Dimension.DIM_ENDPT_NONE:
#            _str = 'none'
#        elif ep == Dimension.DIM_ENDPT_ARROW:
#            _str = 'arrow'
#        elif ep == Dimension.DIM_ENDPT_FILLED_ARROW:
#            _str = 'filled-arrow'
#        elif ep == Dimension.DIM_ENDPT_SLASH:
#            _str = 'slash'
#        elif ep == Dimension.DIM_ENDPT_CIRCLE:
#            _str = 'circle'
#        else:
#            raise ValueError, "Unexpected endpoint type value: %d" % ep
#        return _str
#
#    getEndpointTypeAsString = classmethod(getEndpointTypeAsString)
#
#    def getEndpointTypeFromString(cls, s):
#        """Return the dimension endpoint type given a string argument.
#
#getEndpointTypeFromString(ep)
#
#This classmethod returns a value based on the string argument:
#
#'none' -&gt; Dimension.DIM_ENDPT_NONE
#'arrow' -&gt; Dimension.DIM_ENDPT_ARROW
#'filled-arrow' -&gt; Dimension.DIM_ENDPT_FILLED_ARROW
#'slash' -&gt; Dimension.DIM_ENDPT_SLASH
#'circle' -&gt; Dimension.DIM_ENDPT_CIRCLE
#
#If the string is not listed above a ValueError execption is raised.
#        """
#        if not isinstance(s, str):
#            raise TypeError, "Invalid argument type: " + `type(s)`
#        _ls = s.lower()
#        if _ls == 'none':
#            _v = Dimension.DIM_ENDPT_NONE
#        elif _ls == 'arrow':
#            _v = Dimension.DIM_ENDPT_ARROW
#        elif (_ls == 'filled-arrow' or _ls == 'filled_arrow'):
#            _v = Dimension.DIM_ENDPT_FILLED_ARROW
#        elif _ls == 'slash':
#            _v = Dimension.DIM_ENDPT_SLASH
#        elif _ls == 'circle':
#            _v = Dimension.DIM_ENDPT_CIRCLE
#        else:
#            raise ValueError, "Unexpected endpoint type string: " + s
#        return _v
#
#    getEndpointTypeFromString = classmethod(getEndpointTypeFromString)
#
#    def getEndpointTypeStrings(cls):
#        """Return the endpoint types as strings.
#
#getEndpointTypeStrings()
#
#This classmethod returns a list of strings.
#        """
#        return [_('None'),
#                _('Arrow'),
#                _('Filled-Arrow'),
#                _('Slash'),
#                _('Circle')
#                ]
#
#    getEndpointTypeStrings = classmethod(getEndpointTypeStrings)
#
#    def getEndpointTypeValues(cls):
#        """Return the endpoint type values.
#
#getEndpointTypeValues()
#
#This classmethod returns a list of values.
#        """
#        return [Dimension.DIM_ENDPT_NONE,
#                Dimension.DIM_ENDPT_ARROW,
#                Dimension.DIM_ENDPT_FILLED_ARROW,
#                Dimension.DIM_ENDPT_SLASH,
#                Dimension.DIM_ENDPT_CIRCLE
#                ]
#
#    getEndpointTypeValues = classmethod(getEndpointTypeValues)
#    
#    def getEndpointType(self):
#        """Return what type of endpoints the Dimension uses.
#
#getEndpointType()
#        """
#        _et = self.__eptype
#        if _et is None:
#            _et = self.__dimstyle.getValue('DIM_ENDPOINT')
#        return _et
#
#    def setEndpointType(self, eptype=None):
#        """Set what type of endpoints the Dimension will use.
#
#setEndpointType([e])
#
#The argument 'e' should be one of the following
#
#dimension.NO_ENDPOINT =&gt; no special marking at the dimension crossbar ends
#dimension.ARROW =&gt; an arrowhead at the dimension crossbar ends
#dimension.FILLED_ARROW =&gt; a filled arrohead at the dimension crossbar ends
#dimension.SLASH =&gt; a slash mark at the dimension crossbar ends
#dimension.CIRCLE =&gt; a filled circle at the dimension crossbar ends
#
#If this method is called without an argument, the endpoint type is set
#to that given in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Changing endpoint type allowed - object locked."
#        _ep = eptype
#        if _ep is not None:
#            if (_ep != Dimension.DIM_ENDPT_NONE and
#                _ep != Dimension.DIM_ENDPT_ARROW and
#                _ep != Dimension.DIM_ENDPT_FILLED_ARROW and
#                _ep != Dimension.DIM_ENDPT_SLASH and
#                _ep != Dimension.DIM_ENDPT_CIRCLE):
#                raise ValueError, "Invalid endpoint value: '%s'" % str(_ep)
#        _et = self.getEndpointType()
#        if ((_ep is None and self.__eptype is not None) or
#            (_ep is not None and _ep != _et)):
#            self.startChange('endpoint_type_changed')
#            self.__eptype = _ep
#            self.endChange('endpoint_type_changed')
#            self.calcDimValues()
#            self.sendMessage('endpoint_type_changed', _et)
#            self.modified()
#
#    endpoint = property(getEndpointType, setEndpointType,
#                        None, "Dimension endpoint type.")
#
#    def getEndpointSize(self):
#        """Return the size of the Dimension endpoints.
#
#getEndpointSize()
#        """
#        _es = self.__epsize
#        if _es is None:
#            _es = self.__dimstyle.getValue('DIM_ENDPOINT_SIZE')
#        return _es
#
#    def setEndpointSize(self, size=None):
#        """Set the size of the Dimension endpoints.
#
#setEndpointSize([size])
#
#Optional argument 'size' should be a float greater than or equal to 0.0.
#Calling this method without an argument sets the endpoint size to that
#given in the DimStle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Changing endpoint type allowed - object locked."
#        _size = size
#        if _size is not None:
#            _size = util.get_float(_size)
#            if _size &lt; 0.0:
#                raise ValueError, "Invalid endpoint size: %g" % _size
#        _es = self.getEndpointSize()
#        if ((_size is None and self.__epsize is not None) or
#            (_size is not None and abs(_size - _es) &gt; 1e-10)):
#            self.startChange('endpoint_size_changed')
#            self.__epsize = _size
#            self.endChange('endpoint_size_changed')
#            self.calcDimValues()
#            self.sendMessage('endpoint_size_changed', _es)
#            self.modified()
#
#    def getDimstrings(self):
#        """Return both primary and secondry dimstrings.
#
#getDimstrings()
#        """
#        return self.__ds1, self.__ds2
#
#    def getPrimaryDimstring(self):
#        """ Return the DimString used for formatting the primary dimension.
#
#getPrimaryDimstring()
#        """
#        return self.__ds1
#
#    def getSecondaryDimstring(self):
#        """Return the DimString used for formatting the secondary dimension.
#
#getSecondaryDimstring()
#        """
#        return self.__ds2
#
#    def getDualDimMode(self):
#        """Return if the Dimension is displaying primary and secondary values.
#
#getDualDimMode(self)
#        """
#        _mode = self.__ddm
#        if _mode is None:
#            _mode = self.__dimstyle.getValue('DIM_DUAL_MODE')
#        return _mode
#
#    def setDualDimMode(self, mode=None):
#        """Set the Dimension to display both primary and secondary values.
#
#setDualDimMode([mode])
#
#Optional argument 'mode' should be either True or False.
#Invoking this method without arguments will set the dual dimension
#value display mode to that given from the DimStyle
#        """
#        if self.isLocked():
#            raise RuntimeError, "Changing dual mode not allowed - object locked."
#        _mode = mode
#        if _mode is not None:
#            util.test_boolean(_mode)
#        _ddm = self.getDualDimMode()
#        if ((_mode is None and self.__ddm is not None) or
#            (_mode is not None and _mode is not _ddm)): 
#            self.startChange('dual_mode_changed')
#            self.__ddm = _mode
#            self.endChange('dual_mode_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.calcDimValues()
#            self.sendMessage('dual_mode_changed', _ddm)
#            self.modified()
#
#    dual_mode = property(getDualDimMode, setDualDimMode, None,
#                         "Display both primary and secondary dimensions")
#
#    def getOffset(self):
#        """Return the current offset value for the Dimension.
#
#getOffset()
#        """
#        _offset = self.__offset
#        if _offset is None:
#            _offset = self.__dimstyle.getValue('DIM_OFFSET')
#        return _offset
#
#    def setOffset(self, offset=None):
#        """Set the offset value for the Dimension.
#
#setOffset([offset])
#
#Optional argument 'offset' should be a positive float.
#Calling this method without arguments sets the value to that
#given in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting offset not allowed - object locked."
#        _o = offset
#        if _o is not None:
#            _o = util.get_float(_o)
#            if _o &lt; 0.0:
#                raise ValueError, "Invalid dimension offset length: %g" % _o
#        _off = self.getOffset()
#        if ((_o is None and self.__offset is not None) or
#            (_o is not None and abs(_o - _off) &gt; 1e-10)):
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            self.startChange('offset_changed')
#            self.__offset = _o
#            self.endChange('offset_changed')
#            self.calcDimValues()
#            self.sendMessage('offset_changed', _off)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    offset = property(getOffset, setOffset, None, "Dimension offset.")
#
#    def getExtension(self):
#        """Get the extension length of the Dimension.
#
#getExtension()
#        """
#        _ext = self.__extlen
#        if _ext is None:
#            _ext = self.__dimstyle.getValue('DIM_EXTENSION')
#        return _ext
#
#    def setExtension(self, ext=None):
#        """Set the extension length of the Dimension.
#
#setExtension([ext])
#
#Optional argument 'ext' should be a positive float value.
#Calling this method without arguments set the extension length
#to that given in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting extension not allowed - object locked."
#        _e = ext
#        if _e is not None:
#            _e = util.get_float(_e)
#            if _e &lt; 0.0:
#                raise ValueError, "Invalid dimension extension length: %g" % _e
#        _ext = self.getExtension()
#        if ((_e is None and self.__extlen is not None) or
#            (_e is not None and abs(_e - _ext) &gt; 1e-10)):
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            self.startChange('extension_changed')
#            self.__extlen = _e
#            self.endChange('extension_changed')
#            self.calcDimValues()
#            self.sendMessage('extension_changed', _ext)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    extension = property(getExtension, setExtension, None,
#                         "Dimension extension length.")
#
#    def getPositionAsString(cls, p):
#        """Return a text string for the dimension text position.
#
#getPositionAsString(p)
#
#This classmethod returns 'split', 'above', or 'below'
#        """
#        if not isinstance(p, int):
#            raise TypeError, "Invalid argument type: " + `type(p)`
#        if p == Dimension.DIM_TEXT_POS_SPLIT:
#            _str = 'split'
#        elif p == Dimension.DIM_TEXT_POS_ABOVE:
#            _str = 'above'
#        elif p == Dimension.DIM_TEXT_POS_BELOW:
#            _str = 'below'
#        else:
#            raise ValueError, "Unexpected position value: %d" % p
#        return _str
#
#    getPositionAsString = classmethod(getPositionAsString)
#
#    def getPositionFromString(cls, s):
#        """Return the dimension text position given a string argument.
#
#getPositionFromString(s)
#
#This classmethod returns a value based on the string argument:
#
#'split' -&gt; Dimension.DIM_TEXT_POS_SPLIT
#'above' -&gt; Dimension.DIM_TEXT_POS_ABOVE
#'below' -&gt; Dimension.DIM_TEXT_POS_BELOW
#
#If the string is not listed above a ValueError execption is raised.
#
#        """
#        if not isinstance(s, str):
#            raise TypeError, "Invalid argument type: " + `type(s)`
#        _ls = s.lower()
#        if _ls == 'split':
#            _v = Dimension.DIM_TEXT_POS_SPLIT
#        elif _ls == 'above':
#            _v = Dimension.DIM_TEXT_POS_ABOVE
#        elif _ls == 'below':
#            _v = Dimension.DIM_TEXT_POS_BELOW
#        else:
#            raise ValueError, "Unexpected position string: " + s
#        return _v
#
#    getPositionFromString = classmethod(getPositionFromString)
#
#    def getPositionStrings(cls):
#        """Return the position values as strings.
#
#getPositionStrings()
#
#This classmethod returns a list of strings.
#        """
#        return [_('Split'),
#                _('Above'),
#                _('Below')
#                ]
#
#    getPositionStrings = classmethod(getPositionStrings)
#
#    def getPositionValues(cls):
#        """Return the position values.
#
#getPositionValues()
#
#This classmethod reutrns a list of values.
#        """
#        return [Dimension.DIM_TEXT_POS_SPLIT,
#                Dimension.DIM_TEXT_POS_ABOVE,
#                Dimension.DIM_TEXT_POS_BELOW
#                ]
#
#    getPositionValues = classmethod(getPositionValues)
#    
#    def getPosition(self):
#        """Return how the dimension text intersects the crossbar.
#
#getPosition()
#        """
#        _pos = self.__textpos
#        if _pos is None:
#            _pos = self.__dimstyle.getValue('DIM_POSITION')
#        return _pos
#
#    def setPosition(self, pos=None):
#        """Set where the dimension text should be placed at the crossbar.
#
#setPosition([pos])
#
#Choices for optional argument 'pos' are:
#
#dimension.SPLIT =&gt; In the middle of the crossbar.
#dimension.ABOVE =&gt; Beyond the crossbar from the dimensioned objects.
#dimension.BELOW =&gt; Between the crossbar and the dimensioned objects.
#
#Calling this method without arguments sets the position to that given
#in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting position not allowed - object locked."
#        _pos = pos
#        if (_pos != Dimension.DIM_TEXT_POS_SPLIT and
#            _pos != Dimension.DIM_TEXT_POS_ABOVE and
#            _pos != Dimension.DIM_TEXT_POS_BELOW):
#            raise ValueError, "Invalid dimension text position: '%s'" % str(_pos)
#        _dp = self.getPosition()
#        if ((_pos is None and self.__textpos is not None) or
#            (_pos is not None and _pos != _dp)):
#            self.startChange('position_changed')
#            self.__textpos = _pos
#            self.endChange('position_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.sendMessage('position_changed', _dp)
#            self.modified()
#
#    position = property(getPosition, setPosition, None,
#                        "Dimension text position")
#
#    def getPositionOffset(self):
#        """Get the offset for the dimension text and the crossbar/crossarc.
#
#getPositionOffset()
#        """
#        _po = self.__poffset
#        if _po is None:
#            _po = self.__dimstyle.getValue('DIM_POSITION_OFFSET')
#        return _po
#
#    def setPositionOffset(self, offset=None):
#        """Set the separation between the dimension text and the crossbar.
#
#setPositionOffset([offset])
#
#If this method is called without arguments, the text offset
#length is set to the value given in the DimStyle.
#If the argument 'offset' is supplied, it should be a positive float value.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting text offset length not allowed - object locked."
#        _o = offset
#        if _o is not None:
#            _o = util.get_float(_o)
#            if _o &lt; 0.0:
#                raise ValueError, "Invalid text offset length: %g" % _o
#        _to = self.getPositionOffset()
#        if ((_o is None and self.__poffset is not None) or
#            (_o is not None and abs(_o - _to) &gt; 1e-10)):
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            self.startChange('position_offset_changed')
#            self.__poffset = _o
#            self.endChange('position_offset_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.calcDimValues()
#            self.sendMessage('position_offset_changed', _to)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    position_offset = property(getPositionOffset, setPositionOffset, None,
#                               "Text offset from crossbar/crossarc distance.")
#
#    def getDualModeOffset(self):
#        """Get the offset for the dimension text when displaying two dimensions.
#
#getDualModeOffset()
#        """
#        _dmo = self.__dmoffset
#        if _dmo is None:
#            _dmo = self.__dimstyle.getValue('DIM_DUAL_MODE_OFFSET')
#        return _dmo
#
#    def setDualModeOffset(self, offset=None):
#        """Set the separation between the dimensions and the dual mode dimension divider.
#
#setDualModeOffset([offset])
#
#If this method is called without arguments, the dual mode offset
#length is set to the value given in the DimStyle.
#If the argument 'offset' is supplied, it should be a positive float value.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting dual mode offset length not allowed - object locked."
#        _o = offset
#        if _o is not None:
#            _o = util.get_float(_o)
#            if _o &lt; 0.0:
#                raise ValueError, "Invalid dual mode offset length: %g" % _o
#        _dmo = self.getDualModeOffset()
#        if ((_o is None and self.__dmoffset is not None) or
#            (_o is not None and abs(_o - _dmo) &gt; 1e-10)):
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            self.startChange('dual_mode_offset_changed')
#            self.__dmoffset = _o
#            self.endChange('dual_mode_offset_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.calcDimValues()
#            self.sendMessage('dual_mode_offset_changed', _dmo)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    dual_mode_offset = property(getDualModeOffset, setDualModeOffset, None,
#                                "Text offset from dimension splitting bar when displaying two dimensions.")
#
#    def getColor(self):
#        """Return the color of the dimension lines.
#
#getColor()
#        """
#        _col = self._color
#        if _col is None:
#            _col = self.__dimstyle.getValue('DIM_COLOR')
#        return _col
#
#    def setColor(self, c=None):
#        """Set the color of the dimension lines.
#
#setColor([c])
#
#Optional argument 'c' should be a Color instance. Calling this
#method without an argument sets the color to the value given
#in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting object color not allowed - object locked."
#        _c = c
#        if _c is not None:
#            if not isinstance(_c, color.Color):
#                raise TypeError, "Invalid color type: " + `type(_c)`
#        _oc = self.getColor()
#        if ((_c is None and self._color is not None) or
#            (_c is not None and _c != _oc)):
#            self.startChange('color_changed')
#            self._color = _c
#            self.endChange('color_changed')
#            self.sendMessage('color_changed', _oc)
#            self.modified()
#
#    color = property(getColor, setColor, None, "Dimension Color")
#
#    def getThickness(self):
#        """Return the thickness of the dimension bars.
#
#getThickness()
#
#This method returns a float.
#        """
#        _t = self.__thickness
#        if _t is None:
#            _t = self.__dimstyle.getValue('DIM_THICKNESS')
#        return _t
#
#    def setThickness(self, thickness=None):
#        """Set the thickness of the dimension bars.
#
#setThickness([thickness])
#
#Optional argument 'thickness' should be a float value. Setting the
#thickness to 0 will display and print the lines with the thinnest
#value possible. Calling this method without arguments resets the
#thickness to the value defined in the DimStyle.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting thickness not allowed - object locked."
#        _t = thickness
#        if _t is not None:
#            _t = util.get_float(_t)
#            if _t &lt; 0.0:
#                raise ValueError, "Invalid thickness: %g" % _t
#        _ot = self.getThickness()
#        if ((_t is None and self.__thickness is not None) or
#            (_t is not None and abs(_t - _ot) &gt; 1e-10)):
#            self.startChange('thickness_changed')
#            self.__thickness = _t
#            self.endChange('thickness_changed')
#            self.sendMessage('thickness_changed', _ot)
#            self.modified()
#
#    thickness = property(getThickness, setThickness, None,
#                         "Dimension bar thickness.")
#
#    def getScale(self):
#        """Return the Dimension scale factor.
#
#getScale()
#        """
#        return self.__scale
#
#    def setScale(self, scale=None):
#        """Set the Dimension scale factor.
#
#setScale([scale])
#
#Optional argument 's' should be a float value greater than 0. If
#no argument is supplied the default scale factor of 1 is set. 
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting scale not allowed - object locked."
#        _s = scale
#        if _s is None:
#            _s = 1.0
#        _s = util.get_float(_s)
#        if not _s &gt; 0.0:
#            raise ValueError, "Invalid scale factor: %g" % _s
#        _os = self.__scale
#        if abs(_os - _s) &gt; 1e-10:
#            self.startChange('scale_changed')
#            self.__scale = _s
#            self.endChange('scale_changed')
#            self.sendMessage('scale_changed', _os)
#            self.modified()
#
#    scale = property(getScale, setScale, None, "Dimension scale factor.")
#
#    def getLocation(self):
#        """Return the location of the dimensional text values.
#
#getLocation()
#        """
#        return self.__dimloc
#
#    def setLocation(self, x, y):
#        """Set the location of the dimensional text values.
#
#setLocation(x, y)
#
#The 'x' and 'y' arguments should be float values. The text is
#centered around that point.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting location not allowed - object locked."
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _ox, _oy = self.__dimloc
#        if abs(_ox - _x) &gt; 1e-10 or abs(_oy - _y) &gt; 1e-10:
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            self.startChange('location_changed')
#            self.__dimloc = (_x, _y)
#            self.endChange('location_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.calcDimValues()
#            self.sendMessage('location_changed', _ox, _oy)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    location = property(getLocation, setLocation, None,
#                        "Dimension location")
#
#    def move(self, dx, dy):
#        """Move a Dimension.
#
#move(dx, dy)
#
#The first argument gives the x-coordinate displacement,
#and the second gives the y-coordinate displacement. Both
#values should be floats.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Moving not allowed - object locked."
#        _dx = util.get_float(dx)
#        _dy = util.get_float(dy)
#        if abs(_dx) &gt; 1e-10 or abs(_dy) &gt; 1e-10:
#            _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#            _x, _y = self.__dimloc
#            self.startChange('location_changed')
#            self.__dimloc = ((_x + _dx), (_y + _dy))
#            self.endChange('location_changed')
#            self.__ds1.setBounds()
#            self.__ds2.setBounds()
#            self.calcDimValues()
#            self.sendMessage('location_changed', _x, _y)
#            self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    def getStyleValue(self, ds, opt):
#        """Get the value in the DimStyle for some option
#
#getStyleValue(ds, opt)
#
#Argument 'ds' should be one of the DimString objects in
#the Dimension, and argument 'opt' should be a string.
#Valid choices for 'opt' are 'prefix', 'suffix', 'precision',
#'units', 'print_zero', 'print_decimal', 'font_family',
#'font_style', 'font_weight', 'size', 'color', 'angle',
#and 'alignment'.
#        """
#        if not isinstance(ds, DimString):
#            raise TypeError, "Invalid DimString type: " + `type(ds)`
#        if not isinstance(opt, str):
#            raise TypeError, "Invalid DimStyle option type: " + `type(opt)`
#        _key = None
#        if ds is self.__ds1:
#            if opt == 'prefix':
#                _key = 'DIM_PRIMARY_PREFIX'
#            elif opt == 'suffix':
#                _key = 'DIM_PRIMARY_SUFFIX'
#            elif opt == 'precision':
#                _key = 'DIM_PRIMARY_PRECISION'
#            elif opt == 'units':
#                _key = 'DIM_PRIMARY_UNITS'
#            elif opt == 'print_zero':
#                _key = 'DIM_PRIMARY_LEADING_ZERO'
#            elif opt == 'print_decimal':
#                _key = 'DIM_PRIMARY_TRAILING_DECIMAL'
#            elif opt == 'font_family':
#                _key = 'DIM_PRIMARY_FONT_FAMILY'
#            elif opt == 'font_weight':
#                _key = 'DIM_PRIMARY_FONT_WEIGHT'
#            elif opt == 'font_style':
#                _key = 'DIM_PRIMARY_FONT_STYLE'
#            elif opt == 'size':
#                _key = 'DIM_PRIMARY_TEXT_SIZE'
#            elif opt == 'color':
#                _key = 'DIM_PRIMARY_FONT_COLOR'
#            elif opt == 'angle':
#                _key = 'DIM_PRIMARY_TEXT_ANGLE'
#            elif opt == 'alignment':
#                _key = 'DIM_PRIMARY_TEXT_ALIGNMENT'
#            else:
#                raise ValueError, "Unexpected option: %s" % opt
#        elif ds is self.__ds2:
#            if opt == 'prefix':
#                _key = 'DIM_SECONDARY_PREFIX'
#            elif opt == 'suffix':
#                _key = 'DIM_SECONDARY_SUFFIX'
#            elif opt == 'precision':
#                _key = 'DIM_SECONDARY_PRECISION'
#            elif opt == 'units':
#                _key = 'DIM_SECONDARY_UNITS'
#            elif opt == 'print_zero':
#                _key = 'DIM_SECONDARY_LEADING_ZERO'
#            elif opt == 'print_decimal':
#                _key = 'DIM_SECONDARY_TRAILING_DECIMAL'
#            elif opt == 'font_family':
#                _key = 'DIM_SECONDARY_FONT_FAMILY'
#            elif opt == 'font_weight':
#                _key = 'DIM_SECONDARY_FONT_WEIGHT'
#            elif opt == 'font_style':
#                _key = 'DIM_SECONDARY_FONT_STYLE'
#            elif opt == 'size':
#                _key = 'DIM_SECONDARY_TEXT_SIZE'
#            elif opt == 'color':
#                _key = 'DIM_SECONDARY_FONT_COLOR'
#            elif opt == 'angle':
#                _key = 'DIM_SECONDARY_TEXT_ANGLE'
#            elif opt == 'alignment':
#                _key = 'DIM_SECONDARY_TEXT_ALIGNMENT'
#            else:
#                raise ValueError, "Unexpected option: %s" % opt
#        else:
#            raise ValueError, "DimString not used in this Dimension: " + `ds`
#        if _key is None:
#            raise ValueError, "Unexpected option: %s" % opt
#        return self.__dimstyle.getValue(_key)
#
#    def getDimensions(self, dimlen):
#        """Return the formatted dimensional values.
#
#getDimensions(dimlen)
#
#The argument 'dimlen' should be the length in millimeters.
#
#This method returns a list of the primary and secondary
#dimensional values.
#        """
#        _dl = util.get_float(dimlen)
#        dims = []
#        dims.append(self.__ds1.formatDimension(_dl))
#        dims.append(self.__ds2.formatDimension(_dl))
#        return dims
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display
#
#calcDimValues([allpts])
#
#This method is meant to be overriden by subclasses.
#        """
#        pass
#
#    def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
#        """Return whether or not a Dimension exists with a region.
#
#isRegion(xmin, ymin, xmax, ymax[, fully])
#
#The first four arguments define the boundary. The optional
#fifth argument 'fully' indicates whether or not the Dimension
#must be completely contained within the region or just pass
#through it.
#
#This method should be overriden in classes derived from Dimension.
#        """
#        return False
#
#    def getBounds(self):
#        """Return the minimal and maximal locations of the dimension
#
#getBounds()
#
#This method returns a tuple of four values - xmin, ymin, xmax, ymax.
#These values give the mimimum and maximum coordinates of the dimension
#object.
#
#This method should be overriden in classes derived from Dimension.
#        """
#        _xmin = _ymin = -float(sys.maxint)
#        _xmax = _ymax = float(sys.maxint)
#        return _xmin, _ymin, _xmax, _ymax
#
#    def copyDimValues(self, dim):
#        """This method adjusts one Dimension to match another Dimension
#
#copyDimValues(dim)
#
#Argument 'dim' must be a Dimension instance
#        """
#        if not isinstance(dim, Dimension):
#            raise TypeError, "Invalid Dimension type: " + `type(dim)`
#        self.setDimStyle(dim.getDimStyle())
#        self.setOffset(dim.getOffset())
#        self.setExtension(dim.getExtension())
#        self.setEndpointType(dim.getEndpointType())
#        self.setEndpointSize(dim.getEndpointSize())
#        self.setColor(dim.getColor())
#        self.setThickness(dim.getThickness())
#        self.setDualDimMode(dim.getDualDimMode())
#        self.setPositionOffset(dim.getPositionOffset())
#        self.setDualModeOffset(dim.getDualModeOffset())
#        #
#        _ds1, _ds2 = dim.getDimstrings()
#        #
#        _ds = self.__ds1
#        _ds.setTextStyle(_ds1.getTextStyle())
#        _ds.setPrefix(_ds1.getPrefix())
#        _ds.setSuffix(_ds1.getSuffix())
#        _ds.setPrecision(_ds1.getPrecision())
#        _ds.setUnits(_ds1.getUnits())
#        _ds.setPrintZero(_ds1.getPrintZero())
#        _ds.setPrintDecimal(_ds1.getPrintDecimal())
#        _ds.setFamily(_ds1.getFamily())
#        _ds.setWeight(_ds1.getWeight())
#        _ds.setStyle(_ds1.getStyle())
#        _ds.setColor(_ds1.getColor())
#        _ds.setSize(_ds1.getSize())
#        _ds.setAngle(_ds1.getAngle())
#        _ds.setAlignment(_ds1.getAlignment())
#        #
#        _ds = self.__ds2
#        _ds.setTextStyle(_ds2.getTextStyle())
#        _ds.setPrefix(_ds2.getPrefix())
#        _ds.setSuffix(_ds2.getSuffix())
#        _ds.setPrecision(_ds2.getPrecision())
#        _ds.setUnits(_ds2.getUnits())
#        _ds.setPrintZero(_ds2.getPrintZero())
#        _ds.setPrintDecimal(_ds2.getPrintDecimal())
#        _ds.setFamily(_ds2.getFamily())
#        _ds.setWeight(_ds2.getWeight())
#        _ds.setStyle(_ds2.getStyle())
#        _ds.setColor(_ds2.getColor())
#        _ds.setSize(_ds2.getSize())
#        _ds.setAngle(_ds2.getAngle())
#        _ds.setAlignment(_ds2.getAlignment())
#        
#    def __dimstringChangePending(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        _arg = args[0]
#        if _arg == 'moved':
#            self.startChange(_arg)
#        elif (_arg == 'textstyle_changed' or
#              _arg == 'font_family_changed' or
#              _arg == 'font_style_changed' or
#              _arg == 'font_weight_changed' or
#              _arg == 'font_color_changed' or
#              _arg == 'text_size_changed' or
#              _arg == 'text_angle_changed' or
#              _arg == 'text_alignment_changed' or
#              _arg == 'prefix_changed' or
#              _arg == 'suffix_changed' or
#              _arg == 'units_changed' or
#              _arg == 'precision_changed' or
#              _arg == 'print_zero_changed' or
#              _arg == 'print_decimal_changed'):
#            self.startChange('dimstring_changed')
#        else:
#            pass
#
#    def __dimstringChangeComplete(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        _arg = args[0]
#        if _arg == 'moved':
#            self.endChanged(_arg)
#        elif (_arg == 'textstyle_changed' or
#              _arg == 'font_family_changed' or
#              _arg == 'font_style_changed' or
#              _arg == 'font_weight_changed' or
#              _arg == 'font_color_changed' or
#              _arg == 'text_size_changed' or
#              _arg == 'text_angle_changed' or
#              _arg == 'text_alignment_changed' or
#              _arg == 'prefix_changed' or
#              _arg == 'suffix_changed' or
#              _arg == 'units_changed' or
#              _arg == 'precision_changed' or
#              _arg == 'print_zero_changed' or
#              _arg == 'print_decimal_changed'):
#            self.endChange('dimstring_changed')
#        else:
#            pass
#            
#    def sendsMessage(self, m):
#        if m in Dimension.__messages:
#            return True
#        return super(Dimension, self).sendsMessage(m)
#
##
## class stuff for dimension styles
##
#
#class DimStyle(object):
#    """A class storing preferences for Dimensions
#
#The DimStyle class stores a set of dimension parameters
#that will be used when creating dimensions when the
#particular style is active.
#
#A DimStyle object has the following methods:
#
#getName(): Return the name of the DimStyle.
#getOption(): Return a single value in the DimStyle.
#getOptions(): Return all the options in the DimStyle.
#getValue(): Return the value of one of the DimStyle options.
#
#getOption() and getValue() are synonymous.
#
#The DimStyle class has the following classmethods:
#
#getDimStyleOptions(): Return the options defining a DimStyle.
#getDimStyleDefaultValue(): Return the default value for a DimStyle option.
#    """
#
#    #
#    # the default values for the DimStyle class
#    #
#    __deftextcolor = color.Color('#ffffff')
#    __defdimcolor = color.Color(255,165,0)
#    __defaults = {
#        'DIM_PRIMARY_FONT_FAMILY' : 'Sans',
#        'DIM_PRIMARY_TEXT_SIZE' : 1.0,
#        'DIM_PRIMARY_FONT_WEIGHT' : text.TextStyle.FONT_NORMAL,
#        'DIM_PRIMARY_FONT_STYLE' : text.TextStyle.FONT_NORMAL,
#        'DIM_PRIMARY_FONT_COLOR' : __deftextcolor,
#        'DIM_PRIMARY_TEXT_ANGLE' : 0.0,
#        'DIM_PRIMARY_TEXT_ALIGNMENT' : text.TextStyle.ALIGN_CENTER,
#        'DIM_PRIMARY_PREFIX' : u'',
#        'DIM_PRIMARY_SUFFIX' : u'',
#        'DIM_PRIMARY_PRECISION' : 3,
#        'DIM_PRIMARY_UNITS' : units.MILLIMETERS,
#        'DIM_PRIMARY_LEADING_ZERO' : True,
#        'DIM_PRIMARY_TRAILING_DECIMAL' : True,
#        'DIM_SECONDARY_FONT_FAMILY' : 'Sans',
#        'DIM_SECONDARY_TEXT_SIZE' : 1.0,
#        'DIM_SECONDARY_FONT_WEIGHT' : text.TextStyle.FONT_NORMAL,
#        'DIM_SECONDARY_FONT_STYLE' : text.TextStyle.FONT_NORMAL,
#        'DIM_SECONDARY_FONT_COLOR' : __deftextcolor,
#        'DIM_SECONDARY_TEXT_ANGLE' : 0.0,
#        'DIM_SECONDARY_TEXT_ALIGNMENT' : text.TextStyle.ALIGN_CENTER,
#        'DIM_SECONDARY_PREFIX' : u'',
#        'DIM_SECONDARY_SUFFIX' : u'',
#        'DIM_SECONDARY_PRECISION' : 3,
#        'DIM_SECONDARY_UNITS' : units.MILLIMETERS,
#        'DIM_SECONDARY_LEADING_ZERO' : True,
#        'DIM_SECONDARY_TRAILING_DECIMAL' : True,
#        'DIM_OFFSET' : 1.0,
#        'DIM_EXTENSION' : 1.0,
#        'DIM_COLOR' : __defdimcolor,
#        'DIM_THICKNESS' : 0.0,
#        'DIM_POSITION' : Dimension.DIM_TEXT_POS_SPLIT,
#        'DIM_ENDPOINT' : Dimension.DIM_ENDPT_NONE,
#        'DIM_ENDPOINT_SIZE' : 1.0,
#        'DIM_DUAL_MODE' : False,
#        'DIM_POSITION_OFFSET' : 0.0,
#        'DIM_DUAL_MODE_OFFSET' : 1.0,
#        'RADIAL_DIM_PRIMARY_PREFIX' : u'',
#        'RADIAL_DIM_PRIMARY_SUFFIX' : u'',
#        'RADIAL_DIM_SECONDARY_PREFIX' : u'',
#        'RADIAL_DIM_SECONDARY_SUFFIX' : u'',
#        'RADIAL_DIM_DIA_MODE' : False,
#        'ANGULAR_DIM_PRIMARY_PREFIX' : u'',
#        'ANGULAR_DIM_PRIMARY_SUFFIX' : u'',
#        'ANGULAR_DIM_SECONDARY_PREFIX' : u'',
#        'ANGULAR_DIM_SECONDARY_SUFFIX' : u'',
#        }
#
#    def __init__(self, name, keywords={}):
#        """Instantiate a DimStyle object.
#
#ds = DimStyle(name, keywords)
#
#The argument 'name' should be a unicode name, and the
#'keyword' argument should be a dict. The keys should
#be the same keywords used to set option values, such
#as DIM_OFFSET, DIM_EXTENSION, etc, and the value corresponding
#to each key should be set appropriately.
#        """
#        super(DimStyle, self).__init__()
#        _n = name
#        if not isinstance(_n, types.StringTypes):
#            raise TypeError, "Invalid DimStyle name type: "+ `type(_n)`
#        if isinstance(_n, str):
#            _n = unicode(_n)
#        if not isinstance(keywords, dict):
#            raise TypeError, "Invalid keywords argument type: " + `type(keywords)`
#        from PythonCAD.Generic.options import test_option
#        self.__opts = baseobject.ConstDict(str)
#        self.__name = _n
#        for _kw in keywords:
#            if _kw not in DimStyle.__defaults:
#                raise KeyError, "Unknown DimStyle keyword: " + _kw
#            _val = keywords[_kw]            
#            _valid = test_option(_kw, _val)
#            self.__opts[_kw] = _val
#
#    def __eq__(self, obj):
#        """Test a DimStyle object for equality with another DimStyle.
#        """
#        if not isinstance(obj, DimStyle):
#            return False
#        if obj is self:
#            return True
#        if self.__name != obj.getName():
#            return False
#        _val = True
#        for _key in DimStyle.__defaults.keys():
#            _sv = self.getOption(_key)
#            _ov = obj.getOption(_key)
#            if ((_key == 'DIM_PRIMARY_TEXT_SIZE') or
#                (_key == 'DIM_PRIMARY_TEXT_ANGLE') or
#                (_key == 'DIM_SECONDARY_TEXT_SIZE') or
#                (_key == 'DIM_SECONDARY_TEXT_ANGLE') or
#                (_key == 'DIM_OFFSET') or
#                (_key == 'DIM_EXTENSION') or
#                (_key == 'DIM_THICKNESS') or
#                (_key == 'DIM_ENDPOINT_SIZE') or
#                (_key == 'DIM_POSITION_OFFSET') or
#                (_key == 'DIM_DUAL_MODE_OFFSET')):
#                if abs(_sv - _ov) &gt; 1e-10:
#                    _val = False
#            else:
#                if _sv != _ov:
#                    _val = False
#            if _val is False:
#                break
#        return _val
#
#    def __ne__(self, obj):
#        """Test a DimStyle object for inequality with another DimStyle.
#        """
#        return not self == obj
#
#    def getDimStyleOptions(cls):
#        """Return the options used to define a DimStyle instance.
#
#getDimStyleOptions()
#
#This classmethod returns a list of strings.
#        """
#        return cls.__defaults.keys()
#
#    getDimStyleOptions = classmethod(getDimStyleOptions)
#
#    def getDimStyleDefaultValue(cls, key):
#        """Return the default value for a DimStyle option.
#
#getDimStyleValue(key)
#
#Argument 'key' must be one of the options given in getDimStyleOptions().
#        """
#        return cls.__defaults[key]
#
#    getDimStyleDefaultValue = classmethod(getDimStyleDefaultValue)
#
#    def getName(self):
#        """Return the name of the DimStyle.
#
#getName()
#        """
#        return self.__name
#
#    name = property(getName, None, None, "DimStyle name.")
#
#    def getKeys(self):
#        """Return the non-default options within the DimStyle.
#
#getKeys()
#        """
#        return self.__opts.keys()
#
#    def getOptions(self):
#        """Return all the options stored within the DimStyle.
#
#getOptions()
#        """
#        _keys = self.__opts.keys()
#        for _key in DimStyle.__defaults:
#            if _key not in self.__opts:
#                _keys.append(_key)
#        return _keys
#
#    def getOption(self, key):
#        """Return the value of a particular option in the DimStyle.
#
#getOption(key)
#
#The key should be one of the strings returned from getOptions. If
#there is no value found in the DimStyle for the key, the value None
#is returned.
#        """
#        if key in self.__opts:
#            _val = self.__opts[key]
#        elif key in DimStyle.__defaults:
#            _val = DimStyle.__defaults[key]
#        else:
#            raise KeyError, "Unexpected DimStyle keyword: '%s'" % key
#        return _val
#
#    def getValue(self, key):
#        """Return the value of a particular option in the DimStyle.
#
#getValue(key)
#
#The key should be one of the strings returned from getOptions. This
#method raises a KeyError exception if the key is not found.
#
#        """
#        if key in self.__opts:
#            _val = self.__opts[key]
#        elif key in DimStyle.__defaults:
#            _val = DimStyle.__defaults[key]
#        else:
#            raise KeyError, "Unexpected DimStyle keyword: '%s'" % key
#        return _val
#
#    def getValues(self):
#        """Return values comprising the DimStyle.
#
#getValues()
#        """
#        _vals = {}
#        _vals['name'] = self.__name
#        for _opt in self.__opts:
#            _val = self.__opts[_opt]
#            if ((_opt == 'DIM_PRIMARY_FONT_COLOR') or
#                (_opt == 'DIM_SECONDARY_FONT_COLOR') or
#                (_opt == 'DIM_COLOR')):
#                _vals[_opt] = _val.getColors()
#            else:
#                _vals[_opt] = _val
#        return _vals
#
#class LinearDimension(Dimension):
#    """A class for Linear dimensions.
#
#The LinearDimension class is derived from the Dimension
#class, so it shares all of those methods and attributes.
#A LinearDimension should be used to display the absolute
#distance between two Point objects.
#
#A LinearDimension object has the following methods:
#
#{get/set}P1(): Get/Set the first Point for the LinearDimension.
#{get/set}P2(): Get/Set the second Point for the LinearDimension.
#getDimPoints(): Return the two Points used in this dimension.
#getDimLayers(): Return the two Layers holding the Points.
#getDimXPoints(): Get the x-coordinates of the dimension bar positions.
#getDimYPoints(): Get the y-coordinates of the dimension bar positions.
#getDimMarkerPoints(): Get the locaiton of the dimension endpoint markers.
#calcMarkerPoints(): Calculate the coordinates of any dimension marker objects.
#    """
#
#    __messages = {
#        'point_changed' : True,
#        }
#
#    def __init__(self, p1, p2, x, y, ds=None, **kw):
#        """Instantiate a LinearDimension object.
#
#ldim = LinearDimension(p1, p2, x, y, ds)
#
#p1: A Point contained in a Layer
#p2: A Point contained in a Layer
#x: The x-coordinate of the dimensional text
#y: The y-coordinate of the dimensional text
#ds: The DimStyle used for this Dimension.
#        """
#        if not isinstance(p1, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p1)`
#        if p1.getParent() is None:
#            raise ValueError, "Point P1 not stored in a Layer!"
#        if not isinstance(p2, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p2)`
#        if p2.getParent() is None:
#            raise ValueError, "Point P2 not stored in a Layer!"
#        super(LinearDimension, self).__init__(x, y, ds, **kw)
#        self.__p1 = p1
#        self.__p2 = p2
#        self.__bar1 = DimBar()
#        self.__bar2 = DimBar()
#        self.__crossbar = DimCrossbar()
#        p1.storeUser(self)
#        p1.connect('moved', self.__movePoint)
#        p1.connect('change_pending', self.__pointChangePending)
#        p1.connect('change_complete', self.__pointChangeComplete)
#        p2.storeUser(self)
#        p2.connect('moved', self.__movePoint)
#        p2.connect('change_pending', self.__pointChangePending)
#        p2.connect('change_complete', self.__pointChangeComplete)
#        self.calcDimValues()
#
#    def __eq__(self, ldim):
#        """Test two LinearDimension objects for equality.
#        """
#        if not isinstance(ldim, LinearDimension):
#            return False
#        _lp1 = self.__p1.getParent()
#        _lp2 = self.__p2.getParent()
#        _p1, _p2 = ldim.getDimPoints()
#        _l1 = _p1.getParent()
#        _l2 = _p2.getParent()
#        if (_lp1 is _l1 and
#            _lp2 is _l2 and
#            self.__p1 == _p1 and
#            self.__p2 == _p2):
#            return True
#        if (_lp1 is _l2 and
#            _lp2 is _l1 and
#            self.__p1 == _p2 and
#            self.__p2 == _p1):
#            return True
#        return False
#
#    def __ne__(self, ldim):
#        """Test two LinearDimension objects for equality.
#        """
#        if not isinstance(ldim, LinearDimension):
#            return True
#        _lp1 = self.__p1.getParent()
#        _lp2 = self.__p2.getParent()
#        _p1, _p2 = ldim.getDimPoints()
#        _l1 = _p1.getParent()
#        _p2 = self.__p2
#        _l2 = _p2.getParent()
#        if (_lp1 is _l1 and
#            _lp2 is _l2 and
#            self.__p1 == _p1 and
#            self.__p2 == _p2):
#            return False
#        if (_lp1 is _l2 and
#            _lp2 is _l1 and
#            self.__p1 == _p2 and
#            self.__p2 == _p1):
#            return False
#        return True
#
#    def finish(self):
#        self.__p1.disconnect(self)
#        self.__p1.freeUser(self)
#        self.__p2.disconnect(self)
#        self.__p2.freeUser(self)
#        self.__bar1 = self.__bar2 = self.__crossbar = None
#        self.__p1 = self.__p2 = None
#        super(LinearDimension, self).finish()
#
#    def getValues(self):
#        """Return values comprising the LinearDimension.
#
#getValues()
#
#This method extends the Dimension::getValues() method.
#        """
#        _data = super(LinearDimension, self).getValues()
#        _data.setValue('type', 'ldim')
#        _data.setValue('p1', self.__p1.getID())
#        _layer = self.__p1.getParent()
#        _data.setValue('l1', _layer.getID())
#        _data.setValue('p2', self.__p2.getID())
#        _layer = self.__p2.getParent()
#        _data.setValue('l2', _layer.getID())
#        return _data
#
#    def getP1(self):
#        """Return the first Point of a LinearDimension.
#
#getP1()
#        """
#        return self.__p1
#
#    def setP1(self, p):
#        """Set the first Point of a LinearDimension.
#
#setP1(p)
#
#There is one required argument for this method:
#
#p: A Point contained in a Layer
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting point not allowed - object locked."
#        if not isinstance(p, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p)`
#        if p.getParent() is None:
#            raise ValueError, "Point not stored in a Layer!"
#        _pt = self.__p1
#        if _pt is not p:
#            _pt.disconnect(self)
#            _pt.freeUser(self)
#            self.startChange('point_changed')
#            self.__p1 = p
#            self.endChange('point_changed')
#            self.sendMessage('point_changed', _pt, p)
#            p.storeUser(self)
#            p.connect('moved', self.__movePoint)
#            p.connect('change_pending', self.__pointChangePending)
#            p.connect('change_complete', self.__pointChangeComplete)
#            if abs(_pt.x - p.x) &gt; 1e-10 or abs(_pt.y - p.y) &gt; 1e-10:
#                _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#                self.calcDimValues()
#                self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    p1 = property(getP1, None, None, "Dimension first point.")
#
#    def getP2(self):
#        """Return the second point of a LinearDimension.
#
#getP2()
#        """
#        return self.__p2
#
#    def setP2(self, p):
#        """Set the second Point of a LinearDimension.
#
#setP2(p)
#
#There is one required argument for this method:
#
#p: A Point contained in a Layer
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting point not allowed - object locked."
#        if not isinstance(p, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p)`
#        if p.getParent() is None:
#            raise ValueError, "Point not stored in a Layer!"
#        _pt = self.__p2
#        if _pt is not p:
#            _pt.disconnect(self)
#            _pt.freeUser(self)
#            self.startChange('point_changed')
#            self.__p2 = p
#            self.endChange('point_changed')
#            self.sendMessage('point_changed', _pt, p)
#            p.storeUser(self)
#            p.connect('moved', self.__movePoint)
#            p.connect('change_pending', self.__pointChangePending)
#            p.connect('change_complete', self.__pointChangeComplete)
#            if abs(_pt.x - p.x) &gt; 1e-10 or abs(_pt.y - p.y) &gt; 1e-10:
#                _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#                self.calcDimValues()
#                self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#            self.modified()
#
#    p2 = property(getP2, None, None, "Dimension second point.")
#
#    def getDimPoints(self):
#        """Return both points used in the LinearDimension.
#
#getDimPoints()
#
#The two points are returned in a tuple.
#        """
#        return self.__p1, self.__p2
#
#    def getDimBars(self):
#        """Return the dimension boundary bars.
#
#getDimBars()
#        """
#        return self.__bar1, self.__bar2
#
#    def getDimCrossbar(self):
#        """Return the dimension crossbar.
#
#getDimCrossbar()
#        """
#        return self.__crossbar
#
#    def getDimLayers(self):
#        """Return both layers used in the LinearDimension.
#
#getDimLayers()
#
#The two layers are returned in a tuple.
#        """
#        _l1 = self.__p1.getParent()
#        _l2 = self.__p2.getParent()
#        return _l1, _l2
#
#    def calculate(self):
#        """Determine the length of this LinearDimension.
#
#calculate()
#        """
#        return self.__p1 - self.__p2
#
#    def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
#        """Return whether or not a LinearDimension exists within a region.
#
#isRegion(xmin, ymin, xmax, ymax[, fully])
#
#The four arguments define the boundary of an area, and the
#function returns True if the LinearDimension lies within that
#area. If the optional argument fully is used and is True,
#then the dimension points and the location of the dimension
#text must lie within the boundary. Otherwise, the function
#returns False.
#        """
#        _xmin = util.get_float(xmin)
#        _ymin = util.get_float(ymin)
#        _xmax = util.get_float(xmax)
#        if _xmax &lt; _xmin:
#            raise ValueError, "Illegal values: xmax &lt; xmin"
#        _ymax = util.get_float(ymax)
#        if _ymax &lt; _ymin:
#            raise ValueError, "Illegal values: ymax &lt; ymin"
#        util.test_boolean(fully)
#        _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#        if ((_dxmin &gt; _xmax) or
#            (_dymin &gt; _ymax) or
#            (_dxmax &lt; _xmin) or
#            (_dymax &lt; _ymin)):
#            return False
#        if fully:
#            if ((_dxmin &gt; _xmin) and
#                (_dymin &gt; _ymin) and
#                (_dxmax &lt; _xmax) and
#                (_dymax &lt; _ymax)):
#                return True
#            return False
#        _dx, _dy = self.getLocation()
#        if _xmin &lt; _dx &lt; _xmax and _ymin &lt; _dy &lt; _ymax: # dim text
#            return True
#        #
#        # bar at p1
#        #
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        _x1, _y1 = _ep1
#        _x2, _y2 = _ep2
#        if util.in_region(_x1, _y1, _x2, _y2, _xmin, _ymin, _xmax, _ymax):
#            return True
#        #
#        # bar at p2
#        #
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _x1, _y1 = _ep1
#        _x2, _y2 = _ep2
#        if util.in_region(_x1, _y1, _x2, _y2, _xmin, _ymin, _xmax, _ymax):
#            return True
#        #
#        # crossbar
#        #
#        _ep1, _ep2 = self.__crossbar.getEndpoints()
#        _x1, _y1 = _ep1
#        _x2, _y2 = _ep2
#        return util.in_region(_x1, _y1, _x2, _y2, _xmin, _ymin, _xmax, _ymax)
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display.
#
#calcDimValues([allpts])
#
#This method calculates where the points for the dimension
#bars and crossbar are located. The argument 'allpts' is
#optional. By default it is True. If the argument is set to
#False, then the coordinates of the dimension marker points
#will not be calculated.
#        """
#        _allpts = allpts
#        util.test_boolean(_allpts)
#        _p1, _p2 = self.getDimPoints()
#        _bar1 = self.__bar1
#        _bar2 = self.__bar2
#        _crossbar = self.__crossbar
#        _p1x, _p1y = _p1.getCoords()
#        _p2x, _p2y = _p2.getCoords()
#        _dx, _dy = self.getLocation()
#        _offset = self.getOffset()
#        _ext = self.getExtension()
#        #
#        # see comp.graphics.algorithms.faq section on calcuating
#        # the distance between a point and line for info about
#        # the following equations ...
#        #
#        _dpx = _p2x - _p1x
#        _dpy = _p2y - _p1y
#        _rnum = ((_dx - _p1x) * _dpx) + ((_dy - _p1y) * _dpy)
#        _snum = ((_p1y - _dy) * _dpx) - ((_p1x - _dx) * _dpy)
#        _den = pow(_dpx, 2) + pow(_dpy, 2)
#        _r = _rnum/_den
#        _s = _snum/_den
#        _sep = abs(_s) * math.sqrt(_den)
#        if abs(_dpx) &lt; 1e-10: # vertical
#            if _p2y &gt; _p1y:
#                _slope = math.pi/2.0
#            else:
#                _slope = -math.pi/2.0
#        elif abs(_dpy) &lt; 1e-10: # horizontal
#            if _p2x &gt; _p1x:
#                _slope = 0.0
#            else:
#                _slope = -math.pi
#        else:
#            _slope = math.atan2(_dpy, _dpx)
#        if _s &lt; 0.0: # dim point left of p1-p2 line
#            _angle = _slope + (math.pi/2.0)
#        else: # dim point right of p1-p2 line (or on it)
#            _angle = _slope - (math.pi/2.0)
#        _sin_angle = math.sin(_angle)
#        _cos_angle = math.cos(_angle)
#        _x = _p1x + (_offset * _cos_angle)
#        _y = _p1y + (_offset * _sin_angle)
#        _bar1.setFirstEndpoint(_x, _y)
#        if _r &lt; 0.0:
#            _px = _p1x + (_r * _dpx)
#            _py = _p1y + (_r * _dpy)
#            _x = _px + (_sep * _cos_angle)
#            _y = _py + (_sep * _sin_angle)
#        else:
#            _x = _p1x + (_sep * _cos_angle)
#            _y = _p1y + (_sep * _sin_angle)
#        _crossbar.setFirstEndpoint(_x, _y)
#        _x = _p1x + (_sep * _cos_angle)
#        _y = _p1y + (_sep * _sin_angle)
#        _crossbar.setFirstCrossbarPoint(_x, _y)
#        _x = _p1x + ((_sep + _ext) * _cos_angle)
#        _y = _p1y + ((_sep + _ext) * _sin_angle)
#        _bar1.setSecondEndpoint(_x, _y)
#        _x = _p2x + (_offset * _cos_angle)
#        _y = _p2y + (_offset * _sin_angle)
#        _bar2.setFirstEndpoint(_x, _y)
#        if _r &gt; 1.0:
#            _px = _p1x + (_r * _dpx)
#            _py = _p1y + (_r * _dpy)
#            _x = _px + (_sep * _cos_angle)
#            _y = _py + (_sep * _sin_angle)
#        else:
#            _x = _p2x + (_sep * _cos_angle)
#            _y = _p2y + (_sep * _sin_angle)
#        _crossbar.setSecondEndpoint(_x, _y)
#        _x = _p2x + (_sep * _cos_angle)
#        _y = _p2y + (_sep * _sin_angle)
#        _crossbar.setSecondCrossbarPoint(_x, _y)
#        _x = _p2x + ((_sep + _ext) * _cos_angle)
#        _y = _p2y + ((_sep + _ext) * _sin_angle)
#        _bar2.setSecondEndpoint(_x, _y)
#        if _allpts:
#            self.calcMarkerPoints()
#
#    def calcMarkerPoints(self):
#        """Calculate and store the dimension endpoint markers coordinates.
#
#calcMarkerPoints()
#        """
#        _type = self.getEndpointType()
#        _crossbar = self.__crossbar
#        _crossbar.clearMarkerPoints()
#        if _type == Dimension.DIM_ENDPT_NONE or _type == Dimension.DIM_ENDPT_CIRCLE:
#            return
#        _size = self.getEndpointSize()
#        _p1, _p2 = _crossbar.getCrossbarPoints()
#        _x1, _y1 = _p1
#        _x2, _y2 = _p2
#        # print "x1: %g" % _x1
#        # print "y1: %g" % _y1
#        # print "x2: %g" % _x2
#        # print "y2: %g" % _y2
#        _sine, _cosine = _crossbar.getSinCosValues()
#        if _type == Dimension.DIM_ENDPT_ARROW or _type == Dimension.DIM_ENDPT_FILLED_ARROW:
#            _height = _size/5.0
#            # p1 -&gt; (x,y) = (size, _height)
#            _mx = (_cosine * _size - _sine * _height) + _x1
#            _my = (_sine * _size + _cosine * _height) + _y1
#            _crossbar.storeMarkerPoint(_mx, _my)
#            # p2 -&gt; (x,y) = (size, -_height)
#            _mx = (_cosine * _size - _sine *(-_height)) + _x1
#            _my = (_sine * _size + _cosine *(-_height)) + _y1
#            _crossbar.storeMarkerPoint(_mx, _my)
#            # p3 -&gt; (x,y) = (-size, _height)
#            _mx = (_cosine * (-_size) - _sine * _height) + _x2
#            _my = (_sine * (-_size) + _cosine * _height) + _y2
#            _crossbar.storeMarkerPoint(_mx, _my)
#            # p4 -&gt; (x,y) = (-size, -_height)
#            _mx = (_cosine * (-_size) - _sine *(-_height)) + _x2
#            _my = (_sine * (-_size) + _cosine *(-_height)) + _y2
#            _crossbar.storeMarkerPoint(_mx, _my)
#        elif _type == Dimension.DIM_ENDPT_SLASH:
#            _angle = 30.0 * _dtr # slope of slash
#            _height = 0.5 * _size * math.sin(_angle)
#            _length = 0.5 * _size * math.cos(_angle)
#            # p1 -&gt; (x,y) = (-_length, -_height)
#            _sx1 = (_cosine * (-_length) - _sine * (-_height))
#            _sy1 = (_sine * (-_length) + _cosine * (-_height))
#            # p2 -&gt; (x,y) = (_length, _height)
#            _sx2 = (_cosine * _length - _sine * _height)
#            _sy2 = (_sine * _length + _cosine * _height)
#            #
#            # shift the calculate based on the location of the
#            # marker point
#            #
#            _mx = _sx1 + _x2
#            _my = _sy1 + _y2
#            _crossbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx2 + _x2
#            _my = _sy2 + _y2
#            _crossbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx1 + _x1
#            _my = _sy1 + _y1
#            _crossbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx2 + _x1
#            _my = _sy2 + _y1
#            _crossbar.storeMarkerPoint(_mx, _my)
#        else:
#            raise ValueError, "Unexpected endpoint type: '%s'" % str(_type)
#
#    def mapCoords(self, x, y, tol=tolerance.TOL):
#        """Test an x/y coordinate pair if it could lay on the dimension.
#
#mapCoords(x, y[, tol])
#
#This method has two required parameters:
#
#x: The x-coordinate
#y: The y-coordinate
#
#These should both be float values.
#
#There is an optional third parameter tol giving the maximum distance
#from the dimension bars that the x/y coordinates may lie.
#        """
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _t = tolerance.toltest(tol)
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        #
#        # test p1 bar
#        #
#        _mp = util.map_coords(_x, _y, _ep1[0], _ep1[1], _ep2[0], _ep2[1], _t)
#        if _mp is not None:
#            return _mp
#        #
#        # test p2 bar
#        #
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _mp = util.map_coords(_x, _y, _ep1[0], _ep1[1], _ep2[0], _ep2[1], _t)
#        if _mp is not None:
#            return _mp
#        #
#        # test crossbar
#        #
#        _ep1, _ep2 = self.__crossbar.getEndpoints()
#        return util.map_coords(_x, _y, _ep1[0], _ep1[1], _ep2[0], _ep2[1], _t)
#
#    def onDimension(self, x, y, tol=tolerance.TOL):
#        return self.mapCoords(x, y, tol) is not None
#
#    def getBounds(self):
#        """Return the minimal and maximal locations of the dimension
#
#getBounds()
#
#This method overrides the Dimension::getBounds() method
#        """
#        _dx, _dy = self.getLocation()
#        _dxpts = []
#        _dypts = []
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        _dxpts.append(_ep1[0])
#        _dypts.append(_ep1[1])
#        _dxpts.append(_ep2[0])
#        _dypts.append(_ep2[1])
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _dxpts.append(_ep1[0])
#        _dypts.append(_ep1[1])
#        _dxpts.append(_ep2[0])
#        _dypts.append(_ep2[1])
#        _ep1, _ep2 = self.__crossbar.getEndpoints()
#        _dxpts.append(_ep1[0])
#        _dypts.append(_ep1[1])
#        _dxpts.append(_ep2[0])
#        _dypts.append(_ep2[1])
#        _xmin = min(_dx, min(_dxpts))
#        _ymin = min(_dy, min(_dypts))
#        _xmax = max(_dx, max(_dxpts))
#        _ymax = max(_dy, max(_dypts))
#        return _xmin, _ymin, _xmax, _ymax
#
#    def clone(self):
#        _p1 = self.__p1
#        _p2 = self.__p2
#        _x, _y = self.getLocation()
#        _ds = self.getDimStyle()
#        _ldim = LinearDimension(_p1, _p2, _x, _y, _ds)
#        _ldim.copyDimValues(self)
#        return _ldim
#        
#    def __pointChangePending(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved':
#            self.startChange('moved')
#
#    def __pointChangeComplete(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved':
#            self.endChange('moved')
#
#    def __movePoint(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 2:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if p is not self.__p1 and p is not self.__p2:
#            raise ValueError, "Unexpected dimension point: " + `p`
#        _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#        self.calcDimValues(True)
#        self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#
#    def sendsMessage(self, m):
#        if m in LinearDimension.__messages:
#            return True
#        return super(LinearDimension, self).sendsMessage(m)
#
#class HorizontalDimension(LinearDimension):
#    """A class representing Horizontal dimensions.
#
#This class is derived from the LinearDimension class, so
#it shares all those attributes and methods of its parent.
#    """
#    def __init__(self, p1, p2, x, y, ds=None, **kw):
#        """Initialize a Horizontal Dimension.
#
#hdim = HorizontalDimension(p1, p2, x, y, ds)
#
#p1: A Point contained in a Layer
#p2: A Point contained in a Layer
#x: The x-coordinate of the dimensional text
#y: The y-coordinate of the dimensional text
#ds: The DimStyle used for this Dimension.
#        """
#        super(HorizontalDimension, self).__init__(p1, p2, x, y, ds, **kw)
#
#    def getValues(self):
#        """Return values comprising the HorizontalDimension.
#
#getValues()
#
#This method extends the LinearDimension::getValues() method.
#        """
#        _data = super(HorizontalDimension, self).getValues()
#        _data.setValue('type', 'hdim')
#        return _data
#
#    def calculate(self):
#        """Determine the length of this HorizontalDimension.
#
#calculate()
#        """
#        _p1, _p2 = self.getDimPoints()
#        return abs(_p1.x - _p2.x)
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display.
#
#calcDimValues([allpts])
#
#This method overrides the LinearDimension::calcDimValues() method.
#        """
#        _allpts = allpts
#        util.test_boolean(_allpts)
#        _p1, _p2 = self.getDimPoints()
#        _bar1, _bar2 = self.getDimBars()
#        _crossbar = self.getDimCrossbar()
#        _p1x, _p1y = _p1.getCoords()
#        _p2x, _p2y = _p2.getCoords()
#        _dx, _dy = self.getLocation()
#        _offset = self.getOffset()
#        _ext = self.getExtension()
#        _crossbar.setFirstEndpoint(_p1x, _dy)
#        _crossbar.setSecondEndpoint(_p2x, _dy)
#        if _dx &lt; min(_p1x, _p2x) or _dx &gt; max(_p1x, _p2x):
#            if _p1x &lt; _p2x:
#                if _dx &lt; _p1x:
#                    _crossbar.setFirstEndpoint(_dx, _dy)
#                if _dx &gt; _p2x:
#                    _crossbar.setSecondEndpoint(_dx, _dy)
#            else:
#                if _dx &lt; _p2x:
#                    _crossbar.setSecondEndpoint(_dx, _dy)
#                if _dx &gt; _p1x:
#                    _crossbar.setFirstEndpoint(_dx, _dy)
#        _crossbar.setFirstCrossbarPoint(_p1x, _dy)
#        _crossbar.setSecondCrossbarPoint(_p2x, _dy)
#        if _dy &lt; min(_p1y, _p2y):
#            _bar1.setFirstEndpoint(_p1x, (_p1y - _offset))
#            _bar1.setSecondEndpoint(_p1x, (_dy - _ext))
#            _bar2.setFirstEndpoint(_p2x, (_p2y - _offset))
#            _bar2.setSecondEndpoint(_p2x, (_dy - _ext))
#        elif _dy &gt; max(_p1y, _p2y):
#            _bar1.setFirstEndpoint(_p1x, (_p1y + _offset))
#            _bar1.setSecondEndpoint(_p1x, (_dy + _ext))
#            _bar2.setFirstEndpoint(_p2x, (_p2y + _offset))
#            _bar2.setSecondEndpoint(_p2x, (_dy + _ext))
#        else:
#            if _dy &gt; _p1y:
#                _bar1.setFirstEndpoint(_p1x, (_p1y + _offset))
#                _bar1.setSecondEndpoint(_p1x, (_dy + _ext))
#            else:
#                _bar1.setFirstEndpoint(_p1x, (_p1y - _offset))
#                _bar1.setSecondEndpoint(_p1x, (_dy - _ext))
#            if _dy &gt; _p2y:
#                _bar2.setFirstEndpoint(_p2x, (_p2y + _offset))
#                _bar2.setSecondEndpoint(_p2x, (_dy + _ext))
#            else:
#                _bar2.setFirstEndpoint(_p2x, (_p2y - _offset))
#                _bar2.setSecondEndpoint(_p2x, (_dy - _ext))
#        if _allpts:
#            self.calcMarkerPoints()
#
#    def clone(self):
#        _p1, _p2 = self.getDimPoints()
#        _x, _y = self.getLocation()
#        _ds = self.getDimStyle()
#        _hdim = HorizontalDimension(_p1, _p2, _x, _y, _ds)
#        _hdim.copyDimValues(self)
#        return _hdim
#
#class VerticalDimension(LinearDimension):
#    """A class representing Vertical dimensions.
#
#This class is derived from the LinearDimension class, so
#it shares all those attributes and methods of its parent.
#    """
#
#    def __init__(self, p1, p2, x, y, ds=None, **kw):
#        """Initialize a Vertical Dimension.
#
#vdim = VerticalDimension(p1, p2, x, y, ds)
#
#p1: A Point contained in a Layer
#p2: A Point contained in a Layer
#x: The x-coordinate of the dimensional text
#y: The y-coordinate of the dimensional text
#ds: The DimStyle used for this Dimension.
#        """
#        super(VerticalDimension, self).__init__(p1, p2, x, y, ds, **kw)
#
#    def getValues(self):
#        """Return values comprising the VerticalDimension.
#
#getValues()
#
#This method extends the LinearDimension::getValues() method.
#        """
#        _data = super(VerticalDimension, self).getValues()
#        _data.setValue('type', 'vdim')
#        return _data
#
#    def calculate(self):
#        """Determine the length of this VerticalDimension.
#
#calculate()
#        """
#        _p1, _p2 = self.getDimPoints()
#        return abs(_p1.y - _p2.y)
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display.
#
#calcDimValues([allpts])
#
#This method overrides the LinearDimension::calcDimValues() method.
#        """
#        _allpts = allpts
#        util.test_boolean(_allpts)
#        _p1, _p2 = self.getDimPoints()
#        _bar1, _bar2 = self.getDimBars()
#        _crossbar = self.getDimCrossbar()
#        _p1x, _p1y = _p1.getCoords()
#        _p2x, _p2y = _p2.getCoords()
#        _dx, _dy = self.getLocation()
#        _offset = self.getOffset()
#        _ext = self.getExtension()
#        _crossbar.setFirstEndpoint(_dx, _p1y)
#        _crossbar.setSecondEndpoint(_dx, _p2y)
#        if _dy &lt; min(_p1y, _p2y) or _dy &gt; max(_p1y, _p2y):
#            if _p1y &lt; _p2y:
#                if _dy &lt; _p1y:
#                    _crossbar.setFirstEndpoint(_dx, _dy)
#                if _dy &gt; _p2y:
#                    _crossbar.setSecondEndpoint(_dx, _dy)
#            if _p2y &lt; _p1y:
#                if _dy &lt; _p2y:
#                    _crossbar.setSecondEndpoint(_dx, _dy)
#                if _dy &gt; _p1y:
#                    _crossbar.setFirstEndpoint(_dx, _dy)
#        _crossbar.setFirstCrossbarPoint(_dx, _p1y)
#        _crossbar.setSecondCrossbarPoint(_dx, _p2y)
#        if _dx &lt; min(_p1x, _p2x):
#            _bar1.setFirstEndpoint((_p1x - _offset), _p1y)
#            _bar1.setSecondEndpoint((_dx - _ext), _p1y)
#            _bar2.setFirstEndpoint((_p2x - _offset), _p2y)
#            _bar2.setSecondEndpoint((_dx - _ext), _p2y)
#        elif _dx &gt; max(_p1x, _p2x):
#            _bar1.setFirstEndpoint((_p1x + _offset), _p1y)
#            _bar1.setSecondEndpoint((_dx + _ext), _p1y)
#            _bar2.setFirstEndpoint((_p2x + _offset), _p2y)
#            _bar2.setSecondEndpoint((_dx + _ext), _p2y)
#        else:
#            if _dx &gt; _p1x:
#                _bar1.setFirstEndpoint((_p1x + _offset), _p1y)
#                _bar1.setSecondEndpoint((_dx + _ext), _p1y)
#            else:
#                _bar1.setFirstEndpoint((_p1x - _offset), _p1y)
#                _bar1.setSecondEndpoint((_dx - _ext), _p1y)
#            if _dx &gt; _p2x:
#                _bar2.setFirstEndpoint((_p2x + _offset), _p2y)
#                _bar2.setSecondEndpoint((_dx + _ext), _p2y)
#            else:
#                _bar2.setFirstEndpoint((_p2x - _offset), _p2y)
#                _bar2.setSecondEndpoint((_dx - _ext), _p2y)
#        if _allpts:
#            self.calcMarkerPoints()
#
#    def clone(self):
#        _p1, _p2 = self.getDimPoints()
#        _x, _y = self.getLocation()
#        _ds = self.getDimStyle()
#        _vdim = VerticalDimension(_p1, _p2, _x, _y, _ds)
#        _vdim.copyDimValues(self)
#        return _vdim
#
#class RadialDimension(Dimension):
#    """A class for Radial dimensions.
#
#The RadialDimension class is derived from the Dimension
#class, so it shares all of those methods and attributes.
#A RadialDimension should be used to display either the
#radius or diamter of a Circle object.
#
#A RadialDimension object has the following methods:
#
#{get/set}DimCircle(): Get/Set the measured circle object.
#getDimLayer(): Return the layer containing the measured circle.
#{get/set}DiaMode(): Get/Set if the RadialDimension should return diameters.
#getDimXPoints(): Get the x-coordinates of the dimension bar positions.
#getDimYPoints(): Get the y-coordinates of the dimension bar positions.
#getDimMarkerPoints(): Get the locaiton of the dimension endpoint markers.
#getDimCrossbar(): Get the DimCrossbar object of the RadialDimension.
#calcDimValues(): Calculate the endpoint of the dimension line.
#mapCoords(): Return coordinates on the dimension near some point.
#onDimension(): Test if an x/y coordinate pair fall on the dimension line.
#    """
#    __messages = {
#        'dimobj_changed' : True,
#        'dia_mode_changed' : True,
#        }
#        
#    def __init__(self, cir, x, y, ds=None, **kw):
#        """Initialize a RadialDimension object.
#
#rdim = RadialDimension(cir, x, y, ds)
#
#cir: A Circle or Arc object
#x: The x-coordinate of the dimensional text
#y: The y-coordinate of the dimensional text
#ds: The DimStyle used for this Dimension.
#        """
#        super(RadialDimension, self).__init__(x, y, ds, **kw)
#        if not isinstance(cir, (circle.Circle, arc.Arc)):
#            raise TypeError, "Invalid circle/arc type: " + `type(cir)`
#        if cir.getParent() is None:
#            raise ValueError, "Circle/Arc not found in Layer!"
#        self.__circle = cir
#        self.__crossbar = DimCrossbar()
#        self.__dia_mode = False
#        cir.storeUser(self)
#        _ds = self.getDimStyle()
#        _pds, _sds = self.getDimstrings()
#        _pds.mute()
#        try:
#            _pds.setPrefix(_ds.getValue('RADIAL_DIM_PRIMARY_PREFIX'))
#            _pds.setSuffix(_ds.getValue('RADIAL_DIM_PRIMARY_SUFFIX'))
#        finally:
#            _pds.unmute()
#        _sds.mute()
#        try:
#            _sds.setPrefix(_ds.getValue('RADIAL_DIM_SECONDARY_PREFIX'))
#            _sds.setSuffix(_ds.getValue('RADIAL_DIM_SECONDARY_SUFFIX'))
#        finally:
#            _sds.unmute()
#        self.setDiaMode(_ds.getValue('RADIAL_DIM_DIA_MODE'))
#        cir.connect('moved', self.__moveCircle)
#        cir.connect('radius_changed', self.__radiusChanged)
#        cir.connect('change_pending', self.__circleChangePending)
#        cir.connect('change_complete', self.__circleChangeComplete)
#        self.calcDimValues()
#
#    def __eq__(self, rdim):
#        """Compare two RadialDimensions for equality.
#        """
#        if not isinstance(rdim, RadialDimension):
#            return False
#        _val = False
#        _layer = self.__circle.getParent()
#        _rc = rdim.getDimCircle()
#        _rl = _rc.getParent()
#        if _layer is _rl and self.__circle == _rc:
#            _val = True
#        return _val
#
#    def __ne__(self, rdim):
#        """Compare two RadialDimensions for inequality.
#        """
#        if not isinstance(rdim, RadialDimension):
#            return True
#        _val = True
#        _layer = self.__circle.getParent()
#        _rc = rdim.getDimCircle()
#        _rl = _rc.getParent()
#        if _layer is _rl and self.__circle == _rc:
#            _val = False
#        return _val
#
#    def finish(self):
#        self.__circle.disconnect(self)
#        self.__circle.freeUser(self)
#        self.__circle = self.__crossbar = None
#        super(RadialDimension, self).finish()
#
#    def getValues(self):
#        """Return values comprising the RadialDimension.
#
#getValues()
#
#This method extends the Dimension::getValues() method.
#        """
#        _data = super(RadialDimension, self).getValues()
#        _data.setValue('type', 'rdim')
#        _data.setValue('circle', self.__circle.getID())
#        _layer = self.__circle.getParent()
#        _data.setValue('layer', _layer.getID())
#        _data.setValue('dia_mode', self.__dia_mode)
#        return _data
#
#    def getDiaMode(self):
#        """Return if the RadialDimension will return diametrical values.
#
#getDiaMode()
#
#This method returns True if the diameter value is returned,
#and False otherwise.
#        """
#        return self.__dia_mode
#
#    def setDiaMode(self, mode=False):
#        """Set the RadialDimension to return diametrical values.
#
#setDiaMode([mode])
#
#Calling this method without an argument sets the RadialDimension
#to return radial measurements. If the argument "mode" is supplied,
#it should be either True or False.
#
#If the RadialDimension is measuring an arc, the returned value
#will always be set to return a radius.
#        """
#        util.test_boolean(mode)
#        if not isinstance(self.__circle, arc.Arc):
#            _m = self.__dia_mode
#            if _m is not mode:
#                self.startChange('dia_mode_changed')
#                self.__dia_mode = mode
#                self.endChange('dia_mode_changed')
#                self.sendMessage('dia_mode_changed', _m)
#                self.calcDimValues()
#                self.modified()
#
#    dia_mode = property(getDiaMode, setDiaMode, None,
#                        "Draw the Dimension as a diameter")
#
#    def getDimLayer(self):
#        """Return the Layer object holding the Circle for this RadialDimension.
#
#getDimLayer()
#        """
#        return self.__circle.getParent()
#
#    def getDimCircle(self):
#        """Return the Circle object this RadialDimension is measuring.
#
#getDimCircle()
#        """
#        return self.__circle
#
#    def setDimCircle(self, c):
#        """Set the Circle object measured by this RadialDimension.
#
#setDimCircle(c)
#
#The argument for this method is:
#
#c: A Circle/Arc contained in a Layer
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting circle/arc not allowed - object locked."
#        if not isinstance(c, (circle.Circle, arc.Arc)):
#            raise TypeError, "Invalid circle/arc type: " + `type(c)`
#        if c.getParent() is None:
#            raise ValueError, "Circle/Arc not found in a Layer!"
#        _circ = self.__circle
#        if _circ is not c:
#            _circ.disconnect(self)
#            _circ.freeUser(self)
#            self.startChange('dimobj_changed')
#            self.__circle = c
#            self.endChange('dimobj_changed')
#            c.storeUser(self)
#            self.sendMessage('dimobj_changed', _circ, c)
#            c.connect('moved', self.__moveCircle)
#            c.connect('radius_changed', self.__radiusChanged)
#            c.connect('change_pending', self.__circleChangePending)
#            c.connect('change_complete', self.__circleChangeComplete)
#            self.calcDimValues()
#            self.modified()
#
#    circle = property(getDimCircle, None, None,
#                      "Radial dimension circle object.")
#
#    def getDimCrossbar(self):
#        """Get the DimCrossbar object used by the RadialDimension.
#
#getDimCrossbar()
#        """
#        return self.__crossbar
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display.
#
#calcDimValues([allpts])
#
#The optional argument 'allpts' is by default True. Calling
#this method with the argument set to False will skip the
#calculation of any dimension endpoint marker points.
#        """
#        _allpts = allpts
#        util.test_boolean(_allpts)
#        _c = self.__circle
#        _dimbar = self.__crossbar
#        _cx, _cy = _c.getCenter().getCoords()
#        _rad = _c.getRadius()
#        _dx, _dy = self.getLocation()
#        _dia_mode = self.__dia_mode
#        _sep = math.hypot((_dx - _cx), (_dy - _cy))
#        _angle = math.atan2((_dy - _cy), (_dx - _cx))
#        _sx = _rad * math.cos(_angle)
#        _sy = _rad * math.sin(_angle)
#        if isinstance(_c, arc.Arc):
#            assert _dia_mode is False, "dia_mode for arc radial dimension"
#            _sa = _c.getStartAngle()
#            _ea = _c.getEndAngle()
#            _angle = _rtd * _angle
#            if _angle &lt; 0.0:
#                _angle = _angle + 360.0
#            if not _c.throughAngle(_angle):
#                _ep1, _ep2 = _c.getEndpoints()
#                if _angle &lt; _sa:
#                    _sa = _dtr * _sa
#                    _sx = _rad * math.cos(_sa)
#                    _sy = _rad * math.sin(_sa)
#                    if _sep &gt; _rad:
#                        _dx = _cx + (_sep * math.cos(_sa))
#                        _dy = _cy + (_sep * math.sin(_sa))
#                if _angle &gt; _ea:
#                    _ea = _dtr * _ea
#                    _sx = _rad * math.cos(_ea)
#                    _sy = _rad * math.sin(_ea)
#                    if _sep &gt; _rad:
#                        _dx = _cx + (_sep * math.cos(_ea))
#                        _dy = _cy + (_sep * math.sin(_ea))
#        if _dia_mode:
#            _dimbar.setFirstEndpoint((_cx - _sx), (_cy - _sy))
#            _dimbar.setFirstCrossbarPoint((_cx - _sx), (_cy - _sy))
#        else:
#            _dimbar.setFirstEndpoint(_cx, _cy)
#            _dimbar.setFirstCrossbarPoint(_cx, _cy)
#        if _sep &gt; _rad:
#            _dimbar.setSecondEndpoint(_dx, _dy)
#        else:
#            _dimbar.setSecondEndpoint((_cx + _sx), (_cy + _sy))
#        _dimbar.setSecondCrossbarPoint((_cx + _sx), (_cy + _sy))
#        if not _allpts:
#            return
#        #
#        # calculate dimension endpoint marker coordinates
#        #
#        _type = self.getEndpointType()
#        _dimbar.clearMarkerPoints()
#        if _type == Dimension.DIM_ENDPT_NONE or _type == Dimension.DIM_ENDPT_CIRCLE:
#            return
#        _size = self.getEndpointSize()
#        _x1, _y1 = _dimbar.getFirstCrossbarPoint()
#        _x2, _y2 = _dimbar.getSecondCrossbarPoint()
#        _sine, _cosine = _dimbar.getSinCosValues()
#        if _type == Dimension.DIM_ENDPT_ARROW or _type == Dimension.DIM_ENDPT_FILLED_ARROW:
#            _height = _size/5.0
#            # p1 -&gt; (x,y) = (size, _height)
#            _mx = (_cosine * _size - _sine * _height) + _x1
#            _my = (_sine * _size + _cosine * _height) + _y1
#            _dimbar.storeMarkerPoint(_mx, _my)
#            # p2 -&gt; (x,y) = (size, -_height)
#            _mx = (_cosine * _size - _sine *(-_height)) + _x1
#            _my = (_sine * _size + _cosine *(-_height)) + _y1
#            _dimbar.storeMarkerPoint(_mx, _my)
#            # p3 -&gt; (x,y) = (-size, _height)
#            _mx = (_cosine * (-_size) - _sine * _height) + _x2
#            _my = (_sine * (-_size) + _cosine * _height) + _y2
#            _dimbar.storeMarkerPoint(_mx, _my)
#            # p4 -&gt; (x,y) = (-size, -_height)
#            _mx = (_cosine * (-_size) - _sine *(-_height)) + _x2
#            _my = (_sine * (-_size) + _cosine *(-_height)) + _y2
#            _dimbar.storeMarkerPoint(_mx, _my)
#        elif _type == Dimension.DIM_ENDPT_SLASH:
#            _angle = 30.0 * _dtr # slope of slash
#            _height = 0.5 * _size * math.sin(_angle)
#            _length = 0.5 * _size * math.cos(_angle)
#            # p1 -&gt; (x,y) = (-_length, -_height)
#            _sx1 = (_cosine * (-_length) - _sine * (-_height))
#            _sy1 = (_sine * (-_length) + _cosine * (-_height))
#            # p2 -&gt; (x,y) = (_length, _height)
#            _sx2 = (_cosine * _length - _sine * _height)
#            _sy2 = (_sine * _length + _cosine * _height)
#            #
#            # shift the calculate based on the location of the
#            # marker point
#            #
#            _mx = _sx1 + _x1
#            _my = _sy1 + _y1
#            _dimbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx2 + _x1
#            _my = _sy2 + _y1
#            _dimbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx1 + _x2
#            _my = _sy1 + _y2
#            _dimbar.storeMarkerPoint(_mx, _my)
#            _mx = _sx2 + _x2
#            _my = _sy2 + _y2
#            _dimbar.storeMarkerPoint(_mx, _my)
#        else:
#            raise ValueError, "Unexpected endpoint type: '%s'" % str(_type)
#
#    def calculate(self):
#        """Return the radius or diamter of this RadialDimension.
#
#calculate()
#
#By default, a RadialDimension will return the radius of the
#circle. The setDiaMode() method can be called to set the
#returned value to corresponed to a diameter.
#        """
#        _val = self.__circle.getRadius()
#        if self.__dia_mode is True:
#            _val = _val * 2.0
#        return _val
#
#    def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
#        """Return whether or not a RadialDimension exists within a region.
#
#isRegion(xmin, ymin, xmax, ymax[, fully])
#
#The four arguments define the boundary of an area, and the
#function returns True if the RadialDimension lies within that
#area. If the optional argument 'fully' is used and is True,
#then the dimensioned circle and the location of the dimension
#text must lie within the boundary. Otherwise, the function
#returns False.
#        """
#        _xmin = util.get_float(xmin)
#        _ymin = util.get_float(ymin)
#        _xmax = util.get_float(xmax)
#        if _xmax &lt; _xmin:
#            raise ValueError, "Illegal values: xmax &lt; xmin"
#        _ymax = util.get_float(ymax)
#        if _ymax &lt; _ymin:
#            raise ValueError, "Illegal values: ymax &lt; ymin"
#        util.test_boolean(fully)
#        _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#        if ((_dxmin &gt; _xmax) or
#            (_dymin &gt; _ymax) or
#            (_dxmax &lt; _xmin) or
#            (_dymax &lt; _ymin)):
#            return False
#        if fully:
#            if ((_dxmin &gt; _xmin) and
#                (_dymin &gt; _ymin) and
#                (_dxmax &lt; _xmax) and
#                (_dymax &lt; _ymax)):
#                return True
#            return False
#        _dx, _dy = self.getLocation()
#        if _xmin &lt; _dx &lt; _xmax and _ymin &lt; _dy &lt; _ymax: # dim text
#            return True
#        _p1, _p2 = self.__crossbar.getEndpoints()
#        _x1, _y1 = _p1
#        _x2, _y2 = _p2
#        return util.in_region(_x1, _y1, _x2, _y2, _xmin, _ymin, _xmax, _ymax)
#
#    def mapCoords(self, x, y, tol=tolerance.TOL):
#        """Test an x/y coordinate pair if it could lay on the dimension.
#
#mapCoords(x, y[, tol])
#
#This method has two required parameters:
#
#x: The x-coordinate
#y: The y-coordinate
#
#These should both be float values.
#
#There is an optional third parameter, 'tol', giving
#the maximum distance from the dimension bars that the
#x/y coordinates may sit.
#        """
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _t = tolerance.toltest(tol)
#        _p1, _p2 = self.__crossbar.getEndpoints()
#        _x1, _y1 = _p1
#        _x2, _y2 = _p2
#        return util.map_coords(_x, _y, _x1, _y1, _x2, _y2, _t)
#
#    def onDimension(self, x, y, tol=tolerance.TOL):
#        return self.mapCoords(x, y, tol) is not None
#
#    def getBounds(self):
#        """Return the minimal and maximal locations of the dimension
#
#getBounds()
#
#This method overrides the Dimension::getBounds() method
#        """
#        _p1, _p2 = self.__crossbar.getEndpoints()
#        _x1, _y1 = _p1
#        _x2, _y2 = _p2
#        _xmin = min(_x1, _x2)
#        _ymin = min(_y1, _y2)
#        _xmax = max(_x1, _x2)
#        _ymax = max(_y1, _y2)
#        return _xmin, _ymin, _xmax, _ymax
#
#    def clone(self):
#        _c = self.__circle
#        _x, _y = self.getLocation()
#        _ds = self.getDimStyle()
#        _rdim = RadialDimension(_c, _x, _y, _ds)
#        _rdim.copyDimValues(self)
#        _rdim.setDiaMode(self.getDiaMode())
#        return _rdim
#
#    def __circleChangePending(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved' or args[0] =='radius_changed':
#            self.startChange('moved')
#
#    def __circleChangeComplete(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved' or args[0] =='radius_changed':
#            self.endChange('moved')
#
#    def __moveCircle(self, circ, *args):
#        _alen = len(args)
#        if _alen &lt; 3:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if circ is not self.__circle:
#            raise ValueError, "Unexpected sender: " + `circ`
#        _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#        self.calcDimValues()
#        self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#
#    def __radiusChanged(self, circ, *args):
#        self.calcDimValues()
#        
#    def sendsMessage(self, m):
#        if m in RadialDimension.__messages:
#            return True
#        return super(RadialDimension, self).sendsMessage(m)
#
#class AngularDimension(Dimension):
#    """A class for Angular dimensions.
#
#The AngularDimension class is derived from the Dimension
#class, so it shares all of those methods and attributes.
#
#AngularDimension objects have the following methods:
#
#{get/set}VertexPoint(): Get/Set the vertex point for the AngularDimension.
#{get/set}P1(): Get/Set the first Point for the AngularDimension.
#{get/set}P2(): Get/Set the second Point for the AngularDimension.
#getDimPoints(): Return the two Points used in this dimension.
#getDimLayers(): Return the two Layers holding the Points.
#getDimXPoints(): Get the x-coordinates of the dimension bar positions.
#getDimYPoints(): Get the y-coordinates of the dimension bar positions.
#getDimAngles(): Get the angles at which the dimension bars should be drawn.
#getDimMarkerPoints(): Get the locaiton of the dimension endpoint markers.
#calcDimValues(): Calculate the endpoint of the dimension line.
#mapCoords(): Return coordinates on the dimension near some point.
#onDimension(): Test if an x/y coordinate pair fall on the dimension line.
#invert(): Switch the endpoints used to measure the dimension
#    """
#
#    __messages = {
#        'point_changed' : True,
#        'inverted' : True,
#        }
#        
#    def __init__(self, vp, p1, p2, x, y, ds=None, **kw):
#        """Initialize an AngularDimension object.
#
#adim = AngularDimension(vp, p1, p2, x, y, ds)
#
#vp: A Point contained in a Layer
#p1: A Point contained in a Layer
#p2: A Point contained in a Layer
#x: The x-coordinate of the dimensional text
#y: The y-coordinate of the dimensional text
#ds: The DimStyle used for this Dimension.
#        """
#        super(AngularDimension, self).__init__(x, y, ds, **kw)
#        if not isinstance(vp, point.Point):
#            raise TypeError, "Invalid point type: " + `type(vp)`
#        if vp.getParent() is None:
#            raise ValueError, "Vertex Point not found in a Layer!"
#        if not isinstance(p1, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p1)`
#        if p1.getParent() is None:
#            raise ValueError, "Point P1 not found in a Layer!"
#        if not isinstance(p2, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p2)`
#        if p2.getParent() is None:
#            raise ValueError, "Point P2 not found in a Layer!"
#        self.__vp = vp
#        self.__p1 = p1
#        self.__p2 = p2
#        self.__bar1 = DimBar()
#        self.__bar2 = DimBar()
#        self.__crossarc = DimCrossarc()
#        _ds = self.getDimStyle()
#        _pds, _sds = self.getDimstrings()
#        _pds.mute()
#        try:
#            _pds.setPrefix(_ds.getValue('ANGULAR_DIM_PRIMARY_PREFIX'))
#            _pds.setSuffix(_ds.getValue('ANGULAR_DIM_PRIMARY_SUFFIX'))
#        finally:
#            _pds.unmute()
#        _sds.mute()
#        try:
#            _sds.setPrefix(_ds.getValue('ANGULAR_DIM_SECONDARY_PREFIX'))
#            _sds.setSuffix(_ds.getValue('ANGULAR_DIM_SECONDARY_SUFFIX'))
#        finally:
#            _sds.unmute()
#        vp.storeUser(self)
#        vp.connect('moved', self.__movePoint)
#        vp.connect('change_pending', self.__pointChangePending)
#        vp.connect('change_complete', self.__pointChangeComplete)
#        p1.storeUser(self)
#        p1.connect('moved', self.__movePoint)
#        p1.connect('change_pending', self.__pointChangePending)
#        p1.connect('change_complete', self.__pointChangeComplete)
#        p2.storeUser(self)
#        p2.connect('moved', self.__movePoint)
#        p2.connect('change_pending', self.__pointChangePending)
#        p2.connect('change_complete', self.__pointChangeComplete)
#        self.calcDimValues()
#
#    def __eq__(self, adim):
#        """Compare two AngularDimensions for equality.
#        """
#        if not isinstance(adim, AngularDimension):
#            return False
#        _val = False
#        _lvp = self.__vp.getParent()
#        _lp1 = self.__p1.getParent()
#        _lp2 = self.__p2.getParent()
#        _vl, _l1, _l2 = adim.getDimLayers()
#        _vp, _p1, _p2 = adim.getDimPoints()
#        if (_lvp is _vl and
#            self.__vp == _vp and
#            _lp1 is _l1 and
#            self.__p1 == _p1 and
#            _lp2 is _l2 and
#            self.__p2 == _p2):
#            _val = True
#        return _val
#
#    def __ne__(self, adim):
#        """Compare two AngularDimensions for inequality.
#        """
#        if not isinstance(adim, AngularDimension):
#            return True
#        _val = True
#        _lvp = self.__vp.getParent()
#        _lp1 = self.__p1.getParent()
#        _lp2 = self.__p2.getParent()
#        _vl, _l1, _l2 = adim.getDimLayers()
#        _vp, _p1, _p2 = adim.getDimPoints()
#        if (_lvp is _vl and
#            self.__vp == _vp and
#            _lp1 is _l1 and
#            self.__p1 == _p1 and
#            _lp2 is _l2 and
#            self.__p2 == _p2):
#            _val = False
#        return _val
#
#    def finish(self):
#        self.__vp.disconnect(self)
#        self.__vp.freeUser(self)
#        self.__p1.disconnect(self)
#        self.__p1.freeUser(self)
#        self.__p2.disconnect(self)
#        self.__p2.freeUser(self)
#        self.__bar1 = self.__bar2 = self.__crossarc = None
#        self.__vp = self.__p1 = self.__p2 = None
#        super(AngularDimension, self).finish()
#
#    def getValues(self):
#        """Return values comprising the AngularDimension.
#
#getValues()
#
#This method extends the Dimension::getValues() method.
#        """
#        _data = super(AngularDimension, self).getValues()
#        _data.setValue('type', 'adim')
#        _data.setValue('vp', self.__vp.getID())
#        _layer = self.__vp.getParent()
#        _data.setValue('vl', _layer.getID())
#        _data.setValue('p1', self.__p1.getID())
#        _layer = self.__p1.getParent()
#        _data.setValue('l1', _layer.getID())
#        _data.setValue('p2', self.__p2.getID())
#        _layer = self.__p2.getParent()
#        _data.setValue('l2', _layer.getID())
#        return _data
#
#    def getDimLayers(self):
#        """Return the layers used in an AngularDimension.
#
#getDimLayers()
#        """
#        _vl = self.__vp.getParent()
#        _l1 = self.__p1.getParent()
#        _l2 = self.__p2.getParent()
#        return _vl, _l1, _l2
#
#    def getDimPoints(self):
#        """Return the points used in an AngularDimension.
#
#getDimPoints()
#        """
#        return self.__vp, self.__p1, self.__p2
#
#    def getVertexPoint(self):
#        """Return the vertex point used in an AngularDimension.
#
#getVertexPoint()
#        """
#        return self.__vp
#
#    def setVertexPoint(self, p):
#        """Set the vertex point for an AngularDimension.
#
#setVertexPoint(p)
#
#There is one required argument for this method:
#
#p: A Point contained in Layer
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting vertex point allowed - object locked."
#        if not isinstance(p, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p)`
#        if p.getParent() is None:
#            raise ValueError, "Point not found in a Layer!"
#        _vp = self.__vp
#        if _vp is not p:
#            _vp.disconnect(self)
#            _vp.freeUser(self)
#            self.startChange('point_changed')
#            self.__vp = p
#            self.endChange('point_changed')
#            p.storeUser(self)
#            p.connect('moved', self.__movePoint)
#            p.connect('change_pending', self.__pointChangePending)
#            p.connect('change_complete', self.__pointChangeComplete)
#            self.sendMessage('point_changed', _vp, p)
#            self.calcDimValues()
#            if abs(_vp.x - p.x) &gt; 1e-10 or abs(_vp.y - p.y) &gt; 1e-10:
#                _x1, _y1 = self.__p1.getCoords()
#                _x2, _y2 = self.__p2.getCoords()
#                _dx, _dy = self.getLocation()
#                self.sendMessage('moved', _vp.x, _vp.y, _x1, _y1,
#                                 _x2, _y2, _dx, _dy)
#            self.modified()
#
#    vp = property(getVertexPoint, None, None,
#                  "Angular Dimension vertex point.")
#
#    def getP1(self):
#        """Return the first angle point used in an AngularDimension.
#
#getP1()
#        """
#        return self.__p1
#
#    def setP1(self, p):
#        """Set the first Point for an AngularDimension.
#
#setP1(p)
#
#There is one required argument for this method:
#
#p: A Point contained in a Layer.
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting vertex point allowed - object locked."
#        if not isinstance(p, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p)`
#        if p.getParent() is None:
#            raise ValueError, "Point not found in a Layer!"
#        _p1 = self.__p1
#        if _p1 is not p:
#            _p1.disconnect(self)
#            _p1.freeUser(self)
#            self.startChange('point_changed')
#            self.__p1 = p
#            self.endChange('point_changed')
#            p.storeUser(self)
#            p.connect('moved', self.__movePoint)
#            p.connect('change_pending', self.__pointChangePending)
#            p.connect('change_complete', self.__pointChangeComplete)
#            self.sendMessage('point_changed', _p1, p)
#            self.calcDimValues()
#            if abs(_p1.x - p.x) &gt; 1e-10 or abs(_p1.y - p.y) &gt; 1e-10:
#                _vx, _vy = self.__vp.getCoords()
#                _x2, _y2 = self.__p2.getCoords()
#                _dx, _dy = self.getLocation()
#                self.sendMessage('moved', _vx, _vy, _p1.x, _p1.y,
#                                 _x2, _y2, _dx, _dy)
#            self.modified()
#
#    p1 = property(getP1, None, None, "Dimension first point.")
#
#    def getP2(self):
#        """Return the second angle point used in an AngularDimension.
#
#getP2()
#        """
#        return self.__p2
#
#    def setP2(self, p):
#        """Set the second Point for an AngularDimension.
#
#setP2(p)
#
#There is one required argument for this method:
#
#l: The layer holding the Point p
#p: A point in Layer l
#        """
#        if self.isLocked():
#            raise RuntimeError, "Setting vertex point allowed - object locked."
#        if not isinstance(p, point.Point):
#            raise TypeError, "Invalid point type: " + `type(p)`
#        if p.getParent() is None:
#            raise ValueError, "Point not found in a Layer!"
#        _p2 = self.__p2
#        if _p2 is not p:
#            _p2.disconnect(self)
#            _p2.freeUser(self)
#            self.startChange('point_changed')
#            self.__p2 = p
#            self.endChange('point_changed')
#            p.storeUser(self)
#            p.connect('moved', self.__movePoint)
#            p.connect('change_pending', self.__pointChangePending)
#            p.connect('change_complete', self.__pointChangeComplete)
#            self.sendMessage('point_changed', _p2, p)
#            self.calcDimValues()
#            if abs(_p2.x - p.x) &gt; 1e-10 or abs(_p2.y - p.y) &gt; 1e-10:
#                _vx, _vy = self.__vp.getCoords()
#                _x1, _y1 = self.__p1.getCoords()
#                _dx, _dy = self.getLocation()
#                self.sendMessage('moved', _vx, _vy, _x1, _y1,
#                                 _p2.x, _p2.y, _dx, _dy)
#            self.modified()
#
#
#    p2 = property(getP2, None, None, "Dimension second point.")
#
#    def getDimAngles(self):
#        """Get the array of dimension bar angles.
#
#geDimAngles()
#        """
#        _angle1 = self.__bar1.getAngle()
#        _angle2 = self.__bar2.getAngle()
#        return _angle1, _angle2
#
#    def getDimRadius(self):
#        """Get the radius of the dimension crossarc.
#
#getDimRadius()
#        """
#        return self.__crossarc.getRadius()
#
#    def getDimBars(self):
#        """Return the dimension boundary bars.
#
#getDimBars()
#        """
#        return self.__bar1, self.__bar2
#
#    def getDimCrossarc(self):
#        """Get the DimCrossarc object used by the AngularDimension.
#
#getDimCrossarc()
#        """
#        return self.__crossarc
#
#    def invert(self):
#        """Switch the endpoints used in this object.
#
#invert()
#
#Invoking this method on an AngularDimension will result in
#it measuring the opposite angle than what it currently measures.
#        """
#        _pt = self.__p1
#        self.startChange('inverted')
#        self.__p1 = self.__p2
#        self.__p2 = _pt
#        self.endChange('inverted')
#        self.sendMessage('inverted')
#        self.calcDimValues()
#        self.modified()
#
#    def calculate(self):
#        """Find the value of the angle measured by this AngularDimension.
#
#calculate()
#        """
#        _vx, _vy = self.__vp.getCoords()
#        _p1x, _p1y = self.__p1.getCoords()
#        _p2x, _p2y = self.__p2.getCoords()
#        _a1 = _rtd * math.atan2((_p1y - _vy), (_p1x - _vx))
#        if _a1 &lt; 0.0:
#            _a1 = _a1 + 360.0
#        _a2 = _rtd * math.atan2((_p2y - _vy), (_p2x - _vx))
#        if _a2 &lt; 0.0:
#            _a2 = _a2 + 360.0
#        _val = _a2 - _a1
#        if _a1 &gt; _a2:
#            _val = _val + 360.0
#        return _val
#
#    def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
#        """Return whether or not an AngularDimension exists within a region.
#
#isRegion(xmin, ymin, xmax, ymax[, fully])
#
#The four arguments define the boundary of an area, and the
#function returns True if the RadialDimension lies within that
#area. If the optional argument 'fully' is used and is True,
#then the dimensioned circle and the location of the dimension
#text must lie within the boundary. Otherwise, the function
#returns False.
#        """
#        _xmin = util.get_float(xmin)
#        _ymin = util.get_float(ymin)
#        _xmax = util.get_float(xmax)
#        if _xmax &lt; _xmin:
#            raise ValueError, "Illegal values: xmax &lt; xmin"
#        _ymax = util.get_float(ymax)
#        if _ymax &lt; _ymin:
#            raise ValueError, "Illegal values: ymax &lt; ymin"
#        util.test_boolean(fully)
#        _vx, _vy = self.__vp.getCoords()
#        _dx, _dy = self.getLocation()
#        _pxmin, _pymin, _pxmax, _pymax = self.getBounds()
#        _val = False
#        if ((_pxmin &gt; _xmax) or
#            (_pymin &gt; _ymax) or
#            (_pxmax &lt; _xmin) or
#            (_pymax &lt; _ymin)):
#            return False
#        if _xmin &lt; _dx &lt; _xmax and _ymin &lt; _dy &lt; _ymax:
#            return True
#        #
#        # bar on vp-p1 line
#        #
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        _ex1, _ey1 = _ep1
#        _ex2, _ey2 = _ep2
#        if util.in_region(_ex1, _ey1, _ex2, _ey2, _xmin, _ymin, _xmax, _ymax):
#            return True
#        #
#        # bar at vp-p2 line
#        #
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _ex1, _ey1 = _ep1
#        _ex2, _ey2 = _ep2
#        if util.in_region(_ex1, _ey1, _ex2, _ey2, _xmin, _ymin, _xmax, _ymax):
#            return True
#        #
#        # dimension crossarc
#        #
#        _val = False
#        _r = self.__crossarc.getRadius()
#        _d1 = math.hypot((_xmin - _vx), (_ymin - _vy))
#        _d2 = math.hypot((_xmin - _vx), (_ymax - _vy))
#        _d3 = math.hypot((_xmax - _vx), (_ymax - _vy))
#        _d4 = math.hypot((_xmax - _vx), (_ymin - _vy))
#        _dmin = min(_d1, _d2, _d3, _d4)
#        _dmax = max(_d1, _d2, _d3, _d4)
#        if _xmin &lt; _vx &lt; _xmax and _ymin &lt; _vy &lt; _ymax:
#            _dmin = -1e-10
#        else:
#            if _vx &gt; _xmax and _ymin &lt; _vy &lt; _ymax:
#                _dmin = _vx - _xmax
#            elif _vx &lt; _xmin and _ymin &lt; _vy &lt; _ymax:
#                _dmin = _xmin - _vx
#            elif _vy &gt; _ymax and _xmin &lt; _vx &lt; _xmax:
#                _dmin = _vy - _ymax
#            elif _vy &lt; _ymin and _xmin &lt; _vx &lt; _xmax:
#                _dmin = _ymin - _vy
#        if _dmin &lt; _r &lt; _dmax:
#            _da = _rtd * math.atan2((_ymin - _vy), (_xmin - _vx))
#            if _da &lt; 0.0:
#                _da = _da + 360.0
#            _val = self._throughAngle(_da)
#            if _val:
#                return _val
#            _da = _rtd * math.atan2((_ymin - _vy), (_xmax - _vx))
#            if _da &lt; 0.0:
#                _da = _da + 360.0
#            _val = self._throughAngle(_da)
#            if _val:
#                return _val
#            _da = _rtd * math.atan2((_ymax - _vy), (_xmax - _vx))
#            if _da &lt; 0.0:
#                _da = _da + 360.0
#            _val = self._throughAngle(_da)
#            if _val:
#                return _val
#            _da = _rtd * math.atan2((_ymax - _vy), (_xmin - _vx))
#            if _da &lt; 0.0:
#                _da = _da + 360.0
#            _val = self._throughAngle(_da)
#        return _val
#
#    def _throughAngle(self, angle):
#        """Test if the angular crossarc exists at a certain angle.
#
#_throughAngle()
#
#This method is private to the AngularDimension class.
#        """
#        _crossarc = self.__crossarc
#        _sa = _crossarc.getStartAngle()
#        _ea = _crossarc.getEndAngle()
#        _val = True
#        if abs(_sa - _ea) &gt; 1e-10:
#            if _sa &gt; _ea:
#                if angle &gt; _ea and angle &lt; _sa:
#                    _val = False
#            else:
#                if angle &gt; _ea or angle &lt; _sa:
#                    _val = False
#        return _val
#
#    def calcDimValues(self, allpts=True):
#        """Recalculate the values for dimensional display.
#
#calcDimValues([allpts])
#
#The optional argument 'allpts' is by default True. Calling
#this method with the argument set to False will skip the
#calculation of any dimension endpoint marker points.
#        """
#        _allpts = allpts
#        util.test_boolean(_allpts)
#        _vx, _vy = self.__vp.getCoords()
#        _p1x, _p1y = self.__p1.getCoords()
#        _p2x, _p2y = self.__p2.getCoords()
#        _dx, _dy = self.getLocation()
#        _offset = self.getOffset()
#        _ext = self.getExtension()
#        _bar1 = self.__bar1
#        _bar2 = self.__bar2
#        _crossarc = self.__crossarc
#        _dv1 = math.hypot((_p1x - _vx), (_p1y - _vy))
#        _dv2 = math.hypot((_p2x - _vx), (_p2y - _vy))
#        _ddp = math.hypot((_dx - _vx), (_dy - _vy))
#        _crossarc.setRadius(_ddp)
#        #
#        # first dimension bar
#        #
#        _angle = math.atan2((_p1y - _vy), (_p1x - _vx))
#        _sine = math.sin(_angle)
#        _cosine = math.cos(_angle)
#        _deg = _angle * _rtd
#        if _deg &lt; 0.0:
#            _deg = _deg + 360.0
#        _crossarc.setStartAngle(_deg)
#        _ex = _vx + (_ddp * _cosine)
#        _ey = _vy + (_ddp * _sine)
#        _crossarc.setFirstCrossbarPoint(_ex, _ey)
#        _crossarc.setFirstEndpoint(_ex, _ey)
#        if _ddp &gt; _dv1: # dim point is radially further to vp than p1
#            _x1 = _p1x + (_offset * _cosine)
#            _y1 = _p1y + (_offset * _sine)
#            _x2 = _vx + ((_ddp + _ext) * _cosine)
#            _y2 = _vy + ((_ddp + _ext) * _sine)
#        else: # dim point is radially closer to vp than p1
#            _x1 = _p1x - (_offset * _cosine)
#            _y1 = _p1y - (_offset * _sine)
#            _x2 = _vx + ((_ddp - _ext) * _cosine)
#            _y2 = _vy + ((_ddp - _ext) * _sine)
#        _bar1.setFirstEndpoint(_x1, _y1)
#        _bar1.setSecondEndpoint(_x2, _y2)
#        #
#        # second dimension bar
#        #
#        _angle = math.atan2((_p2y - _vy), (_p2x - _vx))
#        _sine = math.sin(_angle)
#        _cosine = math.cos(_angle)
#        _deg = _angle * _rtd
#        if _deg &lt; 0.0:
#            _deg = _deg + 360.0
#        _crossarc.setEndAngle(_deg)
#        _ex = _vx + (_ddp * _cosine)
#        _ey = _vy + (_ddp * _sine)
#        _crossarc.setSecondCrossbarPoint(_ex, _ey)
#        _crossarc.setSecondEndpoint(_ex, _ey)
#        if _ddp &gt; _dv2: # dim point is radially further to vp than p2
#            _x1 = _p2x + (_offset * _cosine)
#            _y1 = _p2y + (_offset * _sine)
#            _x2 = _vx + ((_ddp + _ext) * _cosine)
#            _y2 = _vy + ((_ddp + _ext) * _sine)
#        else: # dim point is radially closers to vp than p2
#            _x1 = _p2x - (_offset * _cosine)
#            _y1 = _p2y - (_offset * _sine)
#            _x2 = _vx + ((_ddp - _ext) * _cosine)
#            _y2 = _vy + ((_ddp - _ext) * _sine)
#        _bar2.setFirstEndpoint(_x1, _y1)
#        _bar2.setSecondEndpoint(_x2, _y2)
#        #
#        # test if the DimString lies outside the measured angle
#        # and if it does adjust either the crossarc start or end angle
#        #
#        _deg = _rtd * math.atan2((_dy - _vy), (_dx - _vx))
#        if _deg &lt; 0.0:
#            _deg = _deg + 360.0
#        _csa = _crossarc.getStartAngle()
#        _cea = _crossarc.getEndAngle()
#        if ((_csa &gt; _cea) and (_cea &lt; _deg &lt; _csa)):
#            if abs(_csa - _deg) &lt; abs(_deg - _cea): # closer to start
#                _crossarc.setStartAngle(_deg)
#            else:
#                _crossarc.setEndAngle(_deg)
#        elif ((_cea &gt; _csa) and ((_csa &gt; _deg) or (_cea &lt; _deg))):
#            if _deg &gt; _cea:
#                _a1 = _deg - _cea
#                _a2 = 360.0 - _deg + _csa
#            else:
#                _a1 = 360.0 - _cea + _deg
#                _a2 = _csa - _deg
#            if abs(_a1) &gt; abs(_a2): # closer to start
#                _crossarc.setStartAngle(_deg)
#            else:
#                _crossarc.setEndAngle(_deg)
#        else:
#            pass
#        if not _allpts:
#            return
#        #
#        # calculate dimension endpoint marker coordinates
#        #
#        _type = self.getEndpointType()
#        _crossarc.clearMarkerPoints()
#        if _type == Dimension.DIM_ENDPT_NONE or _type == Dimension.DIM_ENDPT_CIRCLE:
#            return
#        _size = self.getEndpointSize()
#        _a1 = _bar1.getAngle() - 90.0
#        _a2 = _bar2.getAngle() - 90.0
#        # print "a1: %g" % _a1
#        # print "a2: %g" % _a2
#        _mp1, _mp2 = _crossarc.getCrossbarPoints()
#        _x1, _y1 = _mp1
#        _x2, _y2 = _mp2
#        # print "x1: %g" % _x1
#        # print "y1: %g" % _y1
#        # print "x2: %g" % _x2
#        # print "y2: %g" % _y2
#        _sin1 = math.sin(_dtr * _a1)
#        _cos1 = math.cos(_dtr * _a1)
#        _sin2 = math.sin(_dtr * _a2)
#        _cos2 = math.cos(_dtr * _a2)
#        if _type == Dimension.DIM_ENDPT_ARROW or _type == Dimension.DIM_ENDPT_FILLED_ARROW:
#            _height = _size/5.0
#            # p1 -&gt; (x,y) = (size, _height)
#            _mx = (_cos1 * (-_size) - _sin1 * _height) + _x1
#            _my = (_sin1 * (-_size) + _cos1 * _height) + _y1
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p2 -&gt; (x,y) = (size, -_height)
#            _mx = (_cos1 * (-_size) - _sin1 *(-_height)) + _x1
#            _my = (_sin1 * (-_size) + _cos1 *(-_height)) + _y1
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p3 -&gt; (x,y) = (size, _height)
#            _mx = (_cos2 * _size - _sin2 * _height) + _x2
#            _my = (_sin2 * _size + _cos2 * _height) + _y2
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p4 -&gt; (x,y) = (size, -_height)
#            _mx = (_cos2 * _size - _sin2 *(-_height)) + _x2
#            _my = (_sin2 * _size + _cos2 *(-_height)) + _y2
#            _crossarc.storeMarkerPoint(_mx, _my)
#        elif _type == Dimension.DIM_ENDPT_SLASH:
#            _angle = 30.0 * _dtr # slope of slash
#            _height = 0.5 * _size * math.sin(_angle)
#            _length = 0.5 * _size * math.cos(_angle)
#            # p1 -&gt; (x,y) = (-_length, -_height)
#            _mx = (_cos1 * (-_length) - _sin1 * (-_height)) + _x1
#            _my = (_sin1 * (-_length) + _cos1 * (-_height)) + _y1
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p2 -&gt; (x,y) = (_length, _height)
#            _mx = (_cos1 * _length - _sin1 * _height) + _x1
#            _my = (_sin1 * _length + _cos1 * _height) + _y1
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p3 -&gt; (x,y) = (-_length, -_height)
#            _mx = (_cos2 * (-_length) - _sin2 * (-_height)) + _x2
#            _my = (_sin2 * (-_length) + _cos2 * (-_height)) + _y2
#            _crossarc.storeMarkerPoint(_mx, _my)
#            # p4 -&gt; (x,y) = (_length, _height)
#            _mx = (_cos2 * _length - _sin2 * _height) + _x2
#            _my = (_sin2 * _length + _cos2 * _height) + _y2
#            _crossarc.storeMarkerPoint(_mx, _my)
#        else:
#            raise ValueError, "Unexpected endpoint type: '%s'" % str(_type)
#
#    def mapCoords(self, x, y, tol=tolerance.TOL):
#        """Test an x/y coordinate pair hit the dimension lines and arc.
#
#mapCoords(x, y[, tol])
#
#This method has two required parameters:
#
#x: The x-coordinate
#y: The y-coordinate
#
#These should both be float values.
#
#There is an optional third parameter, 'tol', giving
#the maximum distance from the dimension bars that the
#x/y coordinates may sit.
#        """
#        _x = util.get_float(x)
#        _y = util.get_float(y)
#        _t = tolerance.toltest(tol)
#        #
#        # test vp-p1 bar
#        #
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        _ex1, _ey1 = _ep1
#        _ex2, _ey2 = _ep2
#        _mp = util.map_coords(_x, _y, _ex1, _ey1, _ex2, _ey2, _t)
#        if _mp is not None:
#            return _mp
#        #
#        # test vp-p2 bar
#        #
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _mp = util.map_coords(_x, _y, _ex1, _ey1, _ex2, _ey2, _t)
#        if _mp is not None:
#            return _mp
#        #
#        # test the arc
#        #
#        _vx, _vy = self.__vp.getCoords()
#        _psep = math.hypot((_vx - _x), (_vy - y))
#        _dx, _dy = self.getLocation()
#        _dsep = math.hypot((_vx - _dx), (_vy - _dy))
#        if abs(_psep - _dsep) &lt; _t:
#            _crossarc = self.__crossarc
#            _sa = _crossarc.getStartAngle()
#            _ea = _crossarc.getEndAngle()
#            _angle = _rtd * math.atan2((_y - _vy), (_x - _vx))
#            _val = True
#            if abs(_sa - _ea) &gt; 1e-10:
#                if _sa &lt; _ea:
#                    if _angle &lt; _sa or  _angle &gt; _ea:
#                        _val = False
#                else:
#                    if _angle &gt; _ea or _angle &lt; _sa:
#                        _val = False
#            if _val:
#                _xoff = _dsep * math.cos(_angle)
#                _yoff = _dsep * math.sin(_angle)
#                return (_vx + _xoff), (_vy + _yoff)
#        return None
#
#    def onDimension(self, x, y, tol=tolerance.TOL):
#        return self.mapCoords(x, y, tol) is not None
#
#    def getBounds(self):
#        """Return the minimal and maximal locations of the dimension
#
#getBounds()
#
#This method overrides the Dimension::getBounds() method
#        """
#        _vx, _vy = self.__vp.getCoords()
#        _dx, _dy = self.getLocation()
#        _dxpts = []
#        _dypts = []
#        _ep1, _ep2 = self.__bar1.getEndpoints()
#        _dxpts.append(_ep1[0])
#        _dypts.append(_ep1[1])
#        _dxpts.append(_ep2[0])
#        _dypts.append(_ep2[1])
#        _ep1, _ep2 = self.__bar2.getEndpoints()
#        _dxpts.append(_ep1[0])
#        _dypts.append(_ep1[1])
#        _dxpts.append(_ep2[0])
#        _dypts.append(_ep2[1])
#        _rad = self.__crossarc.getRadius()
#        if self._throughAngle(0.0):
#            _dxpts.append((_vx + _rad))
#        if self._throughAngle(90.0):
#            _dypts.append((_vy + _rad))
#        if self._throughAngle(180.0):
#            _dxpts.append((_vx - _rad))
#        if self._throughAngle(270.0):
#            _dypts.append((_vy - _rad))
#        _xmin = min(_dx, min(_dxpts))
#        _ymin = min(_dy, min(_dypts))
#        _xmax = max(_dx, max(_dxpts))
#        _ymax = max(_dy, max(_dypts))
#        return _xmin, _ymin, _xmax, _ymax
#
#    def clone(self):
#        _vp = self.__vp
#        _p1 = self.__p1
#        _p2 = self.__p2
#        _x, _y = self.getLocation()
#        _ds = self.getDimStyle()
#        _adim = AngularDimension(_vp, _p1, _p2, _x, _y, _ds)
#        _adim.copyDimValues(self)
#        return _adim
#
#    def __movePoint(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 2:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if ((p is not self.__vp) and
#            (p is not self.__p1) and
#            (p is not self.__p2)):
#            raise ValueError, "Unexpected dimension point: " + `p`
#        _dxmin, _dymin, _dxmax, _dymax = self.getBounds()
#        self.calcDimValues()
#        self.sendMessage('moved', _dxmin, _dymin, _dxmax, _dymax)
#
#    def __pointChangePending(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved':
#            self.startChange('moved')
#
#    def __pointChangeComplete(self, p, *args):
#        _alen = len(args)
#        if _alen &lt; 1:
#            raise ValueError, "Invalid argument count: %d" % _alen
#        if args[0] == 'moved':
#            self.endChange('moved')
#
#    def sendsMessage(self, m):
#        if m in AngularDimension.__messages:
#            return True
#        return super(AngularDimension, self).sendsMessage(m)
#
</t>
<t tx="1.20130426141258.3231">import math

from Kernel.GeoEntity.geometricalentity     import *
from Kernel.GeoEntity.point                 import Point
from Kernel.GeoUtil.util                    import *
</t>
<t tx="1.20130426141258.3232">class Dimension(GeometricalEntity):
    """
        Dimension class object.
    """
    @others
</t>
<t tx="1.20130426141258.3233">def __init__(self,kw):
    """
        Initialize a Segment object.
        kw['DIMENSION_1'] first point
        kw['DIMENSION_2'] second point (se dimension 1 == dimesion 2 it means that the 
                            dimension is angular
        kw['DIMENSION_3'] third poin
        kw['DIMENSION_4'] angle 0 horizontal pi/2 vertical        
    """
    dimDescription={
                    "DIMENSION_1":Point,
                    "DIMENSION_2":Point, 
                    "DIMENSION_3":Point,
                    "DIMENSION_4":(float, int), 
                    }
    GeometricalEntity.__init__(self,kw, dimDescription)
</t>
<t tx="1.20130426141258.3234">def __str__(self):
    return "Dimension : (%g)" % (self.distance)
</t>
<t tx="1.20130426141258.3235">@property
def info(self):
    return "Dimension : (%g)" % (self.distance)
</t>
<t tx="1.20130426141258.3236">@property
def isAngularDimension(self):
    """
        tells if the dimension is an angular one
    """
    if self.distance&lt;0.000001:
        return True
    else:
        return False
</t>
<t tx="1.20130426141258.3237">@property
def distance(self):
    """
        calculate the distance between the located point
    """
    return self.firstPoint.dist(self.secondPoint)
</t>
<t tx="1.20130426141258.3238">@property
def firstPoint(self):
    return self['DIMENSION_1']
</t>
<t tx="1.20130426141258.3239">@property
def secondPoint(self):
    return self['DIMENSION_2']
</t>
<t tx="1.20130426141258.3240">@property
def thirdPoint(self):
    return self['DIMENSION_3']
</t>
<t tx="1.20130426141258.3241">@property
def angle(self):
    return self['DIMENSION_4']
</t>
<t tx="1.20130426141258.3242">def getConstructionElements(self):
    """
        Get the construction element of entity..
    """
    return {
            "DIMENSION_1":self.firstPoint,
            "DIMENSION_2":self.secondPoint, 
            "DIMENSION_3":self.thirdPoint,
            "DIMENSION_4":self.angle, 
            }
</t>
<t tx="1.20130426141258.3243">def setConstructionElements(self, p1, p2, p3, angle):
    """
        Set the construction element of entity..
    """
    self['DIMENSION_1']=p1
    self['DIMENSION_2']=p2
    self['DIMENSION_3']=p3
    self['DIMENSION_4']=angle
</t>
<t tx="1.20130426141258.3244">def clone(self):
    """
        Create an identical copy of a Point.
    """
    return Dimension(self._point1, self._point2, self._point3,self._angle )
</t>
<t tx="1.20130426141258.3245">def getSympy(self):
    """
        get the sympy object
    """
    return None
</t>
<t tx="1.20130426141258.3246">def move(self,fromPoint, toPoint): #TODO : Test It
    """
        perform the move operation
    """
    self._point1.move(fromPoint, toPoint)
    self._point2.move(fromPoint, toPoint)
    self._point3.move(fromPoint, toPoint)
</t>
<t tx="1.20130426141258.3247">def rotate(self, rotationPoint, angle): #TODO : Test It
    """
        this method must be defined for rotation
    """
    self._point1.rotate(rotationPoint, angle)
    self._point2.rotate(rotationPoint, angle)
    self._point3.rotate(rotationPoint, angle)
    self._angle=self._angle+angle
</t>
<t tx="1.20130426141258.3248">def mirror(self, mirrorRef): #TODO : Test It
    """
        perform the mirror of the line
    """
    self._point1.mirror(mirrorRef)
    self._point2.mirror(mirrorRef)
    self._point3.mirror(mirrorRef)
    self._angle=self._angle+math.pi/2.0
</t>
<t tx="1.20130426141258.3249">#
# Copyright (c) 2003, 2004, 2005, 2006 Art Haas
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# class stuff for ellipses
#
# Ellipse info:
# http://mathworld.wolfram.com/Ellipse.html
# http://astronomy.swin.edu.au/~pbourke/geometry/ellipsecirc/
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3250">import math


from Kernel.GeoUtil.tolerance              import *
from Kernel.GeoUtil.util                   import *
from Kernel.GeoEntity.point                import Point
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoEntity.cline                import CLine
from Kernel.GeoEntity.geometricalentity    import *
</t>
<t tx="1.20130426141258.3251">class Ellipse(GeometricalEntity):
    """
        A base class for Ellipses
        An ellipse has the following attributes:
        center: A _point object
        horizontalRadius_axis:
        verticalRadius_axis:
    """
    @others
</t>
<t tx="1.20130426141258.3252">def __init__(self,kw):
    """
        Initialize a Arc/Circle.
        kw['ELLIPSE_0'] center must be a point 
        kw['ELLIPSE_1'] hradius ax
        kw['ELLIPSE_2'] vradius ax
    """
    argDescription={
                    "ELLIPSE_0":Point,
                    "ELLIPSE_1":(float, int), 
                    "ELLIPSE_2":(float, int)
                    }
    _horizontalRadius=kw['ELLIPSE_1']
    _verticalRadius=kw['ELLIPSE_2']
    #if _verticalRadius &gt; _horizontalRadius:
    #    kw['ELLIPSE_2']=get_float(_horizontalRadius)
    #    kw['ELLIPSE_1']=get_float(_verticalRadius)
    GeometricalEntity.__init__(self,kw, argDescription)
</t>
<t tx="1.20130426141258.3253">@property
def info(self):
    return "Ellipse: Center: %s, horizontalRadius: %s, verticalRadius:%s "%(str(self.center), str(self.horizontalRadius), str(self.verticalRadius))        
</t>
<t tx="1.20130426141258.3254">def __eq__(self, obj):
    """
        Compare one ellipse to another for equality.
    """
    if not isinstance(obj, Ellipse):
        return False
    if obj is self:
        return True
    return (self.center == obj.getCenter() and
            abs(self.horizontalRadius - obj.gethorizontalRadiusAxis()) &lt; 1e-10 and
            abs(self.verticalRadius - obj.getverticalRadiusAxis()) &lt; 1e-10 
            )
</t>
<t tx="1.20130426141258.3255">def __ne__(self, obj):
    """
        Compare one ellipse to another for equality.
    """
    return not self==object
</t>
<t tx="1.20130426141258.3256">def getCenter(self):
    """
        Return the center _Point of the Ellipse.
    """
    return self['ELLIPSE_0']
</t>
<t tx="1.20130426141258.3257">def setCenter(self, point):
    """
        Set the center _Point of the Ellipse.
        The argument must be a _Point or a tuple containing
        two float values.
    """
    self['ELLIPSE_0'] = point
</t>
<t tx="1.20130426141258.3258">center = property(getCenter, setCenter, None, "Ellipse center")

def gethorizontalRadiusAxis(self):
    """
        Return the horizontalRadius axis value of the Ellipse.
        This method returns a float.
    """
    return self['ELLIPSE_1']
</t>
<t tx="1.20130426141258.3259">def sethorizontalRadiusAxis(self, val):
    """
        Set the horizontalRadius axis of the Ellipse.
        Argument 'val' must be a float value greater than 0.
    """
    _val = get_float(val)
    if _val &lt; 0.0:
        raise ValueError("Invalid horizontalRadius axis value: %g" % _val)
    if _val &lt; self.verticalRadius:
        self.self['ELLIPSE_1']=self.verticalRadius
        self.verticalRadius=_val
    else:
        self['ELLIPSE_1']=_val
</t>
<t tx="1.20130426141258.3260">horizontalRadius= property(gethorizontalRadiusAxis, sethorizontalRadiusAxis, None,
                      "Ellipse horizontalRadius axis")

def getverticalRadiusAxis(self):
    """
        Return the verticalRadius axis value of the Ellipse.
        This method returns a float.
    """
    return self['ELLIPSE_2']
</t>
<t tx="1.20130426141258.3261">def setverticalRadiusAxis(self, val):
    """
        Set the verticalRadius axis of the Ellipse.
        Argument 'val' must be a float value greater than 0.
    """
    _val = get_float(val)
    if _val &lt; 0.0:
        raise ValueError("Invalid verticalRadius axis value: %g" % _val)
    if _val &gt; self.horizontalRadius:
        self['ELLIPSE_2']=self.horizontalRadius
        self.horizontalRadius=_val
    else:
        self['ELLIPSE_2']=_val
</t>
<t tx="1.20130426141258.3262">verticalRadius = property(getverticalRadiusAxis, setverticalRadiusAxis, None,
                      "Ellipse verticalRadius axis")


def eccentricity(self):
    """
        Return the eccecntricity of the Ellipse.
        This method returns a float value.
    """
    _horizontalRadius = self.horizontalRadius
    _verticalRadius = self.verticalRadius
    if abs(_horizontalRadius - _verticalRadius) &lt; 1e-10: # circular
        _e = 0.0
    else:
        _e = math.sqrt(1.0 - ((_verticalRadius * _verticalRadius)/(_horizontalRadius * _horizontalRadius)))
    return _e
</t>
<t tx="1.20130426141258.3263">def area(self):
    """
        Return the area of the Ellipse.
        This method returns a float value.
    """
    return math.pi * self.horizontalRadius * self.verticalRadius
</t>
<t tx="1.20130426141258.3264">def circumference(self):
    """
        Return the circumference of an ellipse.
        This method returns a float.
        The algorithm below is taken from
        http://astronomy.swin.edu.au/~pbourke/geometry/ellipsecirc/
        Ramanujan, Second Approximation
    """
    _a = self.horizontalRadius
    _b = self.verticalRadius
    _h = math.pow((_a - _b), 2)/math.pow((_a + _b), 2)
    _3h = 3.0 * _h
    return math.pi * (_a + _b) * (1.0 + _3h/(10.0 + math.sqrt(4.0 - _3h)))
</t>
<t tx="1.20130426141258.3265">#
# measure r from focus
#
# x = c + r*cos(theta)
# y = r*sin(theta)
#
# c = sqrt(a^2 - b^2)
#
# r = a*(1-e)/(1 + e*cos(theta))

def clone(self):
    """
        Make a copy of an Ellipse.
        This method returns a new Ellipse object
    """
    return Ellipse(self.getConstructionElements())
</t>
<t tx="1.20130426141258.3266">def getSympy(self):
    """
        get the sympy object in this case a ellipse
    """
    _cp=self.center.getSympy()
    return geoSympy.Ellipse(_cp,mainSympy.Rational(str(self.horizontalRadius*.5)),mainSympy.Rational(str(self.verticalRadius*.5)))
</t>
<t tx="1.20130426141258.3267">def setFromSympy(self, sympyEllipse):    
    """
        update the points cord from a sympyobject only avaiable for circle
    """
    self.center.setFromSympy(sympyEllipse.center)
    self.horizontalRadius=float(sympyEllipse.hradius )
    self.verticalRadius=float(sympyEllipse.vradius )
</t>
<t tx="1.20130426141258.3268">def __str__(self):
    msg="Ellipse: Center %s , horizontalRadius Axi=%s, Mino Axi=%s"%(
        str(self.center), str(self.horizontalRadius), str(self.verticalRadius))
    return msg
</t>
<t tx="1.20130426141258.3269">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    self.center.mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3270">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide some utility  for the entity 
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3271">import math

import sympy            as mainSympy
import sympy.geometry   as geoSympy

from Kernel.GeoEntity.point        import Point
from Kernel.GeoEntity.segment      import Segment
from Kernel.GeoEntity.arc          import Arc
from Kernel.GeoEntity.ellipse      import Ellipse
</t>
<t tx="1.20130426141258.3272">#    "Ray",
#    "Line",
#    "Triangle",
#    "RegularPolygon",
#    "Polygon",
#    "Curve"
    
def getEntityEntity(sympyEntity):
    """
        convert sympy object into PyCAD object
    """
    if isinstance(sympyEntity, geoSympy.Circle):
        arg={"ARC_0":Point(0.0, 0.0), 
             "ARC_1":1, 
             "ARC_2":None, 
             "ARC_3":None
             }    
        arc=Arc(arg)
        arc.setFromSympy(sympyEntity)
        return arc
    elif isinstance(sympyEntity, geoSympy.Point):
        p=Point(0.0, 0.0)
        p.setFromSympy(sympyEntity)
        return p
    elif isinstance(sympyEntity, geoSympy.Segment):
        segArg={"SEGMENT_0":Point(0.0, 0.0), "SEGMENT_1":Point(1.0, 1.0)}
        seg=Segment(segArg)
        seg.setFromSympy(sympyEntity)
        return seg
    elif isinstance(sympyEntity, geoSympy.Ellipse):
        arg={"ELLIPSE_0":Point(0.0, 0.0), "ELLIPSE_1":1.0, "ELLIPSE_2":2.0}
        e=Ellipse(arg)
        e.setFromSympy(sympyEntity)
        return e
    else:
        raise "not supported entity"
</t>
<t tx="1.20130426141258.3273">#
# Copyright (c) 2010 - 2013 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This is the base class for all the geometrical entitys
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3274">import math

import sympy            as mainSympy
import sympy.geometry   as geoSympy
</t>
<t tx="1.20130426141258.3275">class GeometricalEntity(dict):
    """
        This class provide the basic interface for all the geometrical entitys
    """
    @others
</t>
<t tx="1.20130426141258.3276">def __init__(self, kw, argNameType):
    """
        argv name must be created before init the base class
    """
    if kw is None and argNameType is None:
        return
    if len(kw)!=len(argNameType):
        raise TypeError("Wrong number of items ")
    for k in kw:
        if k in argNameType:
            if isinstance(kw[k],argNameType[k]):
                self[k]=kw[k]
            else:
                raise TypeError("Wrong Type for argument %s"%str(k))
        else:
            raise TypeError("Wrong argument %s "%str(k))
    self.arguments=argNameType
    self._properties={}
</t>
<t tx="1.20130426141258.3277">def updateSnapPoint(self, force=None, fromPoint=None, fromEnt=None):
    pass
</t>
<t tx="1.20130426141258.3278">def getUpdatedSnapPoints(self, force, fromPoint=None,  fromEnt=None):
    """
        update the snappoint with force argument and return an array of geopoint
    """
    self.updateSnapPoint(force, fromPoint, fromEnt)
    return self.snapPoints
</t>
<t tx="1.20130426141258.3279">@property
def snapPoints(self):
    """
        return the snap points
    """
    return self._snapPoints
</t>
<t tx="1.20130426141258.3280">@snapPoints.setter
def snapPoints(self, value):
    self._snapPoints=value
</t>
<t tx="1.20130426141258.3281">def getArgumentsName(self):
    """
        get the construction arguments Name
    """
    return self.arguments
</t>
<t tx="1.20130426141258.3282">def getConstructionElements(self):
    """
        Get the construction element of entity..
    """
    return self
</t>
<t tx="1.20130426141258.3283">def setConstructionElements(self, kw):
    """
        set the construction elemtnts
    """
    self=kw
</t>
<t tx="1.20130426141258.3284">def move(self, fromPoint, toPoint):
    """
        this method must be defined for moving operation
    """
    from Kernel.GeoUtil.geolib import Vector
    from Kernel.GeoEntity.point import Point
    v=Vector(fromPoint, toPoint)
    for key in self:
        if isinstance(self[key] , Point):
            self[key]+=v.point
    return v.point
</t>
<t tx="1.20130426141258.3285">def rotate(self, rotationPoint, angle):
    """
        this method must be defined for rotation
    """
    from Kernel.GeoUtil.geolib import Vector
    from Kernel.GeoEntity.point import Point
    
    for key in self:
        if isinstance(self[key] , Point):
            v=Vector(rotationPoint,self[key] )
            v.rotate(angle)
            self[key]=rotationPoint+v.point
</t>
<t tx="1.20130426141258.3286">def getSympy(self):
    """
        get the sympy object
    """
    pass
</t>
<t tx="1.20130426141258.3287">def setFromSympy(self, sympyPoint):    
    """
        update the points cord from a sympyobject
    """
    pass   
</t>
<t tx="1.20130426141258.3288">class GeometricalEntityComposed(dict):
    """
        this class provide the basic object for composed entity 
        like dimension labels ...
    """
    @others
</t>
<t tx="1.20130426141258.3289">def __init__(self, kw, argNameType):
    if kw is None and argNameType is None:
        return
    if len(kw)!=len(argNameType):
        raise TypeError("Wrong number of items ")
    for k in kw:
        if k in argNameType:
            newTest=argNameType[k]
            if isinstance(argNameType[k], tuple):
                if None in argNameType[k]:
                    if kw[k] == None:
                        self[k]=kw[k]
                        continue
                    else:
                        newTest=tuple([x for x in argNameType[k] if x!=None])
            if isinstance(kw[k],newTest):
                self[k]=kw[k]
            else:
                raise TypeError("Wrong Type for argument %s"%str(k))
        else:
            raise TypeError("Wrong argument %s "%str(k))
    self.arguments=argNameType
</t>
<t tx="1.20130426141258.3290">def getArgumentsName(self):
    """
        get the construction arguments Name
    """
    return self.arguments
</t>
<t tx="1.20130426141258.3291">def getConstructionElements(self):
    """
        Get the construction element of ..
        This must return a tuple of object better if there are point
    """
    pass
</t>
<t tx="1.20130426141258.3292">def getReletedComponent(self):
    """
        Get The releted object to be updated
    """
    pass
</t>
<t tx="1.20130426141258.3293">#
# Copyright (c) 2002, 2003, 2004, 2005 Art Haas
# Copyright (c) 2010,2011 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# hatching code
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__ == '__main__':
    hatchtests()
</t>
<t tx="1.20130426141258.3294">import math

from Kernel.GeoEntity.point                import Point
from Kernel.GeoEntity.segment import Segment
from Kernel.GeoEntity.ccircle import CCircle as Circle
from Kernel.GeoEntity.arc import Arc
#from Kernel.GeoEntity.hatch import Segjoint
from Kernel.layer import Layer
from Kernel.GeoUtil import *
from Kernel.GeoEntity.geometricalentity    import *
</t>
<t tx="1.20130426141258.3295">class Path(GeometricalEntity):
    """
        The class for maintaining a list of objects defining a hatch border.
        A Path object contains one or more objects defining the boundary
        of a hatching. If the Path length is 1, the boundary is either a
        circle or an arc where the start angle and end angle are equal.
        There is no upper limit to the number of objects in the path.
        If a Path consists of Segments, Arcs, Chamfer, or Fillets, the
        Path can only be valid if starting at any point in any object
        in the Path the connections between the objects lead back to the
        starting point.
    """
    @others
</t>
<t tx="1.20130426141258.3296">def __init__(self, objs):
    """
        Initialize a Path.
        The required argument 'objs' is a list of objects defining
        the path. The valid objects are circles, arcs, segments,
        chamfers and fillets.
    """
    if not isinstance(objs, list):
        raise TypeError("Unexpected list type: " + repr(type(objs)))
    if not len(objs):
        raise ValueError("Invalid empty object list")
    if len(objs) == 1:
        _circular = True
        _obj = objs[0]
        if isinstance(_obj, arc.Arc):
            _sa = _obj.getStartAngle()
            _ea = _obj.getEndAngle()
            if not abs(_sa - _ea) &lt; 1e-10:
                raise ValueError("Invalid single Arc path: " + str(_obj))
        elif isinstance(_obj, circle.Circle):
            self.__objs = objs[:]
            return
        else:
            raise TypeError("Invalid single entity path: " + str(_obj))
    for _obj in objs:
        if not (isinstance(_obj, segment.Segment) or
                isinstance(_obj, arc.Arc) or
                isistance(_obj, segjoint.Chamfer) or
                isinstance(_obj, segjoint.Fillet)):
            raise TypeError("Invalid object type in list: " + repr(type(_obj)))
    if pathIsClosed(objs):
        self.__objs = objs[:]
    else:
        raise ValueError("Array List mast be a closef path")
</t>
<t tx="1.20130426141258.3297">def __len__(self):
    return len(self.__objs)
</t>
<t tx="1.20130426141258.3298">def __str__(self):
    print("Element Path are: [")
    for _obj in self.__objs:
        print(str(_obj))
    print("]")
</t>
<t tx="1.20130426141258.3299">def isCircular(self):
    """
        Test if the Path is a Circle or closed Arc.
    """
    if len(self.__objs)==1:
        if isistance(self.__objs,(arc.Arc,circle.Circle)):
            return True
    return False
</t>
<t tx="1.20130426141258.3300">def getPath(self):
    """
        Return the objects defining the Path.
        This method returns a list of objects.
    """
    return self.__objs[:]
</t>
<t tx="1.20130426141258.3301">def inPath(self, x, y):
    """
        Test if a coordinate pair are inside a Path.
        This method has two required arguments:
        This method returns True if the Point is inside the
        Path, and False otherwise.
    """
    _x = util.get_float(x)
    _y = util.get_float(y)
    _inside = False
    if self.__circular:
        assert len(self.__objs) == 1, "Invalid circular path length"
        _circ = self.__objs[0]
        _cx, _cy = _circ.getCenter().getCoords()
        _sep = math.hypot((_cx - _x), (_cy - _y))
        if _sep &lt; _circ.getRadius():
            _inside = True
    else:
        _xp = 0.0
        _yp = 0.0
        _idx = None
        for _i in range(len(self.__objs)):
            _obj = self.__objs[_i]
            if isinstance(_obj, segment.Segment):
                _p1, _p2 = _obj.getEndpoints()
                _p1x, _p1y = _p1.getCoords()
                _p2x, _p2y = _p2.getCoords()
            elif isinstance(_obj, arc.Arc):
                _ep1, _ep2 = _obj.getEndpoints()
                _p1x, _p1y = _ep1
                _p2x, _p2y = _ep2
            elif isinstance(_obj, (segjoint.Chamfer, segjoint.Fillet)):
                _p1, _p2 = _obj.getMovingPoints()
                _p1x, _p1y = _p1.getCoords()
                _p2x, _p2y = _p2.getCoords()
            _xdiff = _p2x - _p1x
            _ydiff = _p2y - _p1y
            _sqlen = pow(_xdiff, 2) + pow(_ydiff, 2)
            _r = ((_x - _p1x)*(_xdiff) + (_y - _p1y)*(_ydiff))/_sqlen
            if 0.0 &lt; _r &lt; 1.0:
                _s = ((_p1y - _y)*(_xdiff) - (_p1x - _x)*(_ydiff))/_sqlen
                if abs(_s) &gt; 1e-10:
                    _xp = _p1x + (_r * _xdiff)
                    _yp = _p1y + (_r * _ydiff)
                    _idx = _i
                    break
        if _idx is not None:
            _count = 1
            for _i in range(len(self.__objs)):
                if _i == _idx:
                    continue
                _obj = self.__objs[_i]
                if isinstance(_obj, segment.Segment):
                    _p1, _p2 = _obj.getEndpoints()
                    _p1x, _p1y = _p1.getCoords()
                    _p2x, _p2y = _p2.getCoords()
                elif isinstance(_obj, arc.Arc):
                    _ep1, _ep2 = _obj.getEndpoints()
                    _p1x, _p1y = _ep1
                    _p2x, _p2y = _ep2
                elif isinstance(_obj, (segjoint.Chamfer, segjoint.Fillet)):
                    _p1, _p2 = _obj.getMovingPoints()
                    _p1x, _p1y = _p1.getCoords()
                    _p2x, _p2y = _p2.getCoords()
                _d = ((_p2x - _p1x)*(_yp - _y)) - ((_p2y - _p1y)*(_xp - _x))
                if abs(_d) &gt; 1e-10:
                    _n = ((_p1y - _y)*(_xp - _x)) - ((_p1x - _x)*(_yp - _y))
                    _r = _n/_d
                    if 0.0 &lt; _r &lt; 1.0:
                        _count = _count + 1
            if _count % 2: # need to test if point is in an arc ...
                _inside = True
    return _inside
</t>
<t tx="1.20130426141258.3302">class HatchRegion(object):
    """The class defining a hatched area.

A HatchRegion object consists of one Path object defining
the external boundary of the hatching, and a list of zero
or more Paths defining any areas inside the enclosing Path
that are not hatched.
    """
    @others
</t>
<t tx="1.20130426141258.3303">def __init__(self, extpath, voids=[]):
    """
        Initialize a HatchRegion.
        The required argument 'extpath' is a Path object defining
        the external boundary of the hatching. The optional argument
        'voids' is a list of Path objects defining areas within the
        external Path that are not to be hatched.
    """
    if not isinstance(extpath, Path):
        raise TypeError("Invalid external path: " + repr(extpath))
    if not extpath.isExternal():
        raise ValueError("Path not defined to be an external path: " + repr(extpath))
    if not isinstance(voids, list):
        raise TypeError("Invalid void list: " + repr(voids))
    for _void in voids:
        if not isinstance(_void, Path):
            raise TypeError("Invalid path in void list: " + repr(_void))
        if _void.isExternal():
            raise ValueError("Void area defined as external: " + repr(_void))
    self.__ext_path = extpath
    self.__voids = voids[:]
</t>
<t tx="1.20130426141258.3304">def getExternalPath(self):
    """
        Return the external Path for the HatchRegion.
    """
    return self.__ext_path
</t>
<t tx="1.20130426141258.3305">def hasVoids(self):
    """
        Test if the HatchRegion has any internal non-hatched areas.
    """
    return len(self.__voids) &gt; 0
</t>
<t tx="1.20130426141258.3306">def getVoids(self):
    """
        Get any internal areas in the HatchRegion.
    """
    return self.__voids[:]
</t>
<t tx="1.20130426141258.3307">def _seg_seg_touch(sega, segb):
    _touch = False
    _pa1, _pa2 = sega.getEndpoints()
    _pb1, _pb2 = segb.getEndpoints()
    if _pa1 is _pb1 or _pa1 is _pb2 or _pa2 is _pb1 or _pa2 is _pb2:
        _touch = True
    return _touch
</t>
<t tx="1.20130426141258.3308">def _seg_arc_touch(seg, a):
    _touch = False
    _p1, _p2 = seg.getEndpoints()
    _ep1, _ep2 = a.getEndpoints()
    if _p1 == _ep1 or _p1 == _ep2 or _p2 == _ep1 or _p2 == _ep2:
        _touch = True
    return _touch
</t>
<t tx="1.20130426141258.3309">def _arc_arc_touch(arca, arcb):
    _touch = False
    _aep1, _aep2 = arca.getEndpoints()
    _bep1, _bep2 = arcb.getEndpoints()
    if _aep1 == _bep1 or _aep1 == _bep2 or _aep2 == _bep1 or _aep2 == _bep2:
        _touch = True
    return _touch
</t>
<t tx="1.20130426141258.3310">def _seg_joint_touch(seg, joint):
    _touch = False
    _s1, _s2 = joint.getSegments()
    if _s1 is seg or _s2 is seg:
        _touch = True
    return _touch
</t>
<t tx="1.20130426141258.3311">def _old_validate_path(objlist):
    """
        Test if the objects in the objlist make a closed path.
        This function is private the the hatching code.
    """
    if not isinstance(objlist, list):
        raise TypeError("Invalid object list: " + repr(objlist))
    _startpt = None
    _nextpt = None
    _valid = False
    for _obj in objlist:
        print("testing object: " + repr(_obj))
        print("start: " + repr(_startpt))
        print("next: " + repr(_nextpt))
        if isinstance(_obj, segment.Segment):
            _p1, _p2 = _obj.getEndpoints()
            if _startpt is None:
                _startpt = _p1
                _nextpt = _p2
            else:
                if _nextpt == _p1:
                    _nextpt = _p2
                elif _nextpt == _p2:
                    _nextpt = _p1
                else:
                    break
        elif isinstance(_obj, arc.Arc):
            _ep1, _ep2 = _obj.getEndpoints()
            if _startpt is None:
                _startpt = _ep1
                _nextpt = _ep2
            else:
                if _nextpt == _ep1:
                    _nextpt = _ep2
                elif _startpt == _ep2:
                    _nextpt = _ep1
                else:
                    break
        elif isinstance(_obj, (segjoint.Chamfer, segjoint.Fillet)):
            _p1, _p2 = _obj.getMovingPoints()
            if _startpt is None:
                _startpt = _p1
                _nextpt = _p2
            else:
                if _nextpt == _p1:
                    _nextpt = _p2
                elif _nextpt == _p2:
                    _nextpt = _p1
                else:
                    break
        else:
            raise TypeError("Invalid object in path: " + repr(_obj))
    if _startpt == _nextpt:
        _valid = True
    return _valid
</t>
<t tx="1.20130426141258.3312">def _can_touch(obja, objb):
    _touch = False
    if isinstance(obja, segment.Segment):
        if isinstance(objb, segment.Segment):
            _touch = _seg_seg_touch(obja, objb)
        elif isinstance(objb, arc.Arc):
            _touch = _seg_arc_touch(obja, objb)
        elif isinstance(objb, segjoint.SegJoint):
            _touch = _seg_joint_touch(obja, objb)
    elif isinstance(obja, arc.Arc):
        if isinstance(objb, segment.Segment):
            _touch = _seg_arc_touch(objb, obja)
        elif isinstance(objb, arc.Arc):
            _touch = _arc_arc_touch(obja, objb)
    elif isinstance(obja, segjoint.SegJoint):
        if isinstance(objb, segment.Segment):
            _touch = _seg_joint_touch(objb, obja)
    return _touch
</t>
<t tx="1.20130426141258.3313">def _validate_path(lyr, objlist):
    """
        Test if the objects in the objlist make a closed path.
        This function is private the the hatching code.
    """
    if not isinstance(objlist, list):
        raise TypeError("Invalid object list: " + repr(objlist))
    for _obj in objlist:
        _lobj = lyr.findObject(_obj)
        if _lobj is not _obj:
            raise ValueError("Object not in layer: " + repr(_obj))
    _valid = True
    for _i in range(len(objlist) - 1):
        _obja = objlist[_i]
        _objb = objlist[_i+1]
        if not _can_touch(_obja, _objb):
            _valid = False
            break
    if _valid:
        _valid = _can_touch(objlist[0], objlist[-1])
    return _valid
</t>
<t tx="1.20130426141258.3314">def point_boundaries(plist):
    _xmin = None
    _xmax = None
    _ymin = None
    _ymax = None
    _set = False
    if len(plist) &gt; 1:
        for _pt in plist:
            _x, _y = _pt.getCoords()
            if not _set:
                _xmin = _x
                _xmax = _x
                _ymin = _y
                _ymax = _y
            else:
                if _x &lt; _xmin:
                    _xmin = _x
                if _x &gt; _xmax:
                    _xmax = _x
                if _y &lt; _ymin:
                    _ymin = _y
                if _y &gt; _ymax:
                    _ymax = _y
    return (_xmin, _ymin, _xmax, _ymax)
</t>
<t tx="1.20130426141258.3315">def point_in_path(path):
    hits = 0
    for seg in path:
        p1, p2 = seg.getEndpoints()
        p1x, p1y = p1.getEndpoints()
        p2x, p2y = p2.getEndpoints()
        xmin = min(p1x, p2x)
        xmax = max(p1x, p2x)
        ymin = min(p1y, p2y)
        ymax = max(p1y, p2y)
        # if hx &lt; xmin or hx &gt; max or hy &gt; ymax:
            # continue
        hits = 1 - hits
    return hits
</t>
<t tx="1.20130426141258.3316">def draw_path(path):
    if len(path):
        print("path: [")
        for seg in path:
            print(seg)
        print("]")
</t>
<t tx="1.20130426141258.3317">def make_paths(pt, seg, sdict):
    paths = []
    print("initial segment: " + str(seg))
    sp1, sp2 = seg.getEndpoints()
    if pt is sp1:
        sp = sp1
    else:
        sp = sp2
    print("start point: " + str(sp))
    segkeys = {}
    path = []
    segkeys[seg] = pt
    path.append(seg)
    draw_path(path)
    paths.append(path)
    while(len(paths)):
        path = paths.pop()
        draw_path(path)
        seg = path[-1]
        print("path final segment: " + str(seg))
        # print "segkey: " + str(segkeys[seg])
        p1, p2 = seg.getEndpoints()
        print("p1: " + str(p1))
        if p1 in sdict and segkeys[seg] is not p1:
            if p1 is sp:
                print("complete path:")
                draw_path(path)
            else:
                for p1seg in sdict[p1]:
                    if p1seg not in path:
                        segkeys[p1seg] = p1
                        path.append(p1seg)
                        # print "new path:"
                        draw_path(path)
                        paths.append(path)
        print("p2: " + str(p2))
        if p2 in sdict and segkeys[seg] is not p2:
            if p2 is sp:
                print("complete path:")
                draw_path(path)
            else:
                for p2seg in sdict[p2]:
                    if p2seg not in path:
                        segkeys[p2seg] = p2
                        path.append(p2seg)
                        # print "new_path:"
                        draw_path(path)
                        paths.append(path)
</t>
<t tx="1.20130426141258.3318">def check_clist(ct, clist):
    xct, yct = ct.getCenter().getCoords()
    rct = ct.getRadius()
    add_flag = True
    i = 0
    while (i &lt; len(clist)):
        _c = clist[i]
        x, y = _c.getCenter().getCoords()
        r = _c.getRadius()
        sep = math.hypot((xct - x), (yct - y))
        if sep &lt; r: # ct center point inside _c
            if sep + rct &lt; r:
                add_flag = False
            else:
                i = i + 1
        elif sep &lt; rct: # _c center point inside ct
            if sep + r &lt; rct:
                del clist[i]
            else:
                i = i + 1
        else: # two circle that may or may not overlap
            i = i + 1
        if not add_flag:
            break
    return add_flag
</t>
<t tx="1.20130426141258.3319">def get_contained_circles(l, c):
    clist = []
    xc, yc = c.getCenter().getCoords()
    rc = c.getRadius()
    for _cir in l.getLayerEntities("circle"):
        if _cir is c:
            continue
        x, y = _cir.getCenter().getCoords()
        r = _cir.getCoords()
        sep = math.hypot((xc - x), (yc - y))
        if sep + r &lt; rc:
            if(check_clist(_cir, clist)):
                clist.append(_cir)
    return clist
</t>
<t tx="1.20130426141258.3320">def make_hatch_area(lyr, x, y):
    _x = util.get_float(x)
    _y = util.get_float(y)
    if not isinstance(lyr, layer.Layer):
        raise TypeError("Invalid layer: " + repr(lyr))
    #
    # see if we're in a circle
    #
    _circle = None
    for _c in lyr.getLayerEntities("circle"):
        _xc, _yc = _c.getCenter().getCoords()
        _r = _c.getRadius()
        _sep = math.hypot((_xc - _x), (_yc - _y))
        if _sep &lt; _r:
            if _circle is None:
                _circle = _c
            else:
                _rc = _circle.getRadius()
                if _r &lt; _rc:
                    _circle = _c
    #
    # get the eligible points in the layer and
    # store any circles that may be fully inside
    # the bounding circle
    #
    _pts = {}
    _circle_voids = []
    if _circle is not None:
        _cx, _cy = _circle.getCenter().getCoords()
        _rad = _circle.getRadius()
        _xmin = _cx - _rad
        _ymin = _cy - _rad
        _xmax = _cx + _rad
        _ymax = _cy + _rad
        for _pt in lyr.getLayerEntities("point"):
            _x, _y = _pt.getCoords()
            if _x &lt; _xmin or _y &lt; _ymin or _y &gt; _ymax:
                continue
            if _x &gt; _xmax:
                break
            _sep = math.hypot((_cx - _x), (_cy - _y))
            if _sep &lt; _rad:
                _addpt = True
                if lyr.countUsers(_pt) == 1:
                    _obj = lyr.usesObject(_pt)
                    if not isinstance(_obj, circle.Circle):
                        _addpt = False
                if _addpt:
                    _pts[_pt] = True
        for _circ in lyr.getLayerEntities("circle"):
            if _circ is _circle:
                continue
            _tcx, _tcy = _circ.getCenter().getCoords()
            _tr = _circ.getRadius()
            if (_tcx + _tr) &gt; _xmax:
                break
            if ((_tcx - _tr) &lt; _xmin or
                (_tcy - _tr) &lt; _ymin or
                (_tcy + _tr) &gt; _ymax):
                continue
            _sepmax = math.hypot((_cx - _tcx), (_cy - _tcy)) + _tr
            if _sepmax &lt; _rad:
                _circle_voids.append(_circ)
    else:
        for _pt in lyr.getLayerEntities("point"):
            _addpt = True
            if lyr.countUsers(_pt) == 1:
                _obj = lyr.usesObject(_pt)
                if not isinstance(_obj, circle.Circle):
                    _addpt = False
            if _addpt:
                _pts[_pt] = True
    #
    # find the entites that can make closed paths
    #
    _objs = {}
    for _pt in _pts:
        for _user in lyr.usesObject(_pt):
            if isinstance(_user, (segment.Segment, arc.Arc,
                                  segjoint.Chamfer, segjoint.Fillet)):
                _objs[_user] = True
                if isinstance(_user, segment.Segment):
                    for _seguser in lyr.usesObject(_user):
                        _objs[_seguser] = True
    _paths = {}
    for _obj in _objs:
        _p1 = None
        _p2 = None
        if isinstance(_obj, segment.Segment):
            if _obj not in _paths:
                _paths[_obj] = []
            for _user in lyr.usesObject(_obj):
                if isinstance(_user, (segjoint.Chamfer, segjoint.Fillet)):
                    _paths[_obj].append(_user)
            _p1, _p2 = _obj.getEndpoints()
        elif isinstance(_obj, arc.Arc):
            _ep1, _ep2 = _obj.getEndpoints()
            for _pt in _pts:
                if _pt == _ep1:
                    _p1 = _pt
                elif _p2 == _ep2:
                    _p2 = _pt
                if _p1 is not None and _p2 is not None:
                    break
            if _p1 is None or _p2 is None:
                continue # only one arc endpoint in list
        else:
            _s1, _s2 = _obj.getSegments()
            if _obj not in _paths:
                _paths[_obj] = []
            _paths[_obj].append(_s1)
            _paths[_obj].append(_s2)
        if _p1 is not None:
            for _user in lyr.usesObject(_p1):
                if _user is not _obj:
                    if isinstance(_user, (segment.Segment, arc.Arc)):
                        _paths[_obj].append(_user)
        if _p2 is not None:
            for _user in lyr.usesObject(_p2):
                if _user is not _obj:
                    if isinstance(_user, (segment.Segment, arc.Arc)):
                        _paths[_obj].append(_user)
    #
    # remove any object that doesn't connect to another object
    #
    _objlist = list(_paths.keys())
    for _obj in _objlist:
        if len(_paths[_obj]) &lt; 1:
            del _paths[_obj]
    #
    # try to make paths from the selected objects
    #
    _routes = {}
    _objlist = list(_paths.keys())
    _objcount = len(_objlist)
    for _obj in _objlist:
        _objpaths = []
        _path = [_obj]
        for _fullpath in _make_paths(_paths, _objcount, _obj, _path):
            print("path: " + str(_fullpath))
            _valid = _validate_path(lyr, _fullpath)
            if _valid:
                _objpaths.append(_fullpath)
            else:
                print("invalid path")
        _routes[_obj] = _objpaths
</t>
<t tx="1.20130426141258.3321">def _make_paths(pathdict, maxlen, tail, path):
    _paths = []
    _pathlen = len(path)
    _head = None
    if _pathlen &lt;= maxlen and tail in pathdict:
        if _pathlen:
            _head = path[0]
        for _next in pathdict[tail]:
            if _next is _head:
                _good = True
                if _pathlen == 2:
                    if (isinstance(path[0], segment.Segment) and
                        isinstance(path[1], segment.Segment)):
                        _good = False
                if _good:
                    _paths.append(path)
            elif _next not in path:
                _path = path + [_next]
                for _newpath in _make_paths(pathdict, maxlen, _next, _path):
                    _paths.append(_newpath)
            else:
                pass
    return _paths
</t>
<t tx="1.20130426141258.3322">hpx = 3.0
hpy = 4.0

def hatchtests():
    p1 = point.Point(0,0)
    p2 = point.Point(10,0)
    p3 = point.Point(10,10)
    p4 = point.Point(0,10)
    s1 = segment.Segment(p1,p2)
    s2 = segment.Segment(p2,p3)
    s3 = segment.Segment(p3,p4)
    s4 = segment.Segment(p4,p1)
    l1 = layer.Layer('foo')
    l1.addObject(p1)
    l1.addObject(p2)
    l1.addObject(p3)
    l1.addObject(p4)
    l1.addObject(s1)
    l1.addObject(s2)
    l1.addObject(s3)
    l1.addObject(s4)
    # find_hatched_area(l1, hpx, hpy)
    p5 = point.Point(2.95, 3.95)
    l1.addObject(p5)
    c1 = circle.Circle(p5, 1)
    l1.addObject(c1)
    # find_hatched_area(l1, hpx, hpy)
</t>
<t tx="1.20130426141258.3323">#
# Copyright (c) 2003 Art Haas
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# NURBS curves




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3324">import array
from Kernel.GeoEntity.geometricalentity  import *
</t>
<t tx="1.20130426141258.3325">class Nurb(GeometricalEntity):
    @others
</t>
<t tx="1.20130426141258.3326">def __init__(self, ctrlpts, knots, order):
    if not isinstance(ctrlpts, list):
        raise TypeError("Invalid control point list: " + str(ctrlpts))
    if not isinstance(knots, list):
        raise TypeError("Invalid knot list: " + str(knots))
    if not isinstance(order, int):
        raise TypeError("Invalid order; " + str(order))
    if order &lt; 2 or order &gt; 16: # what is a good max value?
        raise ValueError("Invalid order: %d" % order)
    _ctrlpts = []
    for _pt in ctrlpts:
        if not isinstance(_pt, tuple):
            raise TypeError("Invalid control point: " + str(_pt))
        _len = len(_pt)
        if not (1 &lt; _len &lt; 4):
            raise ValueError("Invalid tuple length: " + str(_pt))
        if _len == 2:
            _x, _y = _pt
            _w = 1.0
        else:
            _x, _y, _w = _pt
        if not isinstance(_x, float):
            _x = float(_x)
        if not isinstance(_y, float):
            _y = float(_y)
        if not isinstance(_w, float):
            _w = float(_w)
        if not (_w &gt; 0.0):
            raise ValueError("Invalid weight: %g" % _w)
        _ctrlpts.append((_x, _y, _w))
    _knots = []
    for _knot in knots:
        if not isinstance(_knot, float):
            _knot = float(_knot)
        if (_knot &lt; 0.0 or _knot &gt; 1.0):
            raise ValueError("Invalid knot value: %g" % _knot)
        for _val in _knots:
            if _knot &lt; (_val - 1e-10):
                raise ValueError
        _knots.append(_knot)
    print("knots: " + str(_knots))
    print("ctrl: " + str(_ctrlpts))
    print("order: %d" % order)
    _clen = len(_ctrlpts)
    if _clen &lt; order:
        raise ValueError("Order greater than number of control points.")
    if len(_knots) != (_clen + order):
        raise ValueError("Knot/Control Point/Order number error.")
    self.__ctrlpts = _ctrlpts
    self.__knots = _knots
    self.__order = order
</t>
<t tx="1.20130426141258.3327">def getControlPoints(self):
    return self.__ctrlpts[:]
</t>
<t tx="1.20130426141258.3328">def getKnots(self):
    return self.__knots[:]
</t>
<t tx="1.20130426141258.3329">def getOrder(self):
    return self.__order
</t>
<t tx="1.20130426141258.3330">def calculate(self, count):
    if not isinstance(count, int):
        raise TypeError("Invalid count: " + str(count))
    _cpts = self.__ctrlpts
    _knots = self.__knots
    _dt = 1.0/float(count)
    _p = self.__order - 1
    _pts = []
    for _c in range(count):
        _t = _c * _dt
        # print "time: %g" % _t
        _nx = _ny = _nw = 0.0
        for _i in range(len(_cpts)):
            # print "using cpt %d" % _i
            _x, _y, _w = _cpts[_i]
            _Ni = self._N(_i, _p, _t)
            _nx = _nx + (_Ni * _x)
            _ny = _ny + (_Ni * _y)
            _nw = _nw + (_Ni * _w)
        # print "nw: %.3f" % _nw
        # print "nx: %.3f" % _nx
        # print "ny: %.3f" % _ny
        if abs(_nw) &gt; 1e-10:
            _pts.append((_nx/_nw, _ny/_nw))
        else:
            print("zero weight: %f, %f" % (_nx, _ny))

    return _pts
</t>
<t tx="1.20130426141258.3331">def _N(self, i, p, t):
    # print "_N() ..."
    _flag = False
    if abs(t - 1.0) &lt; 1e-10 and False:
        _flag = True
    if _flag:
        print("i: %d" % i)
        print("p: %d" % p)
        print("t: %.3f" % t)
    _knots = self.__knots
    _ki = _knots[i]
    _kin = _knots[i + 1]
    if _flag:
        print("ki: %.3f" % _ki)
        print("kin: %.3f" % _kin)
    if p == 0:
        if ((_ki - 1e-10) &lt; t &lt; _kin):
            _val = 1.0
        else:
            _val = 0.0
    else:
        _kip = _knots[i + p]
        _kipn = _knots[i + p + 1]
        if _flag:
            print("kip: %.3f" % _kip)
            print("kipn: %.3f" % _kipn)
        _t1 = 0.0
        _v1 = _kip - _ki
        if abs(_v1) &gt; 1e-10:
            _v2 = t - _ki
            if abs(_v2) &gt; 1e-10:
                _t1 = (_v2/_v1) * self._N(i, (p - 1), t)
        _t2 = 0.0
        _v1 = _kipn - _kin
        if abs(_v1) &gt; 1e-10:
            _v2 = _kipn - t
            if abs(_v2) &gt; 1e-10:
                _t2 = (_v2/_v1) * self._N((i + 1), (p - 1), t)
        _val = _t1 + _t2
    if _flag:
        print("val: %f" % _val)
    return _val
</t>
<t tx="1.20130426141258.3332">def writedata(self, count, fname):
    if not isinstance(count, int):
        raise TypeError("Invalid count: " + str(count))
    _f = file(fname, "w")
    for _pt in self.calculate(count):
        _x, _y = _pt
        _f.write("%f %f\n" % (_x, _y))
    _f.close()
    _f = file('control_points', "w")
    for _pt in self.getControlPoints():
        _x, _y, _w = _pt # ignore weight
        _f.write("%f %f\n" % (_x, _y))
    _f.close()
    _f = file('knots', "w")
    for _knot in self.getKnots():
        _f.write("%f 0.0\n" % _knot)
    _f.close()
</t>
<t tx="1.20130426141258.3333">def _NN(self, i, p, t):
    _cpts = self.__ctrlpts
    _cl = len(_cpts)
    _knots = self.__knots
    _kl = len(_knots) - 1
    _val = _kl * [0.0]
    #
    # calculate values for 0
    #
    for _i in range(_kl):
        if ((_knots[i] - 1e-10) &lt; t &lt; _knots[i + 1]):
            _val[_i] = 1.0
    #
    # calculate values up to the degree
    #
    for _j in range(1, (p + 1)):
        for _i in range(_kl - _j):
            _ki = _knots[_i]
            _kin = _knots[_i + 1]
            _kip = _knots[_i + p]
            _kipn = _knots[_i + p + 1]
            _t1 = 0.0
            _n = _val[_i]
            if abs(_n) &gt; 1e-10:
                _v1 = _kip - _ki
                if abs(_v1) &gt; 1e-10:
                    _v2 = t - _ki
                    if abs(_v2) &gt; 1e-10:
                        _t1 = (_v2/_v1) * _n
            _t2 = 0.0
            _n = _val[_i + 1]
            if abs(_n) &gt; 1e-10:
                _v1 = _kipn - _kin
                if abs(_v1) &gt; 1e-10:
                    _v2 = _kipn - t
                    if abs(_v2) &gt; 1e-10:
                        _t2 = (_v2/_v1) * _n
            _val[_i] = _t1 + _t2
</t>
<t tx="1.20130426141258.3334">#
# Copyright (c) 2002, 2003, 2004, 2005 Art Haas
# Copyright (c) 2009,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# classes for points
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3335">import math

from Kernel.GeoEntity.geometricalentity  import *
from Kernel.GeoUtil.util                 import *
</t>
<t tx="1.20130426141258.3336">class Point(GeometricalEntity):
    """
        A 2-D point Class.
    """
    @others
</t>
<t tx="1.20130426141258.3337">def __init__(self, x, y=None):
    """
        Initialize a Point.
        There are Tree ways to initialize a Point:
        Point(xc,yc) - Two arguments, with both arguments being floats
        Point((xc,yc)) - A single tuple containing two float objects
        Point(Point) - A single Point Object
    """
    GeometricalEntity.__init__(self, None, None)
    if isinstance(x, tuple):
        if y is not None:
            raise SyntaxError("Invalid call to Point()")
        _x, _y = tuple_to_two_floats(x)
    elif y is not None:
        _x = float(x)
        _y = float(y)
    elif isinstance(x,Point):
        _x,_y=x.getCoords()
    else:
        #print "Debug : x[%s] y[%s]"%(str(x),str(y))
        #print "Debug : type x %s"%str(type(x))
        raise SyntaxError("Invalid call to Point().")
    self.__x = _x
    self.__y = _y
</t>
<t tx="1.20130426141258.3338">def getPoint(self):
    return self
</t>
<t tx="1.20130426141258.3339">def __str__(self):
    return "Point : (%g,%g)" % (self.__x, self.__y)
</t>
<t tx="1.20130426141258.3340">@property
def info(self):
    return "Point : (%g,%g)" % (self.__x, self.__y)
</t>
<t tx="1.20130426141258.3341">def __sub__(self, p):
    """
        Return the separation between two points.
        This function permits the use of '-' to be an easy to read
        way to find the distance between two Point objects.
    """
    if not isinstance(p, Point):
        raise TypeError("Invalid type for Point subtraction: " + repr(type(p)))
    _px, _py = p.getCoords()
    return math.hypot((self.__x - _px), (self.__y - _py))
</t>
<t tx="1.20130426141258.3342">def __eq__(self, obj):
    """
        Compare a Point to either another Point or a tuple for equality.
    """
    if not isinstance(obj, (Point,tuple)):
        return False
    if isinstance(obj, Point):
        if obj is self:
            return True
        _x, _y = obj.getCoords()
    else:
        _x, _y = tuple_to_two_floats(obj)
    if abs(self.__x - _x) &lt; 1e-10 and abs(self.__y - _y) &lt; 1e-10:
        return True
    return False
</t>
<t tx="1.20130426141258.3343">def __ne__(self, obj):
    """
        Compare a Point to either another Point or a tuple for inequality.
    """
    if not isinstance(obj, (Point, tuple)):
        return True
    if isinstance(obj, Point):
        if obj is self:
            return False
        _x, _y = obj.getCoords()
    else:
        _x, _y = tuple_to_two_floats(obj)
    if abs(self.__x - _x) &lt; 1e-10 and abs(self.__y - _y) &lt; 1e-10:
        return False
    return True
</t>
<t tx="1.20130426141258.3344">def __add__(self,obj):
    """
        Add two Point
    """
    if not isinstance(obj, Point):
        if isinstance(obj, tuple):
            x, y = tuple_to_two_floats(obj)
        else:
            raise TypeError("Invalid Argument obj: Point or tuple Required")
    else:
        x,y = obj.getCoords()
    return Point(self.__x+x, self.__y+y)
</t>
<t tx="1.20130426141258.3345">def getConstructionElements(self):
    """
        Get the construction element of entity..
    """
    return {"POINT_0":self.__x, "POINT_1":self.__y}
</t>
<t tx="1.20130426141258.3346">def setConstructionElements(self, p1, p2):
    """
        Set the construction element of entity..
    """
    self__x=p1
    self__y=p2
</t>
<t tx="1.20130426141258.3347">def getx(self):
    """
        Return the x-coordinate of a Point.
        getx()
    """
    return self.__x
</t>
<t tx="1.20130426141258.3348">def setx(self, val):
    """
        Set the x-coordinate of a Point
        setx(val)
        The argument 'val' must be a float.
    """
    _v = get_float(val)
    _x = self.__x
    if abs(_x - _v) &gt; 1e-10:
        self.__x = _v
</t>
<t tx="1.20130426141258.3349">x = property(getx, setx, None, "x-coordinate value")

def gety(self):
    """
        Return the y-coordinate of a Point.
    """
    return self.__y
</t>
<t tx="1.20130426141258.3350">def sety(self, val):
    """
        Set the y-coordinate of a Point
        The argument 'val' must be a float.
    """
    _v = get_float(val)
    _y = self.__y
    if abs(_y - _v) &gt; 1e-10:
        self.__y = _v
</t>
<t tx="1.20130426141258.3351">y = property(gety, sety, None, "y-coordinate value")

def getCoords(self):
    """
        Return the x and y Point coordinates in a tuple.
    """
    return self.__x, self.__y
</t>
<t tx="1.20130426141258.3352">def setCoords(self, x, y):
    """
        Set both the coordinates of a Point.
        Arguments 'x' and 'y' should be float values.
    """
    _x = get_float(x)
    _y = get_float(y)
    _sx = self.__x
    _sy = self.__y
    if abs(_sx - _x) &gt; 1e-10 or abs(_sy - _y) &gt; 1e-10:
        self.__x = _x
        self.__y = _y
</t>
<t tx="1.20130426141258.3353">def clone(self):
    """
        Create an identical copy of a Point.
    """
    return Point(self.__x, self.__y)
</t>
<t tx="1.20130426141258.3354">def inRegion(self, xmin, ymin, xmax, ymax, fully=True):
    """
        Returns True if the Point is within the bounding values.
        inRegion(xmin, ymin, xmax, ymax)
        The four arguments define the boundary of an area, and the
        function returns True if the Point lies within that area.
        Otherwise, the function returns False.
    """
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    test_boolean(fully)
    _x = self.__x
    _y = self.__y
    return not ((_x &lt; _xmin) or
                (_x &gt; _xmax) or
                (_y &lt; _ymin) or
                (_y &gt; _ymax))
</t>
<t tx="1.20130426141258.3355">def dist(self,obj):
    """
       Get The Distance From 2 Points
    """
    if not isinstance(obj, Point):
        if isinstance(obj, tuple):
            _x, _y = tuple_to_two_floats(obj)
        else:
            raise TypeError("Invalid Argument point: Point or Tuple Required")
    else:
        x,y=obj.getCoords()
    xDist=x-self.__x
    yDist=y-self.__y
    return math.sqrt(pow(xDist,2)+pow(yDist,2))
</t>
<t tx="1.20130426141258.3356">def getSympy(self):
    """
        get the sympy object
    """
    return geoSympy.Point(mainSympy.Rational(str(self.__x)), mainSympy.Rational(str(self.__y)))
</t>
<t tx="1.20130426141258.3357">def setFromSympy(self, sympyPoint):
    """
        update the points cord from a sympyobject
    """
    # Yen modified from sympyPoint[0] to .x and [1] to .y
    self.__x=float(sympyPoint.x)
    self.__y=float(sympyPoint.y)
</t>
<t tx="1.20130426141258.3358">def move(self,fromPoint, toPoint):
    """
        perform the move operation
    """
    from Kernel.GeoUtil.geolib  import Vector
    v=Vector(fromPoint, toPoint)
    p=self+v.point
    self.__x=p.x
    self.__y=p.y
</t>
<t tx="1.20130426141258.3359">def rotate(self, rotationPoint, angle):
    """
        this method must be defined for rotation
    """
    from Kernel.GeoUtil.geolib import Vector
    from Kernel.GeoEntity.point import Point
    v=Vector(rotationPoint,self)
    v.rotate(angle)
    p=rotationPoint+v.point    
    self.__x=p.x
    self.__y=p.y
</t>
<t tx="1.20130426141258.3360">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    from Kernel.GeoEntity.cline              import CLine
    from Kernel.GeoEntity.segment            import Segment
    from Kernel.GeoUtil.geolib               import Vector
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    centerMirror=mirrorRef.getProjection(self)
    vCenter=Vector(self, centerMirror )
    p=centerMirror+vCenter.point
    self.__x, self.__y=p.getCoords()
</t>
<t tx="1.20130426141258.3361">#
# Copyright (c) 2003, 2004, 2005, 2006 Art Haas
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# classes for polyline objects
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3362">import math

from Kernel.GeoUtil.tolerance              import *
from Kernel.GeoEntity.point                import Point
from Kernel.GeoEntity.segment              import Segment
from Kernel.GeoEntity.cline                import CLine
from Kernel.GeoEntity.geometricalentity    import *
</t>
<t tx="1.20130426141258.3363">class Polyline(GeometricalEntity):
    """
        A class representing a polyline. A polyline is essentially
        a number of segments that connect end to end.
    """
    @others
</t>
<t tx="1.20130426141258.3364">def __init__(self,kw):
    """
        Initialize a Polyline object.
        kw['POLYLINE_0'] must be a point
        kw['POLYLINE_..'] must be a point
        kw['POLYLINE_..n'] must be a point
    """
    if len(kw)&lt;2:
        raise ValueError("Invalid number of imput value ")
    argDescription=dict([(key,Point) for key in kw])
    GeometricalEntity.__init__(self,kw, argDescription)
</t>
<t tx="1.20130426141258.3365">#def __len__(self):
#    return len(self.points)

def __str__(self):
    return "Polyline"
</t>
<t tx="1.20130426141258.3366">@property
def info(self):
    return "Polyline"
</t>
<t tx="1.20130426141258.3367">def __eq__(self, obj):
    """
        Compare two Polyline objects for equality.
    """
    if not isinstance(obj, Polyline):
        return False
    if obj is self:
        return True
    _val = False
    _ppts = obj.points
    _pcount = len(_ppts)
    _spts = self.points
    _scount = len(_spts)
    if _pcount == _scount:
        _val = True
        for _i in range(_scount):
            if _ppts[_i] != _spts[_i]:
                _val = False
                break
        if not _val: # check reversed point list of second polyline
            _val = True
            _ppts.reverse()
            for _i in range(_scount):
                if _ppts[_i] != _spts[_i]:
                    _val = False
                    break
    return _val
</t>
<t tx="1.20130426141258.3368">def __ne__(self, obj):
    """
        Compare two Polyline objects for inequality.
    """
    if not isinstance(obj, Polyline):
        return True
    if obj is self:
        return False
    _val = True
    _ppts = obj.getPoints()
    _pcount = len(_ppts)
    _spts = self.points
    _scount = len(_spts)
    if _pcount == _scount:
        _val = False
        for _i in range(_scount):
            if _ppts[_i] != _spts[_i]:
                _val = True
                break
        if _val: # check reversed point list of second polyline
            _val = False
            _ppts.reverse()
            for _i in range(_scount):
                if _ppts[_i] != _spts[_i]:
                    _val = True
                    break
    return _val
</t>
<t tx="1.20130426141258.3369">def getPoints(self):
    """
        Get the points of the Polyline.
        This function returns a list containing all the Point
        objects that define the Polyline.
    """
    return self.getConstructionElements()
</t>
<t tx="1.20130426141258.3370">def addPoint(self, name, point):
    """
        Add a Point to the Polyline.
        The argument 'i' must be an integer, and argument 'p' must be a
        Point. The Point is added into the list of points comprising
        the Polyline as the i'th point.
    """
    if not isinstance(point, Point):
        raise TypeError("Invalid Point for Polyline point: " + repr(type(point)))
    self[name]=point
</t>
<t tx="1.20130426141258.3371">def delPoint(self, name):
    """
        Remove a Point from the Polyline.
        The argument i represents the index of the point to remove from
        the list of points defining the Polyline. The point will be
        removed only if the polyline will still have at least two Points.
    """

    if len(self) &gt; 2:
        del self[name]
</t>
<t tx="1.20130426141258.3372">def getBounds(self):
    """
        Return the bounding rectangle around a Polyline.
        This method returns a tuple of four values:
        (xmin, ymin, xmax, ymax)
    """
    _pts = self.points
    _pxmin = None
    _pymin = None
    _pxmax = None
    _pymax = None
    for _pt in _pts:
        _px, _py = _pt.getCoords()
        if _pxmin is None or _px &lt; _pxmin:
            _pxmin = _px
        if _pymin is None or _py &lt; _pymin:
            _pymin = _py
        if _pxmax is None or _px &gt; _pxmax:
            _pxmax = _px
        if _pymax is None or _py &gt; _pymax:
            _pymax = _py
    return _pxmin, _pymin, _pxmax, _pymax
</t>
<t tx="1.20130426141258.3373">def points(self):
    """
        return a list of point
    """
    exit=[]
    kk=list(self.keys())
    kk.sort()
    for k in kk:
        exit.append(self[k])
    return exit
</t>
<t tx="1.20130426141258.3374">def clone(self):
    """
        Create an identical copy of a Polyline.
    """
    _cpts = {}
    i=0
    for _pt in self.points:
        name="POLYLINE_%s"%str(i)
        _cpts[name]=_pt.clone()
        i+=1
    return Polyline(_cpts)
</t>
<t tx="1.20130426141258.3375">def getSympySegments(self):
    """
        return an array of sympy Segment
    """
    out=[]

    for s in self.getSegments():
        out.append(s.getSympy())
    return out
</t>
<t tx="1.20130426141258.3376">def getSegments(self):
    """
        return an array of segments that identifie the polyline
        used for intersection porpouse
    """
    tempPoint=None
    exitArray=[]
    for p in self.points():
        if tempPoint:
            constr={"SEGMENT_0":tempPoint, "SEGMENT_1":p}
            exitArray.append(Segment(constr))
        tempPoint=p
    else:
        return exitArray
    return []
</t>
<t tx="1.20130426141258.3377">def mirror(self, mirrorRef):
    """
        perform the mirror
    """
    for k in self:
        self[k].mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3378">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
# Copyright (c) 2009,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# classes for line segments
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3379">import math

from Kernel.GeoUtil.util                    import *
from Kernel.GeoUtil.geolib                  import Vector
from Kernel.GeoEntity.point                 import Point
from Kernel.GeoEntity.cline                 import CLine
from Kernel.GeoEntity.geometricalentity     import *
</t>
<t tx="1.20130426141258.3380">class Segment(GeometricalEntity):
    """
        A class representing a line segment.
    """
    @others
</t>
<t tx="1.20130426141258.3381">def __init__(self,kw):
    """
        Initialize a Segment object.
        kw['SEGMENT_0'] must be a point 
        kw['SEGMENT_1'] must be a point 
    """
    argDescription={
                    "SEGMENT_0":Point,
                    "SEGMENT_1":Point
                    }
    GeometricalEntity.__init__(self,kw, argDescription)
    if self.p1.dist(self.p2)&lt;0.000001:
        print("distance =0", self)
        #raise StructuralError("Wrong point imput distance between point mast be &gt;0.000001") 
</t>
<t tx="1.20130426141258.3382">def __str__(self):
    return "Segment: %s to %s l=%s" % (self.p1, self.p2, self.length)
</t>
<t tx="1.20130426141258.3383">@property
def info(self):
    return "Segment: %s to %s l=%s" % (self.p1, self.p2, self.length)    
</t>
<t tx="1.20130426141258.3384">def __eq__(self, obj):
    """
        Compare a Segment to another for equality.
    """
    if not isinstance(obj, Segment):
        return False
    if obj is self:
        return True
    _sp1 = self.p1
    _sp2 = self.p2
    _op1, _op2 = obj.getEndpoints()
    return (((_sp1 == _op1) and (_sp2 == _op2)) or
            ((_sp1 == _op2) and (_sp2 == _op1)))
</t>
<t tx="1.20130426141258.3385">def __ne__(self, obj):
    """
        Compare a Segment to another for inequality.
    """
    if not isinstance(obj, Segment):
        return True
    if obj is self:
        return False
    _sp1 = self.p1
    _sp2 = self.p2
    _op1, _op2 = obj.getEndpoints()
    return (((_sp1 != _op1) or (_sp2 != _op2)) and
            ((_sp1 != _op2) or (_sp2 != _op1)))
</t>
<t tx="1.20130426141258.3386">def getEndpoints(self):
    """
        Get the endpoints of the Segment.
        This function returns a tuple containing the two Point objects
        that are the endpoints of the segment.
    """
    return self.p1, self.p2
</t>
<t tx="1.20130426141258.3387">def getKeypoints(self):
    """
        wrapper function for CLine compatibility
    """
    return self.getEndpoints()
</t>
<t tx="1.20130426141258.3388">def getP1(self):
    """
        Return the first endpoint Point of the Segment.
    """
    return self["SEGMENT_0"]
</t>
<t tx="1.20130426141258.3389">def setP1(self, p):
    """
        Set the first endpoint Point of the Segment.
    """
    if not isinstance(p, Point):
        raise TypeError("Invalid P1 endpoint type: " + repr(type(p)))
    if p is self.p2:
        raise ValueError("Segments cannot have identical endpoints.")
    _pt = self.p1
    if _pt is not p:
        self["SEGMENT_0"] = p
    self.updateSnapPoint()
</t>
<t tx="1.20130426141258.3390">p1 = property(getP1, setP1, None, "First endpoint of the Segment.")

def getP2(self):
    """
        Return the second endpoint Point of the Segment.
    """
    return self["SEGMENT_1"]
</t>
<t tx="1.20130426141258.3391">def setP2(self, p):
    """
        Set the second endpoint Point of the Segment.
    """
    if not isinstance(p, Point):
        raise TypeError("Invalid P2 endpoint type: " + repr(type(p)))
    if p is self.p1:
        raise ValueError("Segments cannot have identical endpoints.")
    _pt = self.p2
    if _pt is not p:
        self["SEGMENT_1"] = p
    self.updateSnapPoint()
</t>
<t tx="1.20130426141258.3392">p2 = property(getP2, setP2, None, "Second endpoint of the Segment.")

@property
def length(self):
    """
        Return the length of the Segment.
    """
    return self.p1 - self.p2
</t>
<t tx="1.20130426141258.3393">def getCoefficients(self):
    """
        Express the line segment as a function ax + by + c = 0
        This method returns a tuple of three floats: (a, b, c)
    """
    _x1, _y1 = self.p1.getCoords()
    _x2, _y2 = self.p2.getCoords()
    _a = _y2 - _y1
    _b = _x1 - _x2
    _c = (_x2 * _y1) - (_x1 * _y2)
    return _a, _b, _c
</t>
<t tx="1.20130426141258.3394">def getMiddlePoint(self):
    """
        Return the middle point of the segment
    """
    _p1,_p2=self.getEndpoints()
    _x1=get_float(_p1.x)
    _x2=get_float(_p2.x)
    _y1=get_float(_p1.y)
    _y2=get_float(_p2.y)
    _deltax=abs(_x1-_x2)/2.0
    _deltay=abs(_y1-_y2)/2.0
    if(_x1&lt;_x2):
        retX=_x1+_deltax
    else:
        retX=_x2+_deltax
    if(_y1&lt;_y2):
        retY=_y1+_deltay
    else:
        retY=_y2+_deltay
    return Point(retX,retY)
    #return Point((_x1+_x2)/2.0,(_y1+_y2)/2.0) &lt;&lt;&lt;&lt;why not like this? it seems to work too
</t>
<t tx="1.20130426141258.3395">def getProjection(self,fromPoint):
    """
        get Projection of the point x,y in the line
    """
    p1=self.p1
    p2=self.p2
    v=Vector(p1,p2)
    v1=Vector(p1,fromPoint)
    pjPoint=v.map(v1.point).point
    return p1+pjPoint
</t>
<t tx="1.20130426141258.3396">def mapCoords(self, x, y, tol=0.001):
    """
        Return the nearest Point on the Segment to a coordinate pair.
        The function has two required arguments:
        x: A Float value giving the 'x' coordinate
        y: A Float value giving the 'y' coordinate
        There is a single optional argument:
        tol: A float value equal or greater than 0.
        This function is used to map a possibly near-by coordinate pair to an
        actual Point on the Segment. If the distance between the actual
        Point and the coordinates used as an argument is less than the tolerance,
        the actual Point is returned. Otherwise, this function returns None.
    """
    _x = get_float(x)
    _y = get_float(y)
    _t = tolerance.toltest(tol)
    _x1, _y1 = self.p1.getCoords()
    _x2, _y2 = self.p2.getCoords()
    return map_coords(_x, _y, _x1, _y1, _x2, _y2, _t)
</t>
<t tx="1.20130426141258.3397">def inRegion(self, xmin, ymin, xmax, ymax, fully=False):
    """
        Return whether or not a Segment exists within a region.
        The four arguments define the boundary of an area, and the
        method returns True if the Segment lies within that area. If
        the optional argument fully is used and is True, then both
        endpoints of the Segment must lie within the boundary.
        Otherwise, the method returns False.
    """
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    test_boolean(fully)
    _x1, _y1 = self.p1.getCoords()
    _x2, _y2 = self.p2.getCoords()
    _pxmin = min(_x1, _x2)
    _pymin = min(_y1, _y2)
    _pxmax = max(_x1, _x2)
    _pymax = max(_y1, _y2)
    if ((_pxmax &lt; _xmin) or
        (_pymax &lt; _ymin) or
        (_pxmin &gt; _xmax) or
        (_pymin &gt; _ymax)):
        return False
    if fully:
        if ((_pxmin &gt; _xmin) and
            (_pymin &gt; _ymin) and
            (_pxmax &lt; _xmax) and
            (_pymax &lt; _ymax)):
            return True
        return False
    return in_region(_x1, _y1, _x2, _y2, _xmin, _ymin, _xmax, _ymax)
</t>
<t tx="1.20130426141258.3398">def clipToRegion(self, xmin, ymin, xmax, ymax):
    """
        Clip the Segment using the Liang-Barsky Algorithm.
    """
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    _x1, _y1 = self.p1.getCoords()
    _x2, _y2 = self.p2.getCoords()
    #
    # simple tests to reject line
    #
    if ((max(_x1, _x2) &lt; _xmin) or
        (max(_y1, _y2) &lt; _ymin) or
        (min(_x1, _x2) &gt; _xmax) or
        (min(_y1, _y2) &gt; _ymax)):
        return None
    #
    # simple tests to accept line
    #
    _coords = None
    if (_xmin &lt; _x1 &lt; _xmax and
        _xmin &lt; _x2 &lt; _xmax and
        _ymin &lt; _y1 &lt; _ymax and
        _ymin &lt; _y2 &lt; _ymax):
        _coords = (_x1, _y1, _x2, _y2)
    else:
        #
        # the Segment can be parameterized as
        #
        # x = u * (x2 - x1) + x1
        # y = u * (y2 - y1) + y1
        #
        # for u = 0, x =&gt; x1, y =&gt; y1
        # for u = 1, x =&gt; x2, y =&gt; y2
        #
        # The following is the Liang-Barsky Algorithm
        # for segment clipping
        #
        _dx = _x2 - _x1
        _dy = _y2 - _y1
        _P = [-_dx, _dx, -_dy, _dy]
        _q = [(_x1 - _xmin), (_xmax - _x1), (_y1 - _ymin), (_ymax - _y1)]
        _u1 = 0.0
        _u2 = 1.0
        _valid = True
        for _i in range(4):
            _pi = _P[_i]
            _qi = _q[_i]
            if abs(_pi) &lt; 1e-10:
                if _qi &lt; 0.0:
                    _valid = False
                    break
            else:
                _r = _qi/_pi
                if _pi &lt; 0.0:
                    if _r &gt; _u2:
                        _valid = False
                        break
                    if _r &gt; _u1:
                        _u1 = _r
                else:
                    if _r &lt; _u1:
                        _valid = False
                        break
                    if _r &lt; _u2:
                        _u2 = _r
        if _valid:
            _coords = (((_u1 * _dx) + _x1),
                       ((_u1 * _dy) + _y1),
                       ((_u2 * _dx) + _x1),
                       ((_u2 * _dy) + _y1))
    return _coords
</t>
<t tx="1.20130426141258.3399">def clone(self):
    """
        Create an identical copy of a Segment.
    """
    _cp1 = self.p1.clone()
    _cp2 = self.p2.clone()
    args={"SEGMENT_0":_cp1, "SEGMENT_1":_cp2}
    return Segment(args)
</t>
<t tx="1.20130426141258.3400">def getSympy(self):
    """
        get the sympy object
    """
    _sp1=self.p1.getSympy()
    _sp2=self.p2.getSympy()
    return geoSympy.Segment(_sp1, _sp2)
</t>
<t tx="1.20130426141258.3401">def getSympyLine(self):    
    """
        Get The simpy line
    """
    _sp1=self.p1.getSympy()
    _sp2=self.p2.getSympy()
    return geoSympy.Line(_sp1, _sp2) 
</t>
<t tx="1.20130426141258.3402">def setFromSympy(self, sympySegment):    
    """
        update the points cord from a sympyobject
    """
    # Yen modified, from [0] to .p1 and [1] to .p2
    #self.p1.setFromSympy(sympySegment[0])
    self.p1.setFromSympy(sympySegment.p1)
    #self.p2.setFromSympy(sympySegment[1])
    self.p2.setFromSympy(sympySegment.p2)
</t>
<t tx="1.20130426141258.3403">@property
def vector(self):
    """
        Get The vector of the Segment
    """
    return Vector(self.p1, self.p2)
</t>
<t tx="1.20130426141258.3404">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    if not isinstance(mirrorRef, (CLine, Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")
    #
    self.p1.mirror(mirrorRef)
    self.p2.mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3405">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This class provide all the style operation for the pythoncadDB
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3406">from Kernel.GeoEntity.geometricalentity       import GeometricalEntity
from Kernel.GeoUtil.util                      import getRandomString
</t>
<t tx="1.20130426141258.3407">class Style(GeometricalEntity):
        """
            This class rappresent the style in pythoncad
            objID is the object that rappresent the id in the db
        """
        def __init__(self,kw):
            """
                kw['STYLE_0'] 
                kw['STYLE_1'] 
            """
            argDescription=dict([(key,str) for key in kw])
            GeometricalEntity.__init__(self,kw, argDescription)
            
            if 'STYLE_1' in self:
                if self['STYLE_1'] ==None:
                    from Kernel.initsetting import getDefaultStyle
                    self.__styleProperty=getDefaultStyle()
            else:
                from Kernel.initsetting import getDefaultStyle
                self['STYLE_1']=getDefaultStyle()
                
            if 'STYLE_0' in self:
                if self['STYLE_0'] ==None:
                    self.name=getRandomString()       
            else:
                self['STYLE_0']=getRandomString()       
        @property
        def name(self):
            """
                get the style name
            """
            return self['STYLE_0']
        @name.setter
        def name(self, name):
            """
                set the name of the style
            """
            self['STYLE_0']=name
       
        
        def getStyleProp(self, name):
            """
                get the style property
            """
            if name in  self['STYLE_1']:
                return  self['STYLE_1'][name]
            else:
                return None
        
        def setStyleProp(self, name, value):
            """
                set the style property 
            """
            from Kernel.initsetting         import PYTHONCAD_STYLE_ATTRIBUTES
            from Kernel.exception           import EntityMissing
            if name in PYTHONCAD_STYLE_ATTRIBUTES:
                self['STYLE_1'][name]=value
            else:
                raise EntityMissing("Unable to find the property %s"%str(name))
        
        def Derived(self):
            self.name=str(self)
            self['STYLE_1']['derived']=str(self.name)
            
        @property 
        def props(self):
            return  self['STYLE_1']
</t>
<t tx="1.20130426141258.3408">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# basic text functionality
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3409">from .geometricalentity      import GeometricalEntity


from Kernel.GeoUtil.util import *
from Kernel.GeoEntity.point import Point
</t>
<t tx="1.20130426141258.3410">#
# Text
#
class Text(GeometricalEntity):
    """
        A class representing text in a drawing.
        A Text instance has the following attributes:
    """
    @others
</t>
<t tx="1.20130426141258.3411">def __init__(self,kw):
    """
        Initialize a Arc/Circle.
        kw['TEXT_0'] position point must be a point 
        kw['TEXT_1'] text must be a valid text
        kw['TEXT_2'] angle must be a valid radiant float value or None
        kw['TEXT_3'] position of the text refered to the position point must be a valid string value or None
    """
    argDescription={
                    "TEXT_0":Point,
                    "TEXT_1":(float, str, str), 
                    "TEXT_2":(float, int), 
                    "TEXT_3":(str, str)
                    }
    
    if kw['TEXT_2']==None:
        kw['TEXT_2'] = 0
    from Kernel.initsetting             import TEXT_POSITION
    if kw['TEXT_3']==None:
        kw['TEXT_3'] = 'sw'
    else:
        if not kw['TEXT_3'] in TEXT_POSITION:
            kw['TEXT_3'] = 'sw'
            #if kw['TEXT_3']=='':
            #    kw['TEXT_3'] = 'sw'
            #else:
            #    raise TypeError, "Argument for TEXT_3 not supported"

    GeometricalEntity.__init__(self,kw, argDescription)
</t>
<t tx="1.20130426141258.3412">def __eq__(self, objTest):
    if isistance(objTest,Text):
        if(self.text== objTest.text and
            self.angle ==objTest.angle and
            self.location==objTest.location and
            self.pointPosition==objTest.pointPosition):
            return True
        else:
            return False
    else:
        raise TypeError("obj must be of type Text")
</t>
<t tx="1.20130426141258.3413">@property
def info(self):
    return "Text: %s"%str(self.location) 
</t>
<t tx="1.20130426141258.3414">@property            
def text(self):
    """
        Get the current text within the Text.
    """
    return self['TEXT_1']
</t>
<t tx="1.20130426141258.3415">@text.setter
def text(self, text):
    """
        Set the text within the Text.
    """
    if not isinstance(text, str):
        raise TypeError("Invalid text data: " + str(text))
    self['TEXT_1'] = text
</t>
<t tx="1.20130426141258.3416">@property
def location(self):
    """
        Return the Text spatial position.
    """
    return self['TEXT_0']
</t>
<t tx="1.20130426141258.3417">@location.setter
def location(self, x, y):
    """
        Store the spatial position of the Text.
    """
    _x = get_float(x)
    _y = get_float(y)
    self['TEXT_0'] = Point(_x, _y)
</t>
<t tx="1.20130426141258.3418">@property
def angle(self):
    """
        Return the angle at which the text is drawn.
    """
    return self['TEXT_2']
</t>
<t tx="1.20130426141258.3419">@angle.setter
def angle(self, angle=None):
    """
        Set the angle at which the text block should be drawn.
    """
    self['TEXT_2']= get_float(angle)
</t>
<t tx="1.20130426141258.3420">@property
def pointPosition(self):
    """
        return the position of the textrefered to the point 
    """
    return self['TEXT_3']
</t>
<t tx="1.20130426141258.3421">@pointPosition.setter
def pointPosition(self, position):
    """
        set the position of the textrefered to the point 
    """
    from Kernel.initsetting             import TEXT_POSITION
    from Kernel.exception               import PythopnCadWarning
    if position in TEXT_POSITION:
        self['TEXT_3']=position
    raise TypeError("bad Point position")    
</t>
<t tx="1.20130426141258.3422">def getLineCount(self):
    """
        Return the number of lines of text in the Text
    """
    #
    # ideally Python itself would provide a linecount() method
    # so the temporary list would not need to be created ...
    #
    return len(self.text.splitlines())
</t>
<t tx="1.20130426141258.3423">def clone(self):
    """
        Return an identical copy of a Text.
    """
    _x, _y = self.getLocation().getCoords()
    _text = self.getText()
    _tb = Text(_x, _y, _text)
    _tb.angle = self.getAngle()
    _tb.pointPosition=self.pointPosition
    return _tb
</t>
<t tx="1.20130426141258.3424">def mirror(self, mirrorRef):
    """
        perform the mirror of the line
    """
    # TODO Look at the qt text implementation to understand better the text 
    # mirror 
    pass
    if not isinstance(mirrorRef, ( Segment)):
        raise TypeError("mirrorObject must be Cline Segment or a tuple of points")

    pl=self.getLocation()
    pl.mirror(mirrorRef)
</t>
<t tx="1.20130426141258.3425">def rotate(self, rotationPoint, angle):
    """
        overloading of the rotate base method 
    """
    GeometricalEntity.rotate(self, rotationPoint, angle)
    self.angle=self.angle-angle
</t>
<t tx="1.20130426141258.3426"></t>
<t tx="1.20130426141258.3427"></t>
<t tx="1.20130426141258.3428">#
# Copyright (c) 2009 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide class to manage geometrical vector operation
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3429">import math

from Kernel.GeoEntity.point  import Point
from Kernel.exception import EntityMissing
</t>
<t tx="1.20130426141258.3430">class Vector:
    """
        Provide a full 2d vector operation and definition
    """
    @others
</t>
<t tx="1.20130426141258.3431">def __init__(self,p1,p2):
    """
        Default Constructor
    """
    if(not isinstance(p1,Point)):
        raise EntityMissing("Invalid Argument p1: Point Required")
    if(not isinstance(p2,Point)):
        raise EntityMissing("Invalid Argument p2: Point Required")
    x,y=p1.getCoords()
    x1,y1=p2.getCoords()
    self.X=x1-x
    self.Y=y1-y
</t>
<t tx="1.20130426141258.3432">def mag(self):
    """
        Get the versor
    """
    _a=self.absAng
    p1=Point(0,0)
    p2=Point(math.cos(_a), math.sin(_a))
    return Vector(p1,p2)
</t>
<t tx="1.20130426141258.3433">@property    
def norm(self):
    """
      Get The Norm Of the vector
    """
    return math.sqrt(pow(self.X,2)+pow(self.Y,2))
</t>
<t tx="1.20130426141258.3434">def __eq__(self,vector):
    """
        the 2 vecror are equal
    """ 
    if(not isinstance(vector,Vector)):
        raise TypeError("Invalid Argument vector: Vector Required")   
    if(self.point==vector.point):
        return True             
    else:
        return False
</t>
<t tx="1.20130426141258.3435">@property
def point(self):
    """
          Return The Point 
    """
    return Point(self.X,self.Y)
</t>
<t tx="1.20130426141258.3436">@property
def x(self):
    """
        return the x value of the vector
    """
    return self.X
</t>
<t tx="1.20130426141258.3437">@property
def y(self):
    """
        return the y value of the vector
    """
    return self.Y
</t>
<t tx="1.20130426141258.3438">def dot(self,vector):
    """
        Compute The Dot Product
    """
    if(not isinstance(vector,Vector)):
        raise TypeError("Invalid Argument vector: Vector Required")  
    v0=self.point.getCoords()
    v1=vector.point.getCoords()
    som=0
    for a, b in zip(v0, v1):
        som+=a*b
    return som  
</t>
<t tx="1.20130426141258.3439">def cross(self,vector):
    """
        Compute The Cross Product
    """
    if(not isinstance(vector,Vector)):
        raise TypeError("Invalid Argument vector: Vector Required")  
    x1,y1=self.point.getCoords()
    x2,y2=vector.point.getCoords()
    cros=x1*y2 - y1*x2
    return cros
</t>
<t tx="1.20130426141258.3440">def ang(self,vector):
    """
        Calculate the angle Between the two vector
    """
    if(not isinstance(vector,Vector)):
        raise TypeError("Invalid Argument vector: Vector Required")  
    vself=self.mag()
    vvector=vector.mag()
    dot=vself.dot(vvector)
    if(dot&lt;-1):
        dot=-1
    if(dot&gt;1):
        dot=1
    ang=math.acos(dot)
    return ang
</t>
<t tx="1.20130426141258.3441">@property    
def absAng(self):
    """
        return the angle from the cartesian reference
    """
    _y=self.point.y
    ang=math.atan2(float(_y),float(self.point.x))
    if _y&lt;0:
        ang=ang+2*math.pi
    return ang
</t>
<t tx="1.20130426141258.3442">def mult(self,scalar):
    """
        Multiplae the vector for a scalar value
    """
    self.X=scalar*self.norm*math.cos(self.absAng)
    self.Y=scalar*self.norm*math.sin(self.absAng)
</t>
<t tx="1.20130426141258.3443">def map(self,pPro):
    """
        Get a vector for the mapping point
    """
    p0=Point(0,0)
    vProj=Vector(p0,pPro)
    ang=self.ang(vProj)
    vProjNorm=vProj.norm
    projectionUnitDistance=vProjNorm*math.cos(ang)
    vSelfMag=self.mag()
    vSelfMag.mult(projectionUnitDistance)
    return vSelfMag    
</t>
<t tx="1.20130426141258.3444">def rotate(self, angle):
    """
        rotate the vector of a given angle
    """
    _a=self.absAng+angle
    _norm=self.norm
    self.X=_norm*math.cos(_a)
    self.Y=_norm*math.sin(_a)
</t>
<t tx="1.20130426141258.3445">def invert(self):
    """
        Invert the vector
    """
    self.rotate(math.pi)
</t>
<t tx="1.20130426141258.3446">def __str__(self):    
    """
        print the vector
    """
    msg="Vector :(%s,%s),Norm: %s"%(self.point.x, self.point.y, self.norm)
    return msg
</t>
<t tx="1.20130426141258.3447">#
# Copyright (c) 2002, 2003, 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code to calculate if or where two objects intersect
#

# from __future__ import division



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3448">import math

from Kernel.GeoEntity.point       import Point
from Kernel.GeoEntity.segment     import Segment
from Kernel.GeoEntity.arc         import Arc
from Kernel.GeoEntity.cline       import CLine
from Kernel.GeoEntity.ccircle     import CCircle
from Kernel.GeoEntity.polyline    import Polyline
from Kernel.GeoEntity.ellipse     import Ellipse
from Kernel.GeoUtil.geolib        import Vector
#
# common constants
#

_dtr = math.pi/180.0
_rtd = 180.0/math.pi

_zero = 0.0 - 1e-10
_one = 1.0 + 1e-10
</t>
<t tx="1.20130426141258.3449">#
# the following functions are used to calculate the
# intersection of two line segments
#
# see comp.graphics.algorithms FAQ for details
#

def denom(p1, p2, p3, p4):
    if not isinstance(p1, Point):
        raise TypeError("Invalid argument to denom(): " + repr(type(p1)))
    if not isinstance(p2, Point):
        raise TypeError("Invalid argument to denom(): " + repr(type(p2)))
    if not isinstance(p3, Point):
        raise TypeError("Invalid argument to denom(): " + repr(type(p3)))
    if not isinstance(p4, Point):
        raise TypeError("Invalid argument to denom(): " + repr(type(p4)))
    _p1x, _p1y = p1.getCoords()
    _p2x, _p2y = p2.getCoords()
    _p3x, _p3y = p3.getCoords()
    _p4x, _p4y = p4.getCoords()
    return ((_p2x - _p1x)*(_p4y - _p3y)) - ((_p2y - _p1y)*(_p4x - _p3x))
</t>
<t tx="1.20130426141258.3450">def rnum(p1, p2, p3, p4):
    if not isinstance(p1, Point):
        raise TypeError("Invalid argument to rnum(): " + repr(type(p1)))
    if not isinstance(p2, Point):
        raise TypeError("Invalid argument to rnum(): " + repr(type(p2)))
    if not isinstance(p3, Point):
        raise TypeError("Invalid argument to rnum(): " + repr(type(p3)))
    if not isinstance(p4, Point):
        raise TypeError("Invalid argument to rnum(): " + repr(type(p4)))
    _p1x, _p1y = p1.getCoords()
    _p2x, _p2y = p2.getCoords()
    _p3x, _p3y = p3.getCoords()
    _p4x, _p4y = p4.getCoords()
    return ((_p1y - _p3y)*(_p4x - _p3x)) - ((_p1x - _p3x)*(_p4y - _p3y))
</t>
<t tx="1.20130426141258.3451">def snum(p1, p2, p3, p4):
    if not isinstance(p1, Point):
        raise TypeError("Invalid argument to snum(): " + repr(type(p1)))
    if not isinstance(p2, Point):
        raise TypeError("Invalid argument to snum(): " + repr(type(p2)))
    if not isinstance(p3, Point):
        raise TypeError("Invalid argument to snum(): " + repr(type(p3)))
    if not isinstance(p4, Point):
        raise TypeError("Invalid argument to snum(): " + repr(type(p4)))
    _p1x, _p1y = p1.getCoords()
    _p2x, _p2y = p2.getCoords()
    _p3x, _p3y = p3.getCoords()
    _p4x, _p4y = p4.getCoords()
    return ((_p1y - _p3y)*(_p2x - _p1x)) - ((_p1x - _p3x)*(_p2y - _p1y))
</t>
<t tx="1.20130426141258.3452">#
# intersection functions
#

def _null_intfunc(ipts, obja, objb):
    print("invoked _null_intfunc()")
    print("obja: " + repr(obja))
    print("objb: " + repr(objb))
</t>
<t tx="1.20130426141258.3453">def _non_intersecting(ipts, obja, objb):
    pass
</t>
<t tx="1.20130426141258.3454">#
# Ellipse intersection function
#
def _sympy_intersection(ipts, obj1, obj2):
    """
        calculate the intersection beteen polyline and segment
    """
    from sympy.geometry import Point as sPoint
    from sympy.geometry import intersection as sIntersection
    sympySegment=obj1.getSympy()
    sympyObj2=obj2.getSympy()
    #print("try intersect ", sympySegment, sympyObj2)
    iObjs=sIntersection(sympySegment, sympyObj2 )
    #print("iObjs", iObjs)
    for p in iObjs:
        if isinstance(p, sPoint):
            #ipts.append((float(p[0]),float(p[1])))
            ipts.append((float(p.x),float(p.y)))
    #print("Intersection",ipts)
</t>
<t tx="1.20130426141258.3455">def _pol_obj_intersection(ipts, pol, obj):
    """
        calculate the intersection beteen polyline and a generic object
    """
    for seg in pol.getSegments():
        tempIpts=[]
        _sympy_intersection(tempIpts,  seg,  obj)
        if len(tempIpts)&gt;0:
            ipts=tempIpts
            break
</t>
<t tx="1.20130426141258.3456">def _pol_pol_intersection(ipts, pol1, pol2):
    """
        found an intersection between polyline and other object
    """
    if isinstance(pol1, Polyline):
        if isinstance(pol2, Polyline):
            for seg1 in pol1.getSegments():
                for seg2 in pol2.getSegments():
                    tempIpts=[]
                    _sympy_intersection(tempIpts,  seg1,  seg2)
                    if len(tempIpts)&gt;0:
                        ipts=tempIpts
                        break
</t>
<t tx="1.20130426141258.3457">def find_intersections(obja, objb):
    """
        Find intersection points
    """
    _ipts=[]
    if isinstance(obja,Polyline) or isinstance(objb,Polyline):
        if isinstance(obja,Polyline) and isinstance(objb,Polyline):
            _pol_pol_intersection(_ipts, obja, objb)
        else:
            if isinstance(objb,Polyline):
                sp=obja
                obja=objb
                objb=sp
            _pol_obj_intersection(_ipts, obja, objb)

    else:
            try:
                _sympy_intersection(_ipts, obja, objb)
            except:
                print("find_intersections: problem with sympy intersection",obja,objb)
    return _ipts
</t>
<t tx="1.20130426141258.3458">def findSegmentExtendedIntersection(obja, objb):
    """
        Extend the segment intersection on a cline intersection
        Return an [(x,y),(x1,y1),...]
    """
    if isinstance(obja, Segment):
        p1, p2=obja.getEndpoints()
        arg={"CLINE_0":p1, "CLINE_1":p2}
        obja=CLine(arg)
    if isinstance(objb, Segment):
        p1, p2=objb.getEndpoints()
        arg={"CLINE_0":p1, "CLINE_1":p2}
        objb=CLine(arg)
    return find_intersections(obja, objb)
</t>
<t tx="1.20130426141258.3459">def findSegmentExtendedIntersectionPoint(obja, objb):
    """
        xtend the segment intersection on a cline intersection
        Return a [Point,Point,..]
    """
    return [Point(x, y) for x, y in findSegmentExtendedIntersection(obja, objb)]
</t>
<t tx="1.20130426141258.3460">#
# Copyright (c) 2006 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
# 
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# code to handle rotating objects
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3461">from math import hypot, fmod, atan2, sin, cos, pi

from Kernel.GeoEntity.util     import *
from Kernel.GeoEntity.point    import Point
from Kernel.GeoEntity.segment  import Segment
from Kernel.GeoEntity.arc      import Arc
from Kernel.GeoEntity.cline    import CLine
from Kernel.GeoEntity.ccircle  import CCircle
from Kernel.GeoEntity.polyline import Polyline


#from PythonCAD.Generic.segjoint import Chamfer, Fillet
#from PythonCAD.Generic.leader import Leader
#from PythonCAD.Generic.text import TextBlock
#from PythonCAD.Generic.dimension import Dimension, DimString
#from PythonCAD.Generic.dimension import LinearDimension
#from PythonCAD.Generic.dimension import AngularDimension


_twopi = (2.0 * pi)
_dtr = (pi/180.0)
</t>
<t tx="1.20130426141258.3462">def _calc_coords(pt, cx, cy, ra):
    _px, _py = pt.getCoords()
    _r = hypot((_px - cx), (_py - cy))
    _aorig = atan2((_py - cy), (_px - cx))
    _anew = fmod((_aorig + ra), _twopi)
    _nx = cx + (_r * cos(_anew))
    _ny = cy + (_r * sin(_anew))
    return (_nx, _ny)
</t>
<t tx="1.20130426141258.3463">def _xfrm_point(pt, objdict, cx, cy, ra):
    _layer = pt.getParent()
    _pid = id(pt)
    _np = None
    _x, _y = _calc_coords(pt, cx, cy, ra)
    if _can_move(pt, objdict) and objdict.get(_pid) is not False:
        pt.setCoords(_x, _y)
    else:
        _pts = _layer.find('point', _x, _y)
        if len(_pts) == 0:
            _np = Point(_x, _y)
            _layer.addObject(_np)
        else:
            _np = _most_used(_pts)
    return _np
</t>
<t tx="1.20130426141258.3464">def _adjust_dimensions(op, np):
    _objs = 0
    _dims = []
    _reset = True
    for _user in op.getUsers():
        if isinstance(_user, Dimension):
            _dims.append(_user)
        else:
            _objs = _objs + 1
            if _objs &gt; 1:
                _reset = False
                break
    if _reset:
        for _dim in _dims:
            if isinstance(_dim, LinearDimension):
                _p1, _p2 = _dim.getDimPoints()
                if _p1 is op:
                    _user.setP1(np)
                elif _p2 is op:
                    _user.setP2(np)
            elif isinstance(_dim, AngularDimension):
                _vp, _p1, _p2 = _dim.getDimPoints()
                if _vp is op:
                    _user.setVertexPoint(np)
                elif _p1 is op:
                    _user.setP1(np)
                elif _p2 is op:
                    _user.setP2(np)
            else:
                raise TypeError("Unknown dimension type: " + repr(type(_dim)))
    return _reset
</t>
<t tx="1.20130426141258.3465">def _most_used(plist):
    _pmax = plist.pop()
    _max = _pmax.countUsers()
    for _pt in plist:
        _count = _pt.countUsers()
        if _count &gt; _max:
            _max = _count
            _pmax = _pt
    return _pmax
</t>
<t tx="1.20130426141258.3466">def _used_by(obj, plist):
    _objpt = None
    for _pt in plist:
        for _user in _pt.getUsers():
            if _user is obj:
                _objpt = _pt
                break
        if _objpt is not None:
            break
    return _objpt
</t>
<t tx="1.20130426141258.3467">def _can_move(obj, objdict):
    raise DeprecatedError("The can move have no more relevance from Version R38")
    for _user in obj.getUsers():
        if id(_user) not in objdict:
            return False
    return True
</t>
<t tx="1.20130426141258.3468">def _rotate_polyline(obj, objdict, cx, cy, ra):
    _pts = obj.getPoints()
    _layer = obj.getParent()
    if _layer is None:
        raise RuntimeError("Polyline parent is None")
    _move = True
    for _pt in _pts:
        if _pt.getParent() is not _layer:
            raise RuntimeError("Polyline/point parent object conflict!")
        _move = (_can_move(_pt, objdict) and
                 (objdict.get(id(_pt)) is not False))
        if not _move:
            break
    if _move:
        for _pt in _pts:
            _x, _y = _calc_coords(_pt, cx, cy, ra)
            _pt.setCoords(_x, _y)
            _pid = id(_pt)
            objdict[_pid] = False
    else:
        for _i in range(len(_pts)):
            _pt = _pts[_i]
            if objdict.get(_pid) is True:
                _x, _y = _calc_coords(_pt, cx, cy, ra)
                _pts = _layer.find('point', _x, _y)
                if len(_pts) == 0:
                    _np = Point(_x, _y)
                    _layer.addObject(_np)
                else:
                    _np = _most_used(_pts)
                obj.setPoint(_i, _np)
                objdict[_pid] = False
                _layer.delObject(_pt)
</t>
<t tx="1.20130426141258.3469">def _rotate_leader(obj, objdict, cx, cy, ra):
    _layer = obj.getParent()
    if _layer is None:
        raise RuntimeError("Leader parent is None")
    _p1, _p2, _p3 = obj.getPoints()    
    if _p1.getParent() is not _layer:
        raise RuntimeError("Leader/P1 parent object conflict!")
    if _p2.getParent() is not _layer:
        raise RuntimeError("Leader/P2 parent object conflict!")
    if _p3.getParent() is not _layer:
        raise RuntimeError("Leader/P3 parent object conflict!")
    _np = _xfrm_point(_p1, objdict, cx, cy, ra)
    if _np is not None:
        obj.setP1(_np)
        if _adjust_dimensions(_p1, _np):
            _layer.delObject(_p1)
    _np = _xfrm_point(_p2, objdict, cx, cy, ra)
    if _np is not None:
        obj.setP2(_np)
        if __adjust_dimensions(_p2, _np):
            _layer.delObject(_p2)
    _np = _xfrm_point(_p3, objdict, cx, cy, ra)
    if _np is not None:
        obj.setP3(_np)
        if __adjust_dimensions(_p3, _np):
            _layer.delObject(_p3)
    _pid = id(_p1)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
    _pid = id(_p2)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
    _pid = id(_p3)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
</t>
<t tx="1.20130426141258.3470">def _adjust_endpoint(arc, pt, objdict, cx, cy, ra):
    _layer = arc.getParent()
    if pt.getParent() is not _layer:
        raise RuntimeError("Arc/Endpoint parent object conflict!")
    _pid = id(pt)
    _users = []
    for _user in pt.getUsers():
        _users.append(_user)
    _np = None
    _x, _y = _calc_coords(pt, cx, cy, ra)    
    if len(_users) == 1 and _users[0] is arc:
        if _can_move(pt, objdict) and objdict.get(_pid) is not False:
            pt.setCoords(_x, _y)
        else:
            _pts = _layer.find('point', _x, _y)
            if len(_pts) == 0:
                _np = Point(_x, _y)
                _layer.addObject(_np)
            else:
                _np = _most_used(_pts)
    else:
        pt.freeUser(arc)
        _pts = _layer.find('point', _x, _y)
        if len(_pts) == 0:
            _np = Point(_x, _y)
            _layer.addObject(_np)
        else:
            _np = _most_used(_pts)
    if _np is not None:
        _np.storeUser(arc)
        if _adjust_dimensions(pt, _np):
            _layer.delObject(pt)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
</t>
<t tx="1.20130426141258.3471">def _rotate_arc(obj, objdict, cx, cy, ra):
    _layer = obj.getParent()
    if _layer is None:
        raise RuntimeError("Arc parent is None")
    _cp = obj.getCenter()    
    if _cp.getParent() is not _layer:
        raise RuntimeError("Arc/center parent object conflict!")
    _ep1, _ep2 = obj.getEndpoints()
    _pts = _layer.find('point', _ep1[0], _ep1[1])
    _ep = _used_by(obj, _pts)
    if _ep is None:
        raise RuntimeError("Lost Arc first endpoint: " + str(_ep))
    _adjust_endpoint(obj, _ep, objdict, cx, cy, ra)
    _pts = _layer.find('point', _ep2[0], _ep2[1])
    _ep = _used_by(obj, _pts)
    if _ep is None:
        raise RuntimeError("Lost Arc second endpoint: " + str(_ep))
    _adjust_endpoint(obj, _ep, objdict, cx, cy, ra)
    _np = _xfrm_point(_cp, objdict, cx, cy, ra)
    if _np is not None:
        obj.setCenter(_np)
        if _adjust_dimensions(_cp, _np):
            _layer.delObject(_cp)
    _da = ra/_dtr
    obj.setStartAngle(obj.getStartAngle() + _da)
    obj.setEndAngle(obj.getEndAngle() + _da)
    _pid = id(_cp)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
</t>
<t tx="1.20130426141258.3472">def _rotate_circ_ccirc(obj, objdict, cx, cy, ra):
    if isinstance(obj, Circle):
        _objtype = 'Circle'
    elif isinstance(obj, CCircle):
        _objtype = 'CCircle'
    else:
        raise TypeError("Unexpected object type: " + repr(type(obj)))
    _layer = obj.getParent()
    if _layer is None:
        raise RuntimeError("%s parent is None" % _objtype)
    _cp = obj.getCenter()    
    if _cp.getParent() is not _layer:
        raise RuntimeError("%s/center parent object conflict!" % _objtype)
    _np = _xfrm_point(_cp, objdict, cx, cy, ra)
    if _np is not None:
        obj.setCenter(_np)
        if _adjust_dimensions(_cp, _np):
            _layer.delObject(_cp)
    _pid = id(_cp)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
</t>
<t tx="1.20130426141258.3473">def _rotate_seg_cline(obj, objdict, cx, cy, ra):
    if isinstance(obj, Segment):
        _p1, _p2 = obj.getEndpoints()
        _objtype = 'Segment'
    elif isinstance(obj, CLine):
        _p1, _p2 = obj.getKeypoints()
        _objtype = 'CLine'
    else:
        raise TypeError("Unexpected object type: " + repr(type(obj)))
    _layer = obj.getParent()
    if _layer is None:
        raise RuntimeError("%s parent is None" % _objtype)
    if _p1.getParent() is not _layer:
        raise RuntimeError("%s/P1 parent object conflict!" % _objtype)
    if _p2.getParent() is not _layer:
        raise RuntimeError("%s/P2 parent object conflict!" % _objtype)
    _np = _xfrm_point(_p1, objdict, cx, cy, ra)
    if _np is not None:
        obj.setP1(_np)
        if _adjust_dimensions(_p1, _np):
            _layer.delObject(_p1)
    _np = _xfrm_point(_p2, objdict, cx, cy, ra)
    if _np is not None:
        obj.setP2(_np)
        if _adjust_dimensions(_p2, _np):
            _layer.delObject(_p2)
    _pid = id(_p1)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
    _pid = id(_p2)
    if objdict.get(_pid) is not False:
        objdict[_pid] = False
</t>
<t tx="1.20130426141258.3474">def _adjust_point_users(pt, objdict, da):
    _layer = pt.getParent()
    for _user in pt.getUsers():
        _uid = id(_user)
        if _uid in objdict:
            if isinstance(_user, HCLine) and _layer is not None:
                if abs(fmod(da, 180.0)) &lt; 1e-10:
                    objdict[_uid] = False
                elif abs(fmod(da, 90.0)) &lt; 1e-10:
                    _layer.addObject(VCLine(pt))
                    _layer.delObject(_user)
                    del objdict[_uid]
                else:
                    _layer.addObject(ACLine(pt, da))
                    _layer.delObject(_user)
                    del objdict[_uid]
            elif isinstance(_user, VCLine) and _layer is not None:
                if abs(fmod(da, 180.0)) &lt; 1e-10:
                    objdict[_uid] = False
                elif abs(fmod(da, 90.0)) &lt; 1e-10:
                    _layer.addObject(HCLine(pt))
                    _layer.delObject(_user)
                    del objdict[_uid]
                else:
                    _layer.addObject(ACLine(pt, da))
                    _layer.delObject(_user)
                    del objdict[_uid]
            elif isinstance(_user, ACLine) and _layer is not None:
                _user.setAngle(_user.getAngle() + da)
                objdict[_uid] = False
            else:
                if not isinstance(_user, Dimension):
                    objdict[_uid] = False
</t>
<t tx="1.20130426141258.3475">def rotate_objects(objs, cx, cy, angle):
    """Rotate a list of objects.

rotate_objects(objs, cx, cy, angle)

objs: A list or tuple containing the objects to move.
cx: Rotation center point 'x' coordinate
cy: Rotation center point 'y' coordinate
angle: Angular amount of rotation
    """
    if not isinstance(objs, (list, tuple)):
        raise TypeError("Invalid object list/tuple: " + repr(type(objs)))
    _cx = util.get_float(cx)
    _cy = util.get_float(cy)
    _da = fmod(util.get_float(angle), 360.0)
    _ra = _da * _dtr # value in radians
    if abs(_ra) &lt; 1e-10:
        return
    _objdict = {}
    _fillets = []
    for _obj in objs:
        if not isinstance(_obj, DimString):
            _objdict[id(_obj)] = True
    for _obj in objs:
        _oid = id(_obj)
        if _oid not in _objdict:
            continue
        if _objdict[_oid]:
            if isinstance(_obj, Point):
                _x, _y = _calc_coords(_obj, _cx, _cy, _ra)
                _obj.setCoords(_x, _y)
                _adjust_point_users(_obj, _objdict, _da)
            elif isinstance(_obj, (Segment, CLine)):
                _rotate_seg_cline(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, (Circle, CCircle)):
                _rotate_circ_ccirc(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, Arc):
                _rotate_arc(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, Leader):
                _rotate_leader(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, Polyline):
                _rotate_polyline(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, (TextBlock, Dimension)) and False:
                _obj.move(_cx, _cy)
            elif isinstance(_obj, HCLine):
                _rotate_hcline(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, VCLine):
                _rotate_vcline(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, ACLine):
                _rotate_acline(_obj, _objdict, _cx, _cy, _ra)
            elif isinstance(_obj, (Chamfer, Fillet)) and False:
                _s1, _s2 = _obj.getSegments()
                if id(_s1) not in _objdict or id(_s2) not in _objdict:
                    _layer = _obj.getParent()
                    _layer.delObject(_obj)
                if isinstance(_obj, Fillet):
                    _fillets.append(_obj)
            else:
                print("Unexpected entity type: " + repr(type(_obj)))
            _objdict[_oid] = False
        for _obj in _fillets:
            _obj._calculateCenter() # FIXME
</t>
<t tx="1.20130426141258.3476">#
# Copyright (c) 2003, 2004 Art Haas
#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# functions for handling tangent circles on multiple objects
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3477">import math

from Kernel.GeoEntity.cline import CLine
from Kernel.GeoEntity.ccircle import CCircle
from Kernel.exception import *

#
# common constants
#

_dtr = math.pi/180.0
_piover2 = math.pi/2.0
</t>
<t tx="1.20130426141258.3478">def _get_two_point_projection(x1, y1, x2, y2, x, y):
    """
        project a point to a segment 
    """
    _sqlen = pow((x2 - x1), 2) + pow((y2 - y1), 2)
    _rn = ((x - x1) * (x2 - x1)) + ((y - y1) * (y2 - y1))
    _r = _rn/_sqlen
    _px = x1 + _r * (x2 - x1)
    _py = y1 + _r * (y2 - y1)
    return _px, _py
</t>
<t tx="1.20130426141258.3479">def _get_angled_projection(angle, yint, x, y):
    """
        find the projection point of point (x, y) on a line
        defined by an angle and y intercept
    """
    _x1 = 0.0
    _y1 = yint
    _x2 = _x1 + math.cos(angle)
    _y2 = _y1 + math.sin(angle)
    return _get_two_point_projection(_x1, _y1, _x2, _y2, x, y)
</t>
<t tx="1.20130426141258.3480">def _two_line_tangent(x1, y1, x2, y2, x3, y3, x4, y4, x, y):
    """
        this function calculates the apprpriate tangent circle
        for two lines (x1, y1)-&gt;(x2, y2) and (x3, y3)-&gt;(x4, y4)
        using a point (x, y) to determine which tangent circle
        should be defined
    """
    _cx = _cy = _radius = None
    _denom = ((x2 - x1) * (y4 - y3)) - ((y2 - y1) * (x4 - x3))
    # print "denom: %g" % _denom
    if abs(_denom) &lt; 1e-10:
        # print "parallel ..."
        if abs(x2 - x1) &lt; 1e-10: # both vertical
            if x &lt; min(x1, x3) or x &gt; max(x1, x3):
                return None
            _cx = (x3 + x1)/2.0
            _cy = y
            _radius = abs(x3 - x1)/2.0
        elif abs(y2 - y1) &lt; 1e-10: # both horizontal
            if y &lt; min(y1, y3) or y &gt; max(y1, y3):
                return None
            _cx = x
            _cy = (y3 + y1)/2.0
            _radius = abs(y3 - y1)/2.0
        else: # both at equal angles
            _ax1, _ay1 = _get_two_point_projection(x1, y1, x2, y2, x, y)
            # print "ax1: %g; ay1: %g" % (_ax1, _ay1)
            _ax2, _ay2 = _get_two_point_projection(x3, y3, x4, y4, x, y)
            # print "ax2: %g; ay2: %g" % (_ax2, _ay2)
            if (x &lt; min(_ax1, _ax2) or
                x &gt; max(_ax1, _ax2) or
                y &lt; min(_ay1, _ay2) or
                y &gt; max(_ay1, _ay2)):
                return None
            _cx = (_ax1 + _ax2)/2.0
            _cy = (_ay1 + _ay2)/2.0
            _radius = math.hypot((_ax1 - _cx), (_ay1 - _cy))
        return _cx, _cy, _radius
    #
    # the lines are not parallel, so we have to test for the
    # different combinations of horizontal/vertical/sloped lines ...
    #
    if abs(y2 - y1) &lt; 1e-10: # horizontal line 1
        # print "horizontal line 1 ..."
        if abs(y4 - y3) &lt; 1e-10: # this should be handled above ...
            # print "horizontal line 2 ..."
            if y &lt; min(y1, y3) or y &gt; max(y1, y3):
                return None
            _cx = x
            _cy = (y1 + y3)/2.0
            _radius = abs(_cy - y1)
        elif abs(x4 - x3) &lt; 1e-10: # vertical line 2
            # print "vertical line 2 ..."
            _a1 = math.pi/4.0
            _a2 = -_a1
        else:
            _angle = math.atan2((y4 - y3), (x4 - x3))
            _a1 = _angle/2.0
            if _a1 &gt; 0.0:
                _a2 = _a1 - _piover2
            else:
                _a2 = _a1 + _piover2
    elif abs(x2 - x1) &lt; 1e-10: # vertical line 1
        # print "vertical line 1 ..."
        if abs(y4 - y3) &lt; 1e-10: # horizontal line2
            # print "horizontal line 2 ..."
            _a1 = math.pi/4.0
            _a2 = -_a1
        elif abs(x4 - x3) &lt; 1e-10: # this should be handled above ...
            if x &lt; min(x1, x3) or x &gt; max(x1, x3):
                return None
            _cx = (x1 + x3)/2.0
            _cy = y
            _radius = abs(_cx - x1)
        else:
            _angle = math.atan2((y4 - y3), (x4 - x3))
            if _angle &gt; 0.0:
                _a1 = (_angle + _piover2)/2.0
                _a2 = _a1 - _piover2
            else:
                _a1 = (_angle - _piover2)/2.0
                _a2 = _a1 + _piover2
    else:
        _angle1 = math.atan2((y2 - y1), (x2 - x1))
        if abs(y4 - y3) &lt; 1e-10: # horizontal line2
            _a1 = _angle1/2.0
            if _a1 &gt; 0.0:
                _a2 = _a1 - _piover2
            else:
                _a2 = _a1 + _piover2
        elif abs(x4 - x3) &lt; 1e-10: # vertical line2
            if _angle1 &gt; 0.0:
                _a1 = (_angle1 + _piover2)/2.0
                _a2 = _a1 - _piover2
            else:
                _a1 = (_angle1 - _piover2)/2.0
                _a2 = _a1 + _piover2
        else:
            _angle2 = math.atan2((y4 - y3), (x4 - x3))
            _a1 = (_angle1 + _angle2)/2.0
            if _a1 &gt; 0.0:
                _a2 = _a1 - _piover2
            else:
                _a2 = _a1 + _piover2
    if _cx is not None and _cy is not None and _radius is not None:
        return _cx, _cy, _radius
    #
    # handle the general case of two lines at arbitrary angles
    #
    # print "arbitrary angles ..."
    # print "a1: %g" % (_a1/_dtr)
    # print "a2: %g" % (_a2/_dtr)
    _rn = ((y1 - y3) * (x4 - x3)) - ((x1 - x3) * (y4 - y3))
    # print "rn: %g" % _rn
    _r = _rn/_denom
    # print "r: %g" % _r
    _ix = x1 + _r * (x2 - x1)
    _iy = y1 + _r * (y2 - y1)
    # print "ix: %g; iy: %g" % (_ix, _iy)
    _m1 = math.tan(_a1)
    _b1 = _iy - (_m1 * _ix)
    # print "line1: m: %g; b: %g" % (_m1, _b1)
    _m2 = math.tan(_a2)
    _b2 = _iy - (_m2 * _ix)
    # print "line2: m: %g; b: %g" %  (_m2, _b2)
    _px1, _py1 = _get_angled_projection(_a1, _b1, x, y)
    # print "px1: %g; py1: %g" % (_px1, _py1)
    _sep1 = math.hypot((_px1 - x), (_py1 - y))
    _px2, _py2 = _get_angled_projection(_a2, _b2, x, y)
    # print "px2: %g; py2: %g" % (_px2, _py2)
    _sep2 = math.hypot((_px2 - x), (_py2 - y))
    if _sep1 &lt; _sep2:
        _cx = _px1
        _cy = _py1
    else:
        _cx = _px2
        _cy = _py2
    _px, _py = _get_two_point_projection(x1, y1, x2, y2, _cx, _cy)
    _radius = math.hypot((_px - _cx), (_py - _cy))
    return _cx, _cy, _radius
</t>
<t tx="1.20130426141258.3481">def _gen_cline_ccircle_tangent(radius, hy, x):
    #
    # center of ccircle : (0,0)
    # radius of ccircle : r
    # distance between ccircle and hcl: hy
    # x-coordinate of mouse: x
    #
    # center of tangent circle : (px, py)
    #
    # projection point on hcl: (px, hy)
    #
    # Projection point outside the radius of the circle gives:
    #
    # math.hypot((px - cx), (py - cy)) == math.hypot((px - px), (py - hy)) + r
    #
    # Projection point inside the radius of the circle gives:
    #
    # math.hypot((px - cx), (py - cy)) + rt = r
    #
    # rt == radius of tangent circle
    #
    # Distance from projection point to tangent circle center
    #
    # math.hypot((px - px), (py - hy)) = rt
    #
    # lots of algebra reduces to the following two cases
    #
    _cx = x
    if hy &gt; 0.0:
        _num = pow(x, 2) - pow(hy, 2) - (2.0 * hy * radius) - pow(radius, 2)
        _den = (-2.0 * hy) - (2.0 * radius)
    else:
        _num = pow(x, 2) - pow(hy, 2) + (2.0 * hy * radius) - pow(radius, 2)
        _den = (2.0 * radius) - (2.0 * hy)
    # print "num: %g" % _num
    # print "den: %g" % _den
    _cy = _num/_den
    _radius = abs(_cy - hy)
    return _cx, _cy, _radius
</t>
<t tx="1.20130426141258.3482">#
# two-point construction line
#

def _cl_cl_tangent(cl1, cl2, x, y):
    _p1, _p2 = cl1.getKeypoints()
    _x1, _y1 = _p1.getCoords()
    _x2, _y2 = _p2.getCoords()
    _p3, _p4 = cl2.getKeypoints()
    _x3, _y3 = _p3.getCoords()
    _x4, _y4 = _p4.getCoords()
    return _two_line_tangent(_x1, _y1, _x2, _y2, _x3, _y3, _x4, _y4, x, y)
</t>
<t tx="1.20130426141258.3483">def _cl_cc_tangent(cl, cc, x, y):
    _p1, _p2 = cl.getKeypoints()
    _x1, _y1 = _p1.getCoords()
    # print "x1: %g; y1: %g" % (_x1, _y1)
    _x2, _y2 = _p2.getCoords()
    # print "x2: %g; y2: %g" % (_x2, _y2)
    _ccx, _ccy = cc.center.getCoords()
    # print "ccx: %g; ccy: %g" % (_ccx, _ccy)
    _rad = cc.radius
    #
    # transform the coords into the system where the circle center is (0,0)
    # and rotate so the CLine is horizontal
    #
    _apx, _apy = cl.getProjection(_ccx, _ccy)
    # print "apx: %g; apy: %g" % (_apx, _apy)
    _sep = math.hypot((_apx - _ccx), (_apy - _ccy))
    # print "sep: %g" % _sep
    #
    # use the line (ccx, ccy) to (apx, apy) to determine the
    # angular rotation
    #
    if abs(_apx - _ccx) &lt; 1e-10: # cline is horizontal
        _sine = 0.0
        if _apy &gt; _ccy: # system rotated 0.0
            _cosine = 1.0
        else: # system rotated 180.0
            _cosine = -1.0
    elif abs(_apy - _ccy) &lt; 1e-10: # cline is vertical; system rotated -90.0
        _cosine = 0.0
        if _apx &gt; _ccx: # system rotated 90.0
            _sine = 1.0
        else: # system rotated -90.0
            _sine = -1.0
    else:
        _angle = _piover2 - math.atan2((_apy - _ccy), (_apx - _ccx))
        # print "angle: %g" % _angle
        _sine = math.sin(_angle)
        _cosine = math.cos(_angle)
    # print "sin(angle): %g" % _sine
    # print "cos(angle): %g" % _cosine
    #
    # transform (x, y) into
    _tx1 = x - _ccx
    _ty1 = y - _ccy
    # print "tx1: %g; ty1: %g" % (_tx1, _ty1)
    #
    # transform by rotating through angle to
    # map to horizontal line
    #
    _tx = (_tx1 * _cosine) - (_ty1 * _sine)
    _ty = (_tx1 * _sine) + (_ty1 * _cosine)
    # print "tx: %g; ty: %g" % (_tx, _ty)
    _tcx, _tcy, _tcrad = _gen_cline_ccircle_tangent(_rad, _sep, _tx)
    #
    # transform result back into real coordinates
    #
    # print "tcx: %g: tcy: %g" % (_tcx, _tcy)
    _cx = ((_tcx * _cosine) + (_tcy * _sine)) + _ccx
    _cy = (-(_tcx * _sine) + (_tcy * _cosine)) + _ccy
    # print "cx: %g; cy %g" % (_cx, _cy)
    return _cx, _cy, _tcrad
</t>
<t tx="1.20130426141258.3484">def calc_tangent_circle(obja, objb, x, y):
    _x = x
    if not isinstance(_x, float):
        _x = float(x)
    _y = y
    if not isinstance(_y, float):
        _y = float(y)
    _tandata = None
    if isinstance(obja, CLine):
        if isinstance(objb, CLine):
            _tandata = _cl_cl_tangent(obja, objb, _x, _y)
        elif isinstance(objb, CCircle):
            _cl_cc_tangent(obja, objb, _x, _y)
    elif isinstance(obja, CCircle):
        if isinstance(objb, CLine):
            _tandata = _cl_cc_tangent(objb, obja, _x, _y)
        else:
            raise NotImplementedError("We must define the ccircle ccircle tangent")
            # CCircle/CCircle tangent circles to do later ...
    return _tandata
</t>
<t tx="1.20130426141258.3485">#
# calculate the possible tangent lines between two circles
#

def _calc_values(ax, ay, bx, by, cx, cy):
    """This function was used for debugging"""
    _den = pow((bx - ax), 2) + pow((by - ay), 2)
    _num = ((cx - ax) * (bx - ax)) + ((cy - ay) * (by - ay))
    _r = _num/_den
    # print "r: %g" % _r
    _num = ((ay - cy) * (bx - ax)) - ((ax - cx) * (by - ay))
    _s = _num/_den
    # print "s: %g" % _s
    _sep = abs(_s) * math.sqrt(_den)
    # print "sep: %g" % _sep
    # return _r, _s, _sep
</t>
<t tx="1.20130426141258.3486">def _calc_tangent_triangle(r1, r2, sep, ip):
    _sine = r1/abs(ip)
    # print "sin: %g" % _sine
    _angle = math.asin(_sine)
    # print "angle: %g" % (_angle * (180.0/math.pi))
    _tan = math.tan(_angle)
    # print "tan(angle): %g" % _tan
    _cosine = math.cos(_angle)
    # print "cos(angle): %g" % _cosine
    _tanlen = r1/_tan
    # print "tanlen: %g" % _tanlen
    if ip &lt; 0.0: # r1 &lt; r2 and intersection point left of r1
        assert abs(ip) &gt; r1, "Expected ip beyond radius: %g &lt; %g" % (ip, r1)
        _tx1 =  ip + (_tanlen * _cosine)
    else:
        _tx1 =  ip - (_tanlen * _cosine)
    # print "tx1: %g" % _tx1
    _ty1 = _tanlen * _sine
    # print "ty1: %g" % _ty1
    _dist = math.hypot(_tx1, _ty1)
    # print "dist: %g" % _dist
    assert abs(_dist - r1) &lt; 1e-10, "Invalid tangent point for circle 1"
    _tanlen = r2/_tan
    # print "tanlen: %g" % _tanlen
    if ip &lt; 0.0: # see above
        _tx2 = ip + (_tanlen * _cosine)
        _ty2 = _tanlen * _sine
    elif ip &gt; (sep + r2): # only possible if r1 &gt; r2
        _tx2 = ip - (_tanlen * _cosine)
        _ty2 = _tanlen * _sine
    else:
        _tx2 = ip + (_tanlen * _cosine)
        _ty2 = -1.0 * _tanlen * _sine
    # print "tx2: %g" % _tx2
    # print "ty2: %g" % _ty2
    _dist = math.hypot((_tx2 - sep), _ty2)
    # print "dist: %g" % _dist
    assert abs(_dist - r2) &lt; 1e-10, "Invalid tangent point for circle 2"
    return _tx1, _ty1, _tx2, _ty2
</t>
<t tx="1.20130426141258.3487">def calc_two_circle_tangents(r1, r2, sep):
    # print "in calc_two_circle_tangents() ..."
    _r1 = r1
    if not isinstance(_r1, float):
        _r1 = float(r1)
    if not _r1 &gt; 0.0:
        raise ValueError("Invalid radius: %g" % _r1)
    _r2 = r2
    if not isinstance(_r2, float):
        _r2 = float(r2)
    if not _r2 &gt; 0.0:
        raise ValueError("Invalid radius: %g" % _r2)
    _sep = sep
    if not isinstance(_sep, float):
        _sep = float(sep)
    _tangents = []
    if (abs(_sep) + min(_r1, _r2)) &gt; max(_r1, _r2): # small circle not within larger
        if abs(_r1 - _r2) &lt; 1e-10:
            # print "same radii ..."
            _tangents.append((0.0, _r1, _sep, _r2))
            _tangents.append((0.0, -_r1, _sep, -_r2))
            if abs(_sep) &gt; _r1 + _r2:
                _mid = _sep/2.0
                _angle = math.asin(_r1/_mid)
                _tanlen = _r1/math.tan(_angle)
                _xt = _tanlen * math.cos(_angle)
                _yt = _tanlen * math.sin(_angle)
                _tx1 = _mid - _xt
                _ty1 = _yt
                _tx2 = _mid + _xt
                _ty2 = -_yt
                _tangents.append((_tx1, _ty1, _tx2, _ty2))
                # _calc_values(_tx1, _ty1, _tx2, _ty2, 0.0, 0.0)
                # _calc_values(_tx1, _ty1, _tx2, _ty2, _sep, 0.0)
                _tangents.append((_tx1, -_ty1, _tx2, -_ty2))
                # _calc_values(_tx1, -_ty1, _tx2, -_ty2, 0.0, 0.0)
                # _calc_values(_tx1, -_ty1, _tx2, -_ty2, _sep, 0.0)
        else:
            _alpha = pow((_r1/_r2), 2)
            # print "alpha: %g" % _alpha
            _a = (1.0 - _alpha)
            # print "a: %g" % _a
            _b = (2.0 * _alpha * _sep)
            # print "b: %g" % _b
            _c = (-1.0 * _alpha * pow(_sep, 2))
            # print "c: %g" % _c
            _det = pow(_b, 2) - (4.0 * _a * _c)
            # print "det: %g" % _det
            if _det &gt; 0.0: # can this ever be negative?
                # print "r1: %g" % _r1
                # print "r2: %g" % _r2
                # print "sep: %g" % _sep
                _denom = 2.0 * _a
                _det_sqrt = math.sqrt(_det)
                _num = (-1.0 * _b) + _det_sqrt
                _offset = _num/_denom
                # print "offset: %g" % _offset
                if (_r1 &gt; _r2):
                    # print "r1 &gt; r2"
                    if ((_offset &gt; (_sep + _r2)) or
                        ((_offset &gt; _r1) and (_offset &lt; (_sep - _r2)))):
                        _tpts = _calc_tangent_triangle(_r1, _r2, _sep, _offset)
                        _tangents.append(_tpts)
                        _tx1, _ty1, _tx2, _ty2 = _tpts
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, 0.0, 0.0)
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, 0.0, 0.0)
                        _tpts = (_tx1, - _ty1, _tx2, -_ty2)
                        _tangents.append(_tpts)
                        # _calc_values(_tx1, -_ty1, _tx2,-_ty2, 0.0, 0.0)
                        # _calc_values(_tx1, -_ty1, _tx2, -_ty2, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, 0.0, 0.0)
                else: # _r1 &lt; _r2
                   #  print "r1 &lt; r2"
                    if ((_offset &lt; -_r1) or
                        ((_offset &gt; _r1) and (_offset &lt; (_sep - _r2)))):
                        _tpts = _calc_tangent_triangle(_r1, _r2, _sep, _offset)
                        _tangents.append(_tpts)
                        _tx1, _ty1, _tx2, _ty2 = _tpts
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, 0.0, 0.0)
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, 0.0, 0.0)
                        _tpts = (_tx1, - _ty1, _tx2, -_ty2)
                        _tangents.append(_tpts)
                        # _calc_values(_tx1, -_ty1, _tx2,-_ty2, 0.0, 0.0)
                        # _calc_values(_tx1, -_ty1, _tx2, -_ty2, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, 0.0, 0.0)
                _num = (-1.0 * _b) - _det_sqrt
                _offset = _num/_denom
                # print "offset: %g" % _offset
                if (_r1 &gt; _r2):
                    # print "r1 &gt; r2"
                    if ((_offset &gt; (_sep + _r2)) or
                        ((_offset &gt; _r1) and (_offset &lt; (_sep - _r2)))):
                        _tpts = _calc_tangent_triangle(_r1, _r2, _sep, _offset)
                        _tangents.append(_tpts)
                        _tx1, _ty1, _tx2, _ty2 = _tpts
                        _tpts = (_tx1, - _ty1, _tx2, -_ty2)
                        _tangents.append(_tpts)
                else: # _r1 &lt; _r2
                    # print "r1 &lt; r2"
                    if ((_offset &lt; -_r1) or
                        ((_offset &gt; _r1) and (_offset &lt; (_sep - _r2)))):
                        _tpts = _calc_tangent_triangle(_r1, _r2, _sep, _offset)
                        _tangents.append(_tpts)
                        _tx1, _ty1, _tx2, _ty2 = _tpts
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, 0.0, 0.0)
                        # _calc_values(_tx1, _ty1, _tx2, _ty2, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, _sep, 0.0)
                        # _calc_values(_tx2, _ty2, _tx1, _ty1, 0.0, 0.0)
                        _tpts = (_tx1, - _ty1, _tx2, -_ty2)
                        _tangents.append(_tpts)
                        # _calc_values(_tx1, -_ty1, _tx2,-_ty2, 0.0, 0.0)
                        # _calc_values(_tx1, -_ty1, _tx2, -_ty2, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, _sep, 0.0)
                        # _calc_values(_tx2, -_ty2, _tx1, -_ty1, 0.0, 0.0)
    return _tangents
</t>
<t tx="1.20130426141258.3488">#
# Copyright (c) 2002, 2003 Art Haas
# Copyright (c) 2010 Matteo Boscolo
# This file is part of PythonCAD.
# 
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# this is a class that keeps a tolerance value. It should
# be used as a class (static) variable for classes that
# will compare instances with a tolerance
#
# a valid tolerance is a float value 0 or greater
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3489">TOL = 1e-10
</t>
<t tx="1.20130426141258.3490">class TolObject(object):
    """A class for maintaining a tolerance value.

The tolerance value is a float that must be 0.0 or
greater. Any class using this class as a base class
will have a tolerance value unique to that class.

There are two member functions:

getTolerance(): return the current tolerance
setTolerance(t): set the new tolerance

    """
    @others
    tolerance = property(getTolerance, setTolerance, None, "Tolerance value")
</t>
<t tx="1.20130426141258.3491">def __init__(self, t=None):
    """Initialize a TolObject.

\\-4.TolObject(t)

\\-4.Optional argument t must be a float, and it
\\-4.must be greater than 0. A default tolerance is set
\\-4.if the function is called without arguments.
    """
    if t is None:
        t = TOL
    tol = t
    if not isinstance(tol, float):
        tol = float(t)
    if tol &lt; 0.0:
        raise ValueError("Tolerance must be greater than 0: " + repr(tol))
    self.__tolerance = tol
</t>
<t tx="1.20130426141258.3492">def setTolerance(self, t=None):
    """Set the tolerance value.

\\-4.setTolerance(t)

\\-4.Optional argument t must be a float, and it
\\-4.must be greater than 0. The default tolerance is
\\-4.reset if the function is called without arguments.
\\-4.This function returns the old tolerance value.
    """
    old_tol = self.__tolerance
    if t is None:
        t = TOL
    tol = t
    if not isinstance(tol, float):
        tol = float(t)
    if tol &lt; 0.0:
        raise ValueError("Tolerance must be greater than 0: " + repr(tol))
    self.__tolerance = tol
    return old_tol
</t>
<t tx="1.20130426141258.3493">def getTolerance(self):
    """Get the tolerance value.

\\-4.getTolerance()

\\-4.Return the current tolerance.
    """
    return self.__tolerance
</t>
<t tx="1.20130426141258.3494">class StaticTolObject(object):
    """A class for maintaining a tolerance value.

This class is meant to be a base-class for classes
that wish to use a tolerance value for comparing
one instance to another.

There are two class methods:

getTolerance(): return the current tolerance
setTolerance(tol): set the new tolerance

This class stores the tolerance value as a static class
variable, so any classes using this class as a base class
will share the same tolerance value.
    """

    __tolerance = TOL
    
    @others
    getTolerance = classmethod(getTolerance)
</t>
<t tx="1.20130426141258.3495">def setTolerance(cls, t=None):
    """Set the tolerance value.

\\-4.Optional argument t must be a float, and itmust be
\\-4.greater than 0. The default tolerance is reset if
\\-4.the function is called without arguments.

\\-4.This function returns the old tolerance value.
    """
    old_tol = cls.__tolerance
    if t is None:
        t = TOL
    _t = t
    if not isinstance(_t, float):
        _t = float(t)
    if _t &lt; 0.0:
        raise ValueError("Tolerance must be greater than 0: " + repr(_t))
    cls.__tolerance = _t
    return old_tol
</t>
<t tx="1.20130426141258.3496">setTolerance = classmethod(setTolerance)

def getTolerance(cls):
    """Get the tolerance value.

\\-4.Return the current tolerance.
    """
    return cls.__tolerance
</t>
<t tx="1.20130426141258.3497">def toltest(tol):
    """Test that a tolerance value is valid.

toltest(tol)

The argument "tol" should be a float.
    """
    _t = tol
    if not isinstance(_t, float):
        _t = float(tol)
    if _t &lt; TOL:
        raise ValueError("Invalid tolerance: %g" % _t)
    return _t
</t>
<t tx="1.20130426141258.3498">#
# Copyright (c) 2002, 2003, 2004 Art Haas
#
# This file is part of PythonCAD.
# 
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# miscellaneous utility functions
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3499">import random
import string 

from math import fmod, pi
import types

from Kernel.GeoUtil.tolerance       import TOL
</t>
<t tx="1.20130426141258.3500">def get_float(val):
    _v = val
    if not isinstance(_v, float):
        if not isinstance(_v, int):
            raise TypeError("Invalid non-numeric type: " + repr(type(_v)))
        _v = float(val)
    return _v
</t>
<t tx="1.20130426141258.3501">def test_boolean(val):
    if hasattr(types, 'BooleanType'):
        if not isinstance(val, bool):
            raise TypeError("Invalid non-boolean type: " + repr(type(val)))
    else:
        if val is not True and val is not False:
            raise TypeError("Invalid non-boolean type: " + repr(type(val)))
</t>
<t tx="1.20130426141258.3502">def tuple_to_two_floats(t):
    if not isinstance(t, tuple):
        raise TypeError("Argument must be a tuple: " + repr(type(t)))
    if len(t) != 2:
        raise ValueError("Tuple must hold exactly two objects: " + str(t))
    _obj1, _obj2 = t
    _x = get_float(_obj1)
    _y = get_float(_obj2)
    return _x, _y
</t>
<t tx="1.20130426141258.3503">def tuple_to_three_floats(t):
    if not isinstance(t, tuple):
        raise TypeError("Argument must be a tuple: " + repr(type(t)))
    if len(t) != 3:
        raise ValueError("Tuple must hold exactly three objects: " + str(t))
    _obj1, _obj2, _obj3 = t
    _x = get_float(_obj1)
    _y = get_float(_obj2)
    _z = get_float(_obj3)
    return _x, _y, _z
</t>
<t tx="1.20130426141258.3504">def make_angle(angle):
    """
        Return an angle value such that -pi/2 &lt;= angle &lt;= pi/2.
        The argument angle should be a float. Additionally the argument
        is expected to be in radians.
    """
    pi_2=math.pi/2
    pi_3=3*pi_2
    _angle = get_float(angle)
    if _angle &lt; -pi_2 or _angle &gt; pi_2:
        _fa = fmod(_angle, math.pi)
        if abs(_fa) &lt; 1e-10:
            _angle = 0.0
        elif _fa &gt; 0.0:
            if _fa &gt; pi_3:
                _angle = _fa - math.pi
            elif _fa &gt; pi_2:
                _angle = _fa - pi_2
            else:
                _angle = _fa
        else:
            if _fa &lt; -pi_3:
                _angle = _fa + math.pi
            elif _fa &lt; -pi_2:
                _angle = _fa + pi_2
            else:
                _angle = _fa
    return _angle
</t>
<t tx="1.20130426141258.3505">def make_c_angle(angle):
    """
        Return an angle value such that 0 &lt;= angle &lt;= 360.
        The argument angle should be a float.
    """
    _a = get_float(angle)
    if _a &lt; 0.0:
        _a = fmod(_a, 360.0) + 360.0
    elif _a &gt; 360.0:
        _a = fmod(_a, 360.0)
    return _a
</t>
<t tx="1.20130426141258.3506">def make_c_angle_rad(angle):
    """
        return the angle from 0 to 2*pi
    """
    while angle&gt;pi*2:
        angle=angle-pi*2
    return angle
</t>
<t tx="1.20130426141258.3507">def make_coords(x, y):
    """Check and convert x/y values to float values.

make_coords(x, y)

This routine is used to ensure the values are float values.
    """
    _x = get_float(x)
    _y = get_float(y)
    return _x, _y
</t>
<t tx="1.20130426141258.3508">def make_region(xmin, ymin, xmax, ymax):
    """Return a validated region defined by (xmin, ymin) to (xmax, ymax).

make_region(xmin, ymin, xmax, ymax)

This routine is used to ensure the values are floats and
that xmin &lt; xmax and ymin &lt; ymax.
    """
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Invalid values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Invalid values: ymax &lt; ymin")
    return _xmin, _ymin, _xmax, _ymax
</t>
<t tx="1.20130426141258.3509">def degrees(value):
    """Convert a value from radians to degrees.

degrees(value)

In Python 2.3 this is available as the math.degrees() function, but
the value isn't scaled from -360.0 &lt;= angle &lt;= 360.0
    """
    _value = get_float(value)
    return fmod(_value, 360.0)
</t>
<t tx="1.20130426141258.3510">def radians(value):
    """
        Convert a value from degrees to radians.
        In Python 2.3 this is available ad the math.radians() function, but
        the value isn't scaled from -2*pi &lt;= angle &lt;= 2*pi
    """
    _value = get_float(value)
    return fmod(_value, (2.0 * pi))
</t>
<t tx="1.20130426141258.3511">#
# map x/y coordinates to a (x1, y1)-&gt;(x2, y2) segment
#

def map_coords(x, y, x1, y1, x2, y2, tol=TOL):
    """
map_coords(x, y, x1, y1, x2, y2[, tol])
    """
    _x = get_float(x)
    _y = get_float(y)
    _x1 = get_float(x1)
    _y1 = get_float(y1)
    _x2 = get_float(x2)
    _y2 = get_float(y2)
    _t = toltest(tol)
    if ((_x &lt; min(_x1, _x2) - _t) or
        (_y &lt; min(_y1, _y2) - _t) or
        (_x &gt; max(_x1, _x2) + _t) or
        (_y &gt; max(_y1, _y2) + _t)):
        return None
    _sqlen = pow((_x2 - _x1), 2) + pow((_y2 - _y1), 2)
    if _sqlen &lt; 1e-10: # coincident points
        return None
    _r = ((_x - _x1)*(_x2 - _x1) + (_y - _y1)*(_y2 - _y1))/_sqlen
    if _r &lt; 0.0:
        _r = 0.0
    if _r &gt; 1.0:
        _r = 1.0
    _px = _x1 + _r * (_x2 - _x1)
    _py = _y1 + _r * (_y2 - _y1)
    if abs(_px - _x) &lt; _t and abs(_py - _y) &lt; _t:
        return _px, _py
    return None
</t>
<t tx="1.20130426141258.3512">#
# test if line segments are visible within a rectangular region
#

def in_region(x1, y1, x2, y2, xmin, ymin, xmax, ymax):
    """Test if a segment from (x1, y1)-&gt;(x2, y2) is in region.

in_region(x1, y1, x2, y2, xmin, ymin, xmax, ymax)
    """
    _x1 = get_float(x1)
    _y1 = get_float(y1)
    _x2 = get_float(x2)
    _y2 = get_float(y2)
    _xmin = get_float(xmin)
    _ymin = get_float(ymin)
    _xmax = get_float(xmax)
    if _xmax &lt; _xmin:
        raise ValueError("Illegal values: xmax &lt; xmin")
    _ymax = get_float(ymax)
    if _ymax &lt; _ymin:
        raise ValueError("Illegal values: ymax &lt; ymin")
    if not ((_x1 &lt; _xmin) or
            (_x1 &gt; _xmax) or
            (_y1 &lt; _ymin) or
            (_y1 &gt; _ymax)):
        return True
    if not ((_x2 &lt; _xmin) or
            (_x2 &gt; _xmax) or
            (_y2 &lt; _ymin) or
            (_y2 &gt; _ymax)):
        return True
    #
    # simple horizontal/vertical testing
    #
    if abs(_y2 - _y1) &lt; 1e-10: # horizontal
        if not ((_y1 &lt; _ymin) or (_y1 &gt; _ymax)):
            if min(_x1, _x2) &lt; _xmin and max(_x1, _x2) &gt; _xmax:
                return True
    if abs(_x2 - _x1) &lt; 1e-10: # vertical
        if not ((_x1 &lt; _xmin) or (_x1 &gt; _xmax)):
            if min(_y1, _y2) &lt; _ymin and max(_y1, _y2) &gt; _ymax:
                return True
    #
    # see if segment intersects an imaginary segment
    # from (xmin, ymax) to (xmax, ymin)
    #
    # p1 = (xmin, ymax)
    # p2 = (xmax, ymin)
    # p3 = (x1, y1)
    # p4 = (x2, y2)
    #
    _d = ((_xmax - _xmin)*(_y2 - _y1)) - ((_ymin - _ymax)*(_x2 - _x1))
    if abs(_d) &gt; 1e-10:
        _n = ((_ymax - _y1)*(_x2 - _x1)) - ((_xmin - _x1)*(_y2 - _y1))
        _r = _n/_d
        if 0.0 &lt; _r &lt; 1.0:
            return True
    #
    # see if segment intersects an imaginary segment
    # from (xmin, ymin) to (xmax, ymax)
    #
    # p1 = (xmin, ymin)
    # p2 = (xmax, ymax)
    # p3 = (x1, y1)
    # p4 = (x2, y2)
    #
    _d = ((_xmax - _xmin)*(_y2 - _y1)) - ((_ymax - _ymin)*(_x2 - _x1))
    if abs(_d) &gt; 1e-10:
        _n = ((_ymin - _y1)*(_x2 - _x1)) - ((_xmin - _x1)*(_y2 - _y1))
        _r = _n/_d
        if 0.0 &lt; _r &lt; 1.0:
            return True
    return False
</t>
<t tx="1.20130426141258.3513">def to_unicode(obj, encoding='utf-8'):
    """
        Transform a string in a different format Default utf-8
    """
    if isinstance(obj, str):
        if not isinstance(obj, str):
            obj =obj.replace('\x00', '').decode(encoding, 'ignore').encode(encoding)
        return obj
    raise TypeError("Invalid object type : " + repr(type(obj)))
</t>
<t tx="1.20130426141258.3514">def getRandomString(lengh=None):
    """
        get a random name 
    """
    random.seed(14)
    if lengh==None:
        lengh=10
    d = [random.choice(string.letters) for x in range(lengh)]
    return "".join(d)
</t>
<t tx="1.20130426141258.3515">def getSegmentNearestPoint(segment, p):
    """
        get the segment nearest end point
    """
    ps1, ps2=segment.getEndpoints()
    dist1=ps1.dist(p)
    dist2=ps2.dist(p)
    if (dist1-dist2&lt;TOL):
        return ps1
    elif(dist1&gt;dist2):
        return ps2
    else:
        return ps1
</t>
<t tx="1.20130426141258.3516">def updateSegment(objSegment,objPoint, objInterPoint):
        """
            Return a segment with trimed to the intersection point
        """
        from Kernel.GeoEntity.segment       import Segment
        from Kernel.GeoEntity.point         import Point
        from Kernel.GeoUtil.geolib          import Vector
        
        objProjection=objSegment.getProjection(objPoint)
        _p1 , _p2 = objSegment.getEndpoints()       
        if not (_p1==objInterPoint or _p2==objInterPoint):
            pickIntVect=Vector(objInterPoint,objProjection).mag()                    
            p1IntVect=Vector(objInterPoint,_p1).mag() 
            if(pickIntVect==p1IntVect):
                arg={"SEGMENT_0":_p1,"SEGMENT_1":objInterPoint}
                return Segment(arg)
            p2IntVect=Vector(objInterPoint,_p2).mag()
            if(pickIntVect==p2IntVect):
                arg={"SEGMENT_0":objInterPoint,"SEGMENT_1":_p2}
                return Segment(arg)
        ldist=objProjection.dist(_p1)
        if ldist&gt;objProjection.dist(_p2):
            arg={"SEGMENT_0":_p1,"SEGMENT_1":objInterPoint}
            return Segment(arg)
        else:
            arg={"SEGMENT_0":objInterPoint,"SEGMENT_1":_p2}
            return Segment(arg)
</t>
<t tx="1.20130426141258.3517">def getIdPoint(value):
    """
        imput must be 10@0,0
        return id,Point
    """
    id, p=value.split('@')
    return id, p
</t>
<t tx="1.20130426141258.3518"></t>
<t tx="1.20130426141258.3519"></t>
<t tx="1.20130426141258.3520">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module PROVIDE ALL GLOBAL VARIABLE NEEDE TO THE SCENE
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3521">from Interface.Entity.point         import Point
from Interface.Entity.segment       import Segment
from Interface.Entity.arc           import Arc
from Interface.Entity.text          import Text
from Interface.Entity.ellipse       import Ellipse
from Interface.Entity.polyline      import Polyline
from Interface.Entity.dimension     import Dimension

from Interface.Dialogs.Widget.widgets import PyCadQColor
from Interface.Dialogs.Widget.widgets import PyCadQLineType
from Interface.Dialogs.Widget.widgets import PyCadQDouble
from Interface.Dialogs.Widget.widgets import PyCadQFont

from PyQt5 import QtCore

from Interface.Command.distance2point import Distance2Point

SCENE_SUPPORTED_TYPE=["SEGMENT",
                      "POINT", 
                        "ARC",
                        "TEXT", 
                        "ELLIPSE", 
                        "POLYLINE", 
                        "DIMENSION"]

SCANE_OBJECT_TYPE=dict(list(zip(SCENE_SUPPORTED_TYPE, 
                       (
                        Segment, 
                        Point, 
                        Arc, 
                        Text, 
                        Ellipse, 
                        Polyline, 
                        Dimension
                       ))))

INTERFACE_COMMAND={'DISTANCE2POINT':Distance2Point}

RESTART_COMMAND_OPTION=True

BACKGROUND_COLOR=(255, 255, 255)

KEY_MAP={
         QtCore.Qt.Key_Delete:'DELETE', 
         QtCore.Qt.Key_L:'SEGMENT', 
         QtCore.Qt.Key_P:'POLYLINE', 
         QtCore.Qt.Key_G:'MOVE', 
         QtCore.Qt.Key_C:'COPY', 
         QtCore.Qt.Key_D:'DELETE', 
         QtCore.Qt.Key_R:'ROTATE', 
         QtCore.Qt.Key_M:'MIRROR'
         }


   
PYTHONCAD_STYLE_WIDGET={'entity_color':PyCadQColor, 
                        'entity_linetype':PyCadQLineType,
                        'entity_thickness':PyCadQDouble, 
                        'text_font':PyCadQFont, 
                        'text_height':PyCadQDouble, 
                        }
PYTHONCAD_STYLE_DESCRIPTION={'entity_color':'Color', 
                        'entity_linetype':'Line Type',
                        'entity_thickness':'Line Ticness', 
                        'text_font':'Font', 
                        'text_height':'Text Height', 
                        }
</t>
<t tx="1.20130426141258.3522">#
#
# Copyright (c) 2010 Matteo Boscolo, Gertwin Groen
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module the graphics scene class
#
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3523">import math, time

from PyQt5 import QtCore, QtGui, QtWidgets

from Generic.application import Application

from Interface.pycadapp             import PyCadApp
from Interface.Entity.base          import BaseEntity
from Interface.Entity.segment       import Segment
from Interface.Entity.arc           import Arc
from Interface.Entity.text          import Text
from Interface.Entity.ellipse       import Ellipse
from Interface.Entity.arrowitem     import ArrowItem
from Interface.Entity.actionhandler import PositionHandler
from Interface.Entity.dinamicentryobject   import DinamicEntryLine
from Interface.cadinitsetting       import *
from Interface.Preview.base         import PreviewBase

from Interface.DrawingHelper.snap import *
from Interface.DrawingHelper.polarguides import GuideHandler

from Kernel.pycadevent              import PyCadEvent
from Kernel.GeoEntity.point         import Point
from Kernel.exception               import *
from Kernel.entity                  import Entity
</t>
<t tx="1.20130426141258.3524">class CadScene(QtWidgets.QGraphicsScene):
    @others
</t>
<t tx="1.20130426141258.3525">def __init__(self, document, parent=None):
    super(CadScene, self).__init__(parent)
    # drawing limits
    self.setSceneRect(-10000, -10000, 20000, 20000)
    # scene custom event
    self.zoomWindows=PyCadEvent()
    self.fireCommandlineFocus=PyCadEvent()
    self.fireKeyShortcut=PyCadEvent()
    self.fireKeyEvent=PyCadEvent()
    self.fireWarning=PyCadEvent()
    self.fireCoords=PyCadEvent()
    #fire Pan and Zoom events to the view
    self.firePan=PyCadEvent()
    self.fireZoomFit=PyCadEvent()
    self.__document=document
    self.needPreview=False
    self.forceDirectionEnabled=False
    self.forceDirection=None
    self.__lastPickedEntity=None
    self.isInPan=False
    self.forceSnap=None
    self._cmdZoomWindow=None
    self.showHandler=False
    self.posHandler=None
    #
    # new command implementation
    #
    self.__activeKernelCommand=None
    self.activeICommand=None
    #
    self.__grapWithd=20.0
    #
    # Input implemetation by carlo
    #
    self.fromPoint=None #frompoint is assigned in icommand.getClickedPoint() and deleted by applycommand and cancelcommand, is needed for statusbar coordinates dx,dy
    self.selectionAddMode=False

    # Init loading of snap marks
    self.initSnap()

    # Init loading of guides
    self.isGuided=None
    self.isGuideLocked=None
    self.initGuides()

    # scene aspect
    r, g, b=BACKGROUND_COLOR #defined in cadinitsetting
    self.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(r, g, b), QtCore.Qt.SolidPattern))
</t>
<t tx="1.20130426141258.3526">def initSnap(self):
    # Init loading of snap marks
    self.snappingPoint=SnapPoint(self)
    self.endMark=SnapEndMark(0.0, 0.0)
    self.addItem(self.endMark)
</t>
<t tx="1.20130426141258.3527">def initGuides(self):
    self.GuideHandler=GuideHandler(self, 0.0, 0.0,0.0 )
    self.addItem(self.GuideHandler)
    self.GuideHandler.reset()
</t>
<t tx="1.20130426141258.3528">@property
def activeKernelCommand(self):
    """
        return the active command
    """
    return self.__activeKernelCommand
</t>
<t tx="1.20130426141258.3529">@activeKernelCommand.setter
def activeKernelCommand(self, value):
    self.__activeKernelCommand=value
</t>
<t tx="1.20130426141258.3530">def setActiveSnap(self, value):
    if self.activeICommand!=None:
        self.activeICommand.activeSnap=value
        self.snappingPoint.activeSnap=value
</t>
<t tx="1.20130426141258.3531">def _qtInputPopUpReturnPressed(self):
    self.forceDirection="F"+self.qtInputPopUp.text
</t>
<t tx="1.20130426141258.3532"># ###############################################MOUSE EVENTS
# ##########################################################

def mouseMoveEvent(self, event):
    scenePos=event.scenePos()
    mouseOnSceneX=scenePos.x()
    mouseOnSceneY=scenePos.y()*-1.0
    self.geoMousePointOnScene=Point(mouseOnSceneX,mouseOnSceneY)
    #
    # This event manages middle mouse button PAN
    #
    if self.isInPan:
        self.firePan(None, event.scenePos())
    #
    #This event manages the status bar coordinates display (relative or absolute depending on self.fromPoint)
    #
    else:
        if self.fromPoint==None:
            self.fireCoords(mouseOnSceneX, mouseOnSceneY, "abs")
        else:
            x=mouseOnSceneX-self.fromPoint.getx()
            y=mouseOnSceneY-self.fromPoint.gety()
            self.fireCoords(x, y, "rel")
    #
    #This seems needed to preview commands
    #
    ps=self.geoMousePointOnScene
    if self.activeICommand:
        #SNAP PREVIEW
        if self.activeKernelCommand.activeException()==ExcPoint or self.activeKernelCommand.activeException()==ExcLenght:
            item=self.activeICommand.getEntity(ps)
            if item:
                ps=self.snappingPoint.getSnapPoint(self.geoMousePointOnScene, item)
                if ps!=self.geoMousePointOnScene:
                    self.endMark.move(ps.getx(), ps.gety()*-1.0)
            else:
                self.hideSnapMarks()
        #qtItem=[self.itemAt(scenePos)] # old
        qtItem = [self.itemAt(scenePos, QtGui.QTransform())]
        self.activeICommand.updateMauseEvent(ps, qtItem)
    super(CadScene, self).mouseMoveEvent(event)
    return
</t>
<t tx="1.20130426141258.3533">def mousePressEvent(self, event):
    if event.button()==QtCore.Qt.MidButton:
        self.isInPan=True
        self.firePan(True, event.scenePos())
    if not self.isInPan:
        #qtItem=self.itemAt(event.scenePos())
        qtItem = self.itemAt(event.scenePos(), QtGui.QTransform())
        if qtItem:
            qtItem.setSelected(True)
            self.updateSelected()
            if event.button()==QtCore.Qt.RightButton:
                self.showContextMenu(qtItem, event)
    super(CadScene, self).mousePressEvent(event)
</t>
<t tx="1.20130426141258.3534">def mouseReleaseEvent(self, event):
    if event.button()==QtCore.Qt.MidButton:
        self.isInPan=False
        self.firePan(False, None)
    if not self.isInPan:
        self.updateSelected()
        if self.activeICommand:
            if event.button()==QtCore.Qt.RightButton:
                try:
                    self.activeICommand.applyDefault()
                except PyCadWrongImputData:
                    self.fireWarning("Wrong input value")
            if event.button()==QtCore.Qt.LeftButton:
                point=Point(event.scenePos().x(), event.scenePos().y()*-1.0)
                qtItems=[item for item in self.selectedItems() if isinstance(item, BaseEntity)]
                if self.showHandler:
                    if self.posHandler==None:
                        self.posHandler=PositionHandler(event.scenePos())
                        self.addItem(self.posHandler)
                    else:
                        self.posHandler.show()
                # fire the mouse to the ICommand class
                self.activeICommand.addMauseEvent(point=point,
                                                entity=qtItems,
                                                force=self.forceDirection)
        else:
            self.hideHandler()

    if self._cmdZoomWindow:
        self.zoomWindows(self.selectionArea().boundingRect())
        self._cmdZoomWindow=None
        self.clearSelection() #clear the selection after the window zoom, why? because zoom windows select entities_&gt;that's bad

    super(CadScene, self).mouseReleaseEvent(event)
    return
</t>
<t tx="1.20130426141258.3535">def showContextMenu(self, selectedQtItems, event):
    """
        show a context menu
    """
    def delete():
        self.fireKeyShortcut('DELETE')

    def property():
        self.fireKeyShortcut('PROPERTY')

    contexMenu=QtWidgets.QMenu()
    # Create Actions
    removeAction=contexMenu.addAction("Delete")
    removeAction.triggered.connect(delete)

    propertyAction=contexMenu.addAction("Property")
    propertyAction.triggered.connect(property)
    contexMenu.exec_(event.screenPos())
    del(contexMenu)
</t>
<t tx="1.20130426141258.3536">def hanhlerDoubleClick(self):
    """
        event add from the handler
    """
    point=Point(self.posHandler.scenePos.x(), self.posHandler.scenePos.y()*-1.0)
    self.activeICommand.addMauseEvent(point=point,
                                        distance=self.posHandler.distance,
                                        angle=self.posHandler.angle)
    self.hideHandler()
</t>
<t tx="1.20130426141258.3537">def hideHandler(self):
    """
        this function is used to hide the handler
    """
    if self.posHandler!=None:
        self.posHandler.hide()
</t>
<t tx="1.20130426141258.3538">def hideSnapMarks(self):
    """
        this function is used to hide the handler
    """
    self.endMark.hide()
</t>
<t tx="1.20130426141258.3539">def mouseDoubleClickEvent(self, event):
    if event.button()==QtCore.Qt.MidButton:
        self.fireZoomFit()
    else:
        return QtWidgets.QGraphicsScene.mouseDoubleClickEvent(self, event)
</t>
<t tx="1.20130426141258.3540">def cancelCommand(self):
    """
        cancel the active command
    """
    self.clearSelection()
    self.updateSelected()
    #self.forceDirection=None
    self.__activeKernelCommand=None
    self.activeICommand=None
    self.showHandler=False
    self.clearPreview()
    self.hideSnapMarks()
    self.fromPoint=None
    self.GuideHandler.reset()
</t>
<t tx="1.20130426141258.3541"># ################################################# KEY EVENTS
# ##########################################################

def keyPressEvent(self, event):
    if event.key()==QtCore.Qt.Key_Return:
        if self.activeICommand!=None:
            self.activeICommand.applyCommand()
    elif event.key()==QtCore.Qt.Key_Escape:
        self.cancelCommand()
    elif event.key()==QtCore.Qt.Key_Space:
        self.fireCommandlineFocus(self, event)
    elif event.key()==QtCore.Qt.Key_Shift:
        if self.isGuided==True:
            self.isGuideLocked=True
            print("GUIDE LOCKED")
        else:
            self.selectionAddMode=True

\\-4.#        elif event.key()==QtCore.Qt.Key_F8:  &lt;&lt;&lt;&lt;this must maybe be implemented in cadwindow
\\-4.#            if self.forceDirection is None:
\\-4.#                self.forceDirection=True
\\-4.#            else:
\\-4.#                self.forceDirection=None
\\-4.#            print self.forceDirection
\\-4.#            self.forceDirection='H'        &lt;&lt;&lt;&lt;&lt;&lt;&lt;H and V are substituted by ortho mode, for future implementations it could be nice if shift pressed locks the direction of the mouse pointer
\\-4.#        elif event.key()==QtCore.Qt.Key_V:  &lt;&lt;&lt;Ortho mode should be rewritten allowing to enter step angles and snap direction
\\-4.#            self.forceDirection='V'
    elif event.key()==QtCore.Qt.Key_Q: #Maybe we could use TAB
        self.showHandler=True
    else:
        if self.activeICommand!=None:
            self.fireCommandlineFocus(self, event)
            self.fireKeyEvent(event)
        elif event.key() in KEY_MAP:
                #exec(KEY_MAP[event.key()])
                self.fireKeyShortcut(KEY_MAP[event.key()])
    super(CadScene, self).keyPressEvent(event)
</t>
<t tx="1.20130426141258.3542">def keyReleaseEvent(self, event):
    if event.key()==QtCore.Qt.Key_Shift:
\\-4.#            if self.activeICommand!=None:
\\-4.#                if self.activeKernelCommand.activeException()==ExcMultiEntity:
        if self.isGuided==True:
            self.isGuideLocked=None
            self.isGuided=None
            self.GuideHandler.hideGuides()
        else:
            self.selectionAddMode=False
    else:
        pass
</t>
<t tx="1.20130426141258.3543">def textInput(self, value):
    """
        someone give some test imput at the scene
    """
    if self.activeICommand!=None:
        #self.forceDirection=None # reset force direction for the imput value
        self.updateSelected()
        self.activeICommand.addTextEvent(value)
    return
</t>
<t tx="1.20130426141258.3544">def updateSelected(self):
    """
        update all the selected items
    """
    for item in self.selectedItems():
        item.updateSelected()
</t>
<t tx="1.20130426141258.3545">def clearPreview(self):
    """
        remove the preview items from the scene
    """
    entitys=[item for item in list(self.items()) if isinstance(item, PreviewBase)]
    for ent in entitys:
        self.removeItem(ent)
</t>
<t tx="1.20130426141258.3546">def initDocumentEvents(self):
    """
        Initialize the document events.
    """
    if not self.__document is None:
        self.__document.showEntEvent        += self.eventShow
        self.__document.updateShowEntEvent  += self.eventUpdate
        self.__document.deleteEntityEvent   += self.eventDelete
        self.__document.massiveDeleteEvent  += self.eventMassiveDelete
        self.__document.undoRedoEvent       += self.eventUndoRedo
        self.__document.hideEntEvent        += self.eventDelete
</t>
<t tx="1.20130426141258.3547">def populateScene(self, document):
    """
        Traverse all entities in the document and add these to the scene.
    """
    entities = self.__document.getEntityFromType(SCENE_SUPPORTED_TYPE)
    for entity in entities:
        self.addGraficalObject(entity)
</t>
<t tx="1.20130426141258.3548">def addGraficalObject(self, entity):
    """
        Add the single object
    """
    newQtEnt=None
    entityType=entity.getEntityType()
    if entityType in SCENE_SUPPORTED_TYPE:
        newQtEnt=SCANE_OBJECT_TYPE[entityType](entity)
        self.addGraficalItem(newQtEnt)
</t>
<t tx="1.20130426141258.3549">def addGraficalItem(self, qtItem):
    """
        add item to the scene
    """
    if qtItem!=None:
        self.addItem(qtItem)
</t>
<t tx="1.20130426141258.3550">def eventUndoRedo(self, document, entity):
    """
        Manage the undo redo event
    """
    self.clear()
    self.populateScene(document)
    self.initSnap()
    self.initGuides()
</t>
<t tx="1.20130426141258.3551">def eventShow(self, document, entity):
    """
        Manage the show entity event
    """
    self.addGraficalObject(entity)
</t>
<t tx="1.20130426141258.3552">def eventUpdate(self, document, entity):
    """
        Manage the Update entity event
    """
    self.updateItemsFromID([entity])
</t>
<t tx="1.20130426141258.3553">def eventDelete(self, document, entity):
    """
        Manage the Delete entity event
    """
    #import time
    #startTime=time.clock()
    self.deleteEntity([entity])
    #endTime=time.clock()-startTime
    #print "eventDelete in %s"%str(endTime)
</t>
<t tx="1.20130426141258.3554">def eventMassiveDelete(self, document,  entitys):
    """
        Massive delete of all entity event
    """
    #import time
    #startTime=time.clock()
    self.deleteEntity(entitys)
    #endTime=time.clock()-startTime
    #print "eventDelete in %s"%str(endTime)
</t>
<t tx="1.20130426141258.3555">def deleteEntity(self, entitys):
    """
        delete the entity from the scene
    """
    dicItems=dict([( item.ID, item)for item in list(self.items()) if isinstance(item, BaseEntity)])
    for ent in entitys:
        if ent.eType!="LAYER":
            itemId=ent.getId()
            if itemId in dicItems:
                self.removeItem(dicItems[itemId])
</t>
<t tx="1.20130426141258.3556">def getEntFromId(self, id):
    """
        get the grafical entity from an id
    """
    dicItems=dict([( item.ID, item)for item in list(self.items()) if isinstance(item, BaseEntity) and item.ID==id])
    if len(dicItems)&gt;0:
        return dicItems[0][1]
    return None
</t>
<t tx="1.20130426141258.3557">def updateItemsFromID(self,entitys):
    """
        Update the scene from the Entity []
    """
    dicItems=self.getAllBaseEntity()
    for ent in entitys:
        if ent.getId() in dicItems:
            self.removeItem(dicItems[ent.getId()])
            self.addGraficalObject(ent)
</t>
<t tx="1.20130426141258.3558">def getAllBaseEntity(self):
    """
        get all the base entity from the scene
    """
    return dict([( item.ID, item)for item in list(self.items()) if isinstance(item, BaseEntity)])
</t>
<t tx="1.20130426141258.3559">def updateItemsFromID_2(self,entities):
    """
        update the scene from the Entity []
    """
    ids=[ent.getId() for ent in entities]
    items=[item for item in list(self.items()) if item.ID in ids]
    for item in items:
            self.removeItem(item)
    for ent in entities:
            self.addGraficalObject(ent)
</t>
<t tx="1.20130426141258.3560">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3561">import math
from PyQt5 import QtCore, QtGui, QtWidgets

from Interface.Entity.base import *
from Interface.Preview.base import *
</t>
<t tx="1.20130426141258.3562">class CadView(QtWidgets.QGraphicsView):
    @others
</t>
<t tx="1.20130426141258.3563">def __init__(self, scene, parent=None):
    super(CadView, self).__init__(scene, parent)
    self.scaleFactor=1
    self.controlPress=False
    self.setDragMode(QtWidgets.QGraphicsView.RubberBandDrag)
    self.setResizeAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

    #handle mouse midbutton pan and zoom
    scene.fireZoomFit+=self.fit
    scene.firePan+=self.Pan
    self.firstPanPoint=QtCore.QPointF()
</t>
<t tx="1.20130426141258.3564">def Pan(self, panActive, eventPoint):

    if panActive==True:
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.firstPanPoint=eventPoint
    elif panActive==False:
        self.firstPanPoint=None
        self.setDragMode(QtWidgets.QGraphicsView.RubberBandDrag)
    else:
        if self.controlPress==False:
            c=QtCore.QPoint((self.width()/2-10), (self.height()/2-10))
            cOnScene=self.mapToScene(c)
            vector=self.firstPanPoint-eventPoint
            newC=cOnScene+vector
            self.centerOn(newC)
</t>
<t tx="1.20130426141258.3565">def wheelEvent(self, event):
    #get the center of the view in scene coordinates
    c=QtCore.QPoint((self.width()/2.0)-10, (self.height()/2.0)-10)
    cOnScene=self.mapToScene(c)
    #get the mouse position in scene coordinates
    pOnView=event.pos()
    pOnScene=self.mapToScene(pOnView)
    #old command
    self.scaleFactor=math.pow(2.0,event.angleDelta().y() / 240.0)
    self.scaleView(self.scaleFactor)
\\-4.#       self.updateShape()  &lt;&lt;&lt;prova


    #get the modified position due to occurred zoom
    newPOnScene=self.mapToScene(pOnView)
    #get the vector to move the modified position in the old position
    vector=pOnScene-newPOnScene
    #set a new center to maintain mouse position referred to the scene
    newC=cOnScene+vector
    self.centerOn(newC)
    #self.scaleFactor=math.pow(2.0,-event.delta() / 240.0)
    #self.scaleView(self.scaleFactor)
    self.updateShape()   # &lt;&lt;&lt;prova
</t>
<t tx="1.20130426141258.3566">def keyPressEvent(self, event):
    if event.key()==QtCore.Qt.Key_Control:
        self.controlPress=True
        self.scene().isInPan=True
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
    super(CadView, self).keyPressEvent(event)
</t>
<t tx="1.20130426141258.3567">def keyReleaseEvent(self, event):
    self.controlPress=False
    self.scene().isInPan=False
    self.setDragMode(QtWidgets.QGraphicsView.RubberBandDrag)
    super(CadView, self).keyReleaseEvent(event)
</t>
<t tx="1.20130426141258.3568">def fit(self):
    """
        fit all the item in the view
    """
    boundingRectangle=[item.boundingRect() for item in list(self.scene().items()) if isinstance(item, BaseEntity)]
    qRect=None
    for bound in boundingRectangle:
        if not qRect:
            qRect=bound
        else:
            qRect=qRect.united(bound)
    if qRect:
        self.zoomWindows(qRect)
        self.updateShape()
</t>
<t tx="1.20130426141258.3569">def centerOnSelection(self):
    """
        center the view on selected item
    """
    #TODO: if the item is in the border the centerOn will not work propely
    #more info at :http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qgraphicsview.html#ViewportAnchor-enum
    for item in self.scene().selectedItems():
        self.centerOn(item)
        return
</t>
<t tx="1.20130426141258.3570">def zoomWindows(self, qRect):
    """
        perform a windows zoom
    """
    zb=self.scaleFactor
    qRect.setX(qRect.x()-zb)
    qRect.setY(qRect.y()-zb)
    qRect.setWidth(qRect.width()+zb)
    qRect.setHeight(qRect.height()+zb)
    self.fitInView(qRect,1) # KeepAspectRatioByExpanding
    self.updateShape()
</t>
<t tx="1.20130426141258.3571">def scaleView(self, factor):
    self.scale(factor, factor)
</t>
<t tx="1.20130426141258.3572">def updateShape(self):
    """
        update the item shape tickness
    """
    #matrixScaleFactor=self.matrix().m11() # old
    matrixScaleFactor = self.transform().m11()
    if matrixScaleFactor&lt;0.001:
        matrixScaleFactor=0.001
    val=(1.0/matrixScaleFactor)*10
    BaseEntity.shapeSize=val
    PreviewBase.shapeSize=val
</t>
<t tx="1.20130426141258.3573">############################################################################
#
#  Copyright (C) 2004-2005 Trolltech AS. All rights reserved.
#
#  This file is part of the example classes of the Qt Toolkit.
#
#  This file may be used under the terms of the GNU General Public
#  License version 2.0 as published by the Free Software Foundation
#  and appearing in the file LICENSE.GPL included in the packaging of
#  this file.  Please review the following information to ensure GNU
#  General Public Licensing requirements will be met:
#  http://www.trolltech.com/products/qt/opensource.html
#
#  If you are unsure which license is appropriate for your use, please
#  review the following information:
#  http://www.trolltech.com/products/qt/licensing.html or contact the
#  sales department at sales@trolltech.com.
#
#  This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
#  WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
############################################################################

# This is only needed for Python v2 but is harmless for Python v3.

#import sip
#sip.setapi('QString', 2)


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3574">import os
import sys

from PyQt5 import QtCore, QtGui, QtPrintSupport, QtWidgets

from . import cadwindow_rc

from Generic.application            import Application

#Interface
from Interface.LayerIntf.layerdock  import LayerDock
from Interface.cadscene             import CadScene
from Interface.cadview              import CadView
from Interface.idocument            import IDocument
from Interface.CmdIntf.cmdintf      import CmdIntf
from Interface.Entity.base          import BaseEntity
from Interface.Command.icommand     import ICommand
from Interface.cadinitsetting       import *
from Interface.Dialogs.preferences  import Preferences
#Kernel
from Kernel.exception               import *
from Kernel.initsetting             import * #SNAP_POINT_ARRAY, ACTIVE_SNAP_POINT


from Interface.DrawingHelper.polarguides import getPolarMenu
</t>
<t tx="1.20130426141258.3575">class CadWindowMdi(QtWidgets.QMainWindow):
    @others
</t>
<t tx="1.20130426141258.3576">def __init__(self):
    super(CadWindowMdi, self).__init__()
    self.mdiArea = QtWidgets.QMdiArea()
    self.mdiArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
    self.mdiArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
    self.setCentralWidget(self.mdiArea)
    self.mdiArea.subWindowActivated.connect(self.subWindowActivatedEvent)
    self.oldSubWin=None
\\-4.#        self.readSettings() #now works for position and size, support for toolbars is still missing(http://www.opendocs.net/pyqt/pyqt4/html/qsettings.html)
    self.setWindowTitle("PythonCAD")
    qIcon=self._getIcon('pythoncad')
    if qIcon:
        self.setWindowIcon(qIcon)
    self.setUnifiedTitleAndToolBarOnMac(True)
    #pythoncad kernel
    self.__application = Application()
    self.__cmd_intf = CmdIntf(self)
    #self.__cmd_intf.FunctionHandler.commandExecuted+=self.commandExecuted
    # create all dock windows
    self._createDockWindows()
    # create status bar
    self._createStatusBar()
    self.setUnifiedTitleAndToolBarOnMac(True)
    self._registerCommands()
    self.updateMenus()
    self.lastDirectory=os.getenv('USERPROFILE') or os.getenv('HOME')

    self.readSettings() #now works for position and size and ismaximized, and finally toolbar position
    return
</t>
<t tx="1.20130426141258.3577">@property
def scene(self):
    if self.mdiArea.activeSubWindow():
        return self.mdiArea.activeSubWindow().scene
</t>
<t tx="1.20130426141258.3578">@property
def view(self):
    if self.mdiArea.activeSubWindow():
        return self.mdiArea.activeSubWindow().view
</t>
<t tx="1.20130426141258.3579">@property
def Application(self):
    """
        get the kernel application object
    """
    return self.__application
</t>
<t tx="1.20130426141258.3580">@property
def LayerDock(self):
    """
        get the layer tree dockable window
    """
    return self.__layer_dock
</t>
<t tx="1.20130426141258.3581"># ###############################################STATUSBAR
# ##########################################################

def _createStatusBar(self):
    '''
        Creates the statusbar object.
    '''

    self.statusBar().showMessage("Ready")

    #------------------------------------------------------------------------------------Create status buttons

    #Force Direction
    self.forceDirectionStatus=statusButton('SForceDir.png', 'Orthogonal Mode [right click will in the future set increment constrain angle]')
    self.forceDirectionStatus.clicked.connect(self.setForceDirection)
    self.forceDirectionStatus.setMenu(getPolarMenu())
    self.statusBar().addPermanentWidget(self.forceDirectionStatus)


    #Snap
    self.SnapStatus=statusButton('SSnap.png', 'Snap [right click displays snap list]\n for future implementation it should be a checkist')
    self.SnapStatus.clicked.connect(self.setSnapStatus)
    self.SnapStatus.setMenu(self.__cmd_intf.Category.getMenu(6))
    self.SnapStatus.setChecked(True)
    self.statusBar().addPermanentWidget(self.SnapStatus)


    #Grid
    self.GridStatus=statusButton('SGrid.png', 'Grid Mode [not available yet]')
    self.GridStatus.clicked.connect(self.setGrid)
    self.statusBar().addPermanentWidget(self.GridStatus)

    #------------------------------------------------------------------------------------Set coordinates label on statusbar (updated by idocumet)
    self.coordLabel=QtWidgets.QLabel("x=0.000\ny=0.000")
    self.coordLabel.setAlignment(QtCore.Qt.AlignVCenter)
    self.coordLabel.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)
    self.coordLabel.setMinimumWidth(80)
    self.coordLabel.setMaximumHeight(20)
    self.coordLabel.setFont(QtGui.QFont("Sans", 6))
    self.statusBar().addPermanentWidget(self.coordLabel)
</t>
<t tx="1.20130426141258.3582">def setForceDirection(self):
    if self.forceDirectionStatus.isChecked():
        self.scene.forceDirectionEnabled=True
        self.forceDirectionStatus.setFocus(False)
        if self.scene.activeICommand!=None and self.scene.fromPoint!=None:
            self.scene.GuideHandler.show()
    else:
        self.scene.forceDirectionEnabled=False
        self.scene.GuideHandler.hide()
</t>
<t tx="1.20130426141258.3583">def setSnapStatus(self):
    if self.SnapStatus.isChecked():
        self.scene.snappingPoint.activeSnap=SNAP_POINT_ARRAY['LIST']
    else:
        self.scene.snappingPoint.activeSnap=SNAP_POINT_ARRAY['NONE']
</t>
<t tx="1.20130426141258.3584">def setGrid(self):
    pass
</t>
<t tx="1.20130426141258.3585"># ###############################################END STATUSBAR
# ##########################################################

def commandExecuted(self):
    self.resetCommand()
</t>
<t tx="1.20130426141258.3586">def _createDockWindows(self):
    '''
        Creates all dockable windows for the application
    '''
    # commandline
    command_dock = self.__cmd_intf.commandLine
    # if the commandline exists, add it
    if not command_dock is None:
        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, command_dock)
    return
</t>
<t tx="1.20130426141258.3587">def closeEvent(self, event):
    """
        manage close event
    """
    self.mdiArea.closeAllSubWindows()
    if self.activeMdiChild():
        event.ignore()
    else:
        self.writeSettings()
        event.accept()
</t>
<t tx="1.20130426141258.3588">def subWindowActivatedEvent(self):
    """
        Sub windows activation
    """
    if self.mdiArea.activeSubWindow():
        if (self.mdiArea.activeSubWindow().document!=
                    self.__application.ActiveDocument):
            self.resetCommand()
            self.__application.ActiveDocument=self.mdiArea.activeSubWindow().document
    self.updateMenus()
</t>
<t tx="1.20130426141258.3589">def resetCommand(self):
    """
        Resect the active command
    """
    self.__cmd_intf.resetCommand()
    if self.scene!=None:
        self.scene.cancelCommand()
    self.statusBar().showMessage("Ready")
</t>
<t tx="1.20130426141258.3590"># ################################# SET if ICON AND MENU are ENABLED
# ##########################################################
def updateMenus(self):
    """
        update menu status
    """
    hasMdiChild = (self.activeMdiChild() is not None)
    #File
    self.__cmd_intf.setVisible('import', hasMdiChild)
    self.__cmd_intf.setVisible('saveas', hasMdiChild)
    self.__cmd_intf.setVisible('close', hasMdiChild)
    self.__cmd_intf.setVisible('print', hasMdiChild)
    #Edit
    self.__cmd_intf.setVisible('undo', hasMdiChild)
    self.__cmd_intf.setVisible('redo', hasMdiChild)
    self.__cmd_intf.setVisible('copy', hasMdiChild)
    self.__cmd_intf.setVisible('move', hasMdiChild)
    self.__cmd_intf.setVisible('delete', hasMdiChild)
    self.__cmd_intf.setVisible('mirror', hasMdiChild)
    self.__cmd_intf.setVisible('rotate', hasMdiChild)
    self.__cmd_intf.setVisible('trim', hasMdiChild)
    self.__cmd_intf.setVisible('property', hasMdiChild)
    #Draw
    self.__cmd_intf.setVisible('point', hasMdiChild)
    self.__cmd_intf.setVisible('segment', hasMdiChild)
    self.__cmd_intf.setVisible('rectangle', hasMdiChild)
    self.__cmd_intf.setVisible('polyline', hasMdiChild)
    self.__cmd_intf.setVisible('circle', hasMdiChild)
    self.__cmd_intf.setVisible('arc', hasMdiChild)
    self.__cmd_intf.setVisible('ellipse', hasMdiChild)
    self.__cmd_intf.setVisible('polygon', hasMdiChild)
    self.__cmd_intf.setVisible('fillet', hasMdiChild)
    self.__cmd_intf.setVisible('chamfer', hasMdiChild)
    self.__cmd_intf.setVisible('bisect', hasMdiChild)
    self.__cmd_intf.setVisible('text', hasMdiChild)
    #Dimension
    self.__cmd_intf.setVisible('dimension', hasMdiChild)
    #View
    self.__cmd_intf.setVisible('fit', hasMdiChild)
    self.__cmd_intf.setVisible('zoomwindow', hasMdiChild)
    self.__cmd_intf.setVisible('zoomitem', hasMdiChild)
    #snap
    self.__cmd_intf.setVisible('snapauto', hasMdiChild)
    self.__cmd_intf.setVisible('snapend', hasMdiChild)
    self.__cmd_intf.setVisible('snapmid', hasMdiChild)
    self.__cmd_intf.setVisible('snapcen', hasMdiChild)
    self.__cmd_intf.setVisible('snapper', hasMdiChild)
    self.__cmd_intf.setVisible('snaptan', False)
    self.__cmd_intf.setVisible('snapqua', hasMdiChild)
    self.__cmd_intf.setVisible('snap00', hasMdiChild)
    self.__cmd_intf.setVisible('snapint', hasMdiChild)
    #Tools
    self.__cmd_intf.setVisible('info2p', hasMdiChild)
    #window
    self.__cmd_intf.setVisible('tile', hasMdiChild)
    self.__cmd_intf.setVisible('cascade', hasMdiChild)
    self.__cmd_intf.setVisible('next', hasMdiChild)
    self.__cmd_intf.setVisible('previous', hasMdiChild)
    #hasSelection = (self.activeMdiChild() is not None and
    #                self.activeMdiChild().textCursor().hasSelection())
    #self.cutAct.setEnabled(hasSelection)
    #self.copyAct.setEnabled(hasSelection)

    #StatusBAR Satus Tools
    self.forceDirectionStatus.setEnabled(hasMdiChild)
    self.GridStatus.setEnabled(hasMdiChild)
    self.SnapStatus.setEnabled(hasMdiChild)
</t>
<t tx="1.20130426141258.3591">def createMdiChild(self, file=None):
    """
        Create new IDocument
    """
    if file:
        newDoc=self.__application.openDocument(file)
    else:
        newDoc=self.__application.newDocument()
    for mdiwind in self.mdiArea.subWindowList():
        if mdiwind._IDocument__document.dbPath==file:
            child=mdiwind
            break
    else:
        child = IDocument(newDoc,self.__cmd_intf, self)
        self.mdiArea.addSubWindow(child)

    #child.copyAvailable.connect(self.cutAct.setEnabled)
    #child.copyAvailable.connect(self.copyAct.setEnabled)
    return child
</t>
<t tx="1.20130426141258.3592">#def setAppDocActiveOnUi(self, doc):
#    self.mdiArea.

def _registerCommands(self):
    '''
        Register all commands that are handed by this object
    '''
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'new', '&amp;New Drawing', self._onNewDrawing)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'open', '&amp;Open Drawing...', self._onOpenDrawing)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'import', '&amp;Import Drawing...', self._onImportDrawing)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'saveas', '&amp;Save As...', self._onSaveAsDrawing)
    #
    # Create recentFile structure
    #
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, '-')

    i=0
    for file in self.Application.getRecentFiles:
        fileName=self.strippedName(file)
        self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'file_'+str(i), fileName, self._onOpenRecent)
        i+=1
    #
    # separator
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'close', '&amp;Close', self._onCloseDrawing)
    # separator
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'print', '&amp;Print', self._onPrint)
    # separator
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.File, 'quit', '&amp;Quit', self.close)
    # Edit
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Edit, 'undo', '&amp;Undo', self._onUndo)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Edit, 'redo', '&amp;Redo', self._onRedo)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Edit, 'property', '&amp;Property', self._onProperty)

    # separator
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Edit, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Edit, 'preferences', '&amp;User Preferences', self.preferences)
    #Modify
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'copy', '&amp;Copy', self._onCopy)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'move', '&amp;Move', self._onMove)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'rotate', '&amp;Rotate', self._onRotate)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'mirror', '&amp;Mirror', self._onMirror)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'delete', '&amp;Delete', self._onDelete)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Modify, 'trim', '&amp;Trim', self._onTrim)
    # Draw
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'point', '&amp;Point', self._onPoint)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'segment', '&amp;Segment', self._onSegment)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'rectangle', '&amp;Rectangle', self._onRectangle)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'polyline', '&amp;Polyline', self._onPolyline)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'circle', '&amp;Circle', self._onCircle)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'arc', '&amp;Arc', self._onArc)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'ellipse', '&amp;Ellipse', self._onEllipse)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'polygon', '&amp;Polygon', self._onPolygon)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'fillet', '&amp;Fillet', self._onFillet)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'chamfer', '&amp;Chamfer', self._onChamfer)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'bisect', '&amp;Bisect', self._onBisect)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Draw, 'text', '&amp;Text', self._onText)
    #   Dimension
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Dimension, 'dimension', '&amp;Aligned Dimension', self._onDimension)
    # View
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.View, 'fit', '&amp;Fit', self._onFit)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.View, 'zoomwindow', 'Zoom&amp;Window', self._onZoomWindow)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.View, 'zoomitem', 'Zoom&amp;Item',self._onCenterItem)
    # Snap
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapauto', 'Automatic Snap', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapend', 'End', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapmid', 'Middle', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapint', 'Intersection', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapper', 'Perpendicular', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapcen', 'Center', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snapqua', 'Quadrant', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snaptan', 'Tangent', self._onSnapCommand)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, '-')
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Snap, 'snap00', 'Origin', self._onSnapCommand)

    #Tools
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Tools, 'info2p', 'Info Two Points', self._onInfo2p)

    #--menu: Windows
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Windows, 'tile', '&amp;Tile', self._onTile)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Windows, 'cascade', '&amp;Cascade', self._onCascade)

    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Windows, 'next', 'Ne&amp;xt', self.mdiArea.activateNextSubWindow)
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Windows, 'previous', 'Pre&amp;vious', self.mdiArea.activatePreviousSubWindow)

    # Help
    self.__cmd_intf.registerCommand(self.__cmd_intf.Category.Help, 'about', '&amp;About PythonCAD', self._onAbout)
    return
</t>
<t tx="1.20130426141258.3593">def updateRecentFileList(self):
    """
        update the menu recent file list
    """
    i=0
    for file in self.Application.getRecentFiles:
        fileName=self.strippedName(file)
        self.__cmd_intf.updateText('file_'+str(i), fileName)
        i+=1
</t>
<t tx="1.20130426141258.3594">def strippedName(self, fullFileName):
    """
        get only the name of the filePath
    """
    # 正確取得 stripped file name
    return QtCore.QFileInfo(fullFileName).fileName()
</t>
<t tx="1.20130426141258.3595"># ##########################################              ON COMMANDS
# ##########################################################

def _onNewDrawing(self):
    '''
        Create a new drawing
    '''
    child = self.createMdiChild()
    child.show()
    self.updateRecentFileList()
    return
</t>
<t tx="1.20130426141258.3596">def _onOpenDrawing(self):
    '''
        Open an existing drawing PDR or DXF
    '''
    # ask the user to select an existing drawing
    # 可以正確打開檔案
    drawing = QtWidgets.QFileDialog.getOpenFileName(parent=self,directory=self.lastDirectory,  caption ="Open Drawing", filter ="Drawings (*.pdr *.dxf)")[0]
    # open a document and load the drawing
    print("drawing is:", drawing)
    if len(drawing)&gt;0:
        self.lastDirectory=os.path.split(drawing)[0]
        (name, extension)=os.path.splitext(drawing)
        if extension.upper()=='.DXF':
            child = self.createMdiChild()
            child.importExternalFormat(drawing)
        elif extension.upper()=='.PDR':
            child = self.createMdiChild(drawing)
        else:
            self.critical("Wrong command selected")
            return
        child.show()
        self.updateRecentFileList()
        self.view.fit()
    return
</t>
<t tx="1.20130426141258.3597">def _onImportDrawing(self):
    '''
        Import existing drawing in current drawing (some issues with PyQt4.7)
    '''
    drawing = QtWidgets.QFileDialog.getOpenFileName(parent=self, caption="Import Drawing", directory=self.lastDirectory, filter="Dxf (*.dxf)");[0]
    # open a document and load the drawing
    if len(drawing)&gt;0:
        self.lastDirectory=os.path.split(drawing)[0]
        self.mdiArea.activeSubWindow().importExternalFormat(drawing)
    return
</t>
<t tx="1.20130426141258.3598">def _onOpenRecent(self):
    """
        on open recent file
    """
    #FIXME: if in the command line we insert file_1 or file_2
    #here we get en error action dose not have command attributes
    # action is en edit command not an action and have an empty value
    action = self.sender()
    if action:
        spool, index=action.command.split('_')
        fileName=self.Application.getRecentFiles[int(index)]
        if len(fileName)&gt;0:
            child = self.createMdiChild(fileName)
            child.show()
            self.updateRecentFileList()
            self.view.fit()
    return
</t>
<t tx="1.20130426141258.3599">def _onSaveAsDrawing(self):
    drawing = QtWidgets.QFileDialog.getSaveFileName(self, "Save As...", "/home", filter ="Drawings (*.pdr *.dxf)")[0]
    if len(drawing)&gt;0:
        self.__application.saveAs(drawing)
</t>
<t tx="1.20130426141258.3600">def _onPrint(self):
\\-4.#       printer.setPaperSize(QPrinter.A4);
    self.scene.clearSelection()
    printer=QtPrintSupport.QPrinter()
    printDialog=QtPrintSupport.QPrintDialog(printer)
    if (printDialog.exec_() == QtWidgets.QDialog.Accepted):
        painter=QtGui.QPainter()
        painter.begin(printer)
        painter.setRenderHint(QtGui.QPainter.Antialiasing);
        #self.mdiArea.activeSubWindow().scene.render(painter)
        self.mdiArea.activeSubWindow().view.render(painter)
        painter.end()
    self.statusBar().showMessage("Ready")
    return
</t>
<t tx="1.20130426141258.3601">def _onCloseDrawing(self):
    path=self.mdiArea.activeSubWindow().fileName
    self.__application.closeDocument(path)
    self.mdiArea.closeActiveSubWindow()
    return
</t>
<t tx="1.20130426141258.3602">#---------------------ON COMMANDS in DRAW

def _onPoint(self):
    self.statusBar().showMessage("CMD:Point")
    self.callCommand('POINT')
    return
</t>
<t tx="1.20130426141258.3603">def _onSegment(self):
    self.statusBar().showMessage("CMD:Segment")
    self.callCommand('SEGMENT')
    return
</t>
<t tx="1.20130426141258.3604">def _onCircle(self):
    self.statusBar().showMessage("CMD:Circle")
    self.callCommand('CIRCLE')
    return
</t>
<t tx="1.20130426141258.3605">def _onArc(self):
    self.statusBar().showMessage("CMD:Arc")
    self.callCommand('ARC')
    return
</t>
<t tx="1.20130426141258.3606">def _onEllipse(self):
    self.statusBar().showMessage("CMD:Ellipse")
    self.callCommand('ELLIPSE')
    return
</t>
<t tx="1.20130426141258.3607">def _onRectangle(self):
    self.statusBar().showMessage("CMD:Rectangle")
    self.callCommand('RECTANGLE')
    return
</t>
<t tx="1.20130426141258.3608">def _onPolygon(self):
    self.statusBar().showMessage("CMD:Polygon")
    self.callCommand('POLYGON')
    return
</t>
<t tx="1.20130426141258.3609">def _onPolyline(self):
    self.statusBar().showMessage("CMD:Polyline")
    self.callCommand('POLYLINE')
    return
</t>
<t tx="1.20130426141258.3610">def _onFillet(self):
    self.statusBar().showMessage("CMD:Fillet")
    self.callCommand('FILLET')
    return
</t>
<t tx="1.20130426141258.3611">def _onChamfer(self):
    self.statusBar().showMessage("CMD:Chamfer")
    self.callCommand('CHAMFER')
    return
</t>
<t tx="1.20130426141258.3612">def _onBisect(self):
    self.statusBar().showMessage("CMD:Bisect")
    self.callCommand('BISECTOR')
    return
</t>
<t tx="1.20130426141258.3613">def _onText(self):
    self.statusBar().showMessage("CMD:Text")
    self.callCommand('TEXT')
    return
</t>
<t tx="1.20130426141258.3614">def _onDimension(self):
    self.statusBar().showMessage("CMD:Dimension")
    self.callCommand('DIMENSION')
    return
</t>
<t tx="1.20130426141258.3615">#-------------------------ON COMMANDS in EDIT

def _onUndo(self):
    self.scene.clearSelection()
    try:
       self.mdiArea.activeSubWindow().unDo()
    except UndoDbExc:
        self.critical("Unable To Perform Undo")
    self.statusBar().showMessage("Ready")
    return
</t>
<t tx="1.20130426141258.3616">def _onRedo(self):
    self.scene.clearSelection()
    try:
        self.mdiArea.activeSubWindow().reDo()
    except UndoDbExc:
        self.critical("Unable To Perform Redo")
    self.statusBar().showMessage("Ready")
</t>
<t tx="1.20130426141258.3617">def _onProperty(self):
    self.statusBar().showMessage("CMD:Property")
    self.callCommand('PROPERTY')
</t>
<t tx="1.20130426141258.3618">def preferences(self):
    p=Preferences(self)
    #TODO: Fill up preferences
    if (p.exec_() == QtWidgets.QDialog.Accepted):
        #TODO: save Preferences
        pass
</t>
<t tx="1.20130426141258.3619">#---------------------------ON COMMANDS in MODIFY

def _onCopy(self):
    self.statusBar().showMessage("CMD:Copy")
    self.callCommand('COPY')
    return
</t>
<t tx="1.20130426141258.3620">def _onMove(self):
    self.statusBar().showMessage("CMD:Move")
    self.callCommand('MOVE')
    return
</t>
<t tx="1.20130426141258.3621">def _onDelete(self):
    self.statusBar().showMessage("CMD:Delete")
    self.callCommand('DELETE')
    self.statusBar().showMessage("Ready")
    return
</t>
<t tx="1.20130426141258.3622">def _onTrim(self):
    self.statusBar().showMessage("CMD:Trim")
    self.callCommand('TRIM')
    self.statusBar().showMessage("Ready")
    return
</t>
<t tx="1.20130426141258.3623">def _onMirror(self):
    self.statusBar().showMessage("CMD:Mirror")
    self.callCommand('MIRROR')
    return
</t>
<t tx="1.20130426141258.3624">def _onRotate(self):
    self.statusBar().showMessage("CMD:Rotate")
    self.callCommand('ROTATE')
    return
</t>
<t tx="1.20130426141258.3625">#---------------------------ON COMMANDS in VIEW

def _onFit(self):
    self.view.fit()
</t>
<t tx="1.20130426141258.3626">def _onZoomWindow(self):
    self.statusBar().showMessage("CMD:ZoomWindow")
    self.scene._cmdZoomWindow=True
</t>
<t tx="1.20130426141258.3627">def _onCenterItem(self):
    self.view.centerOnSelection()
</t>
<t tx="1.20130426141258.3628">#---------------------------ON COMMANDS in SNAP

def _onSnapCommand(self):
    """
        On snep Command action
    """
    #__________SNAP NONE?
    self.scene.clearSelection()
    action = self.sender()
    if action:
        if action.command=="snapauto":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["LIST"])
        elif action.command=="snapend":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["END"])
        elif action.command=="snapmid":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["MID"])
        elif action.command=="snapcen":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["CENTER"])
        elif action.command=="snapper":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["ORTHO"])
        elif action.command=="snaptan":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["TANGENT"])
        elif action.command=="snapqua":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["QUADRANT"])
        elif action.command=="snap00":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["ORIG"])
        elif action.command=="snapint":
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["INTERSECTION"])
        else:
            self.scene.setActiveSnap(SNAP_POINT_ARRAY["LIST"])
</t>
<t tx="1.20130426141258.3629">#------------------------ON COMMANDS in TOOLS

def _onInfo2p(self):
    """
        on info two point command
    """
    self.scene.clearSelection()
    self.statusBar().showMessage("CMD:Info2Points")
    self.callCommand('DISTANCE2POINT', 'document')
    return
</t>
<t tx="1.20130426141258.3630">#-- - - -=- - - - -=on commands in menu: Windows
def _onTile(self):   #&lt;-(by: S-PM 110524)
    "on Tile command"    #standard  "Documentation String"

    self.mdiArea.tileSubWindows()   #--call "tile" method
    return
</t>
<t tx="1.20130426141258.3631">#_onTile&gt;


def _onCascade(self):   #&lt;-(by: S-PM 110524)
    "on Cascade command"    #standard  "Documentation String"

\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
\\-4.#                                                                       Prologue
    def cascadeFit(self):  #&lt;-"Fit" function definition
        #--Register
        rgL=[]      #List
        rgN=0       #Integer
        rgGp=None   #General purpose

        #--Action
        rgL=self.mdiArea.subWindowList()    #--get child-List,
        rgN=len(rgL)                        #  and child-count
        if (rgN&lt;1):  return(rgN)    #no sub-window: exit

        rgW = self.mdiArea.width()  #--get actually available room
        rgH = self.mdiArea.height()

        #--compute cascade offset dimensions
        if (rgN&lt;2):     #&lt;-less than 2 sub-windows: no offset
            rgCx=0
            rgCy=0
        elif (rgN&gt;1):   #&lt;-more than 1 sub-window: get offset
            rgCx=rgL[1].x()
            rgCy=rgL[1].y()
        #&gt;
        rgCx=rgCx*(rgN-1)   #compute total cascade offset
        rgCy=rgCy*(rgN-1)

        #&lt;-loop resize all sub-windows, so to fit them into available room
        for rgGp in rgL:
            rgGp.resize(rgW-rgCx, rgH-rgCy)
        #&gt;

        return(rgN)
    #cascadeFit&gt;

\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
\\-4.#                                                                       Action
    #--call "cascade" method, as-is (rudimentary)
    self.mdiArea.cascadeSubWindows()

    rgN=cascadeFit(self)    #"fit" all sub-windows into available room
    return
</t>
<t tx="1.20130426141258.3632">#encoding: utf-8
#_onCascade&gt;



\\-4.#-----------------------ON COMMANDS in ABOUT

def _onAbout(self):
    QtWidgets.QMessageBox.about(self, "About PythonCAD",
            """&lt;b&gt;PythonCAD&lt;/b&gt; is a CAD package written, surprisingly enough, in Python using the PyQt5 interface.&lt;p&gt;
               The PythonCAD project aims to produce a scriptable, open-source,
               easy to use CAD package for any Python/PyQt supported Platforms
               &lt;p&gt;
               This is an Alfa Release For The new R38 Vesion &lt;b&gt;(R38.0.0.5)&lt;b&gt;&lt;P&gt;
               &lt;p&gt;
               &lt;a href="http://sourceforge.net/projects/pythoncad/"&gt;PythonCAD Web Site On Sourceforge&lt;/a&gt;
               &lt;p&gt;
               &lt;a href="http://pythoncad.sourceforge.net/dokuwiki/doku.php"&gt;PythonCAD Wiki Page&lt;/a&gt;
               &lt;p&gt;
               註解: 這是一個利用 Leo 編輯器開發的版本.
               """)
    return
</t>
<t tx="1.20130426141258.3633"># ########################################## CALL COMMAND
# ##########################################################

def callCommand(self, commandName, commandFrom=None):
    """
        call a document command (kernel)
    """
    try:
        if commandFrom==None or commandFrom=='kernel':
            self.scene.activeKernelCommand=self.__application.getCommand(commandName)
        elif commandFrom=='document':
            self.scene.activeKernelCommand=self.getCommand(commandName)
        else:
            return
        self.scene.activeICommand=ICommand(self.scene)
        self.scene.activeICommand.updateInput+=self.updateInput
        self.updateInput(self.scene.activeKernelCommand.activeMessage)
    except EntityMissing:
        self.scene.cancelCommand()
        self.critical("You need to have an active document to perform this command")
    #checks if scene has selected items and launches them directly to the ICommand
    #if it's first prompt it's "give me entities"
    if len(self.scene.selectedItems())&gt;0:
        if  self.scene.activeKernelCommand.activeException()==ExcMultiEntity:
            qtItems=[item for item in self.scene.selectedItems() if isinstance(item, BaseEntity)]
            self.scene.activeICommand.addMauseEvent(point=None,
                                                entity=qtItems,
                                                force=None)
        else:
            self.scene.clearSelection()
</t>
<t tx="1.20130426141258.3634">def getCommand(self, name):
    """
        get an interface command
    """
    if name in INTERFACE_COMMAND:
        return INTERFACE_COMMAND[name](self.mdiArea.activeSubWindow().document,
                                       self.mdiArea.activeSubWindow())
    else:
        self.critical("Wrong command")
</t>
<t tx="1.20130426141258.3635">def updateInput(self, message):
        self.__cmd_intf.commandLine.printMsg(str(message))
        self.statusBar().showMessage(str(message))
</t>
<t tx="1.20130426141258.3636">@staticmethod
def critical(text):
    '''
        Shows an critical message dialog
    '''
    dlg = QtWidgets.QMessageBox()
    dlg.setText(text)
    dlg.setIcon(QtWidgets.QMessageBox.Critical)
    dlg.exec_()
    return
</t>
<t tx="1.20130426141258.3637"># ########################################## SETTINGS STORAGE
# ##########################################################
def readSettings(self): 
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=    
\\-4.# Method to restore application settings saved at previous session end. 
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
    #-create application settings object, platform-independent. 
    # Requires two names: Organization, Application
    # here given as &lt;?&gt;hardcoded values, an example of primitive coding
    lRg=QtCore.QSettings('PythonCAD','MDI Settings')
    
    lRg.beginGroup("CadWindow")        #get this settings group
    if (bool(lRg.value("maximized",False))): #&lt;-window "maximized": 
        self.showMaximized()
    else: #&lt;-window not "maximized": use last window parameters 
        lRg1=lRg.value("size",QtCore.QSize(800,600)).toSize()
        lRg2=lRg.value("pos",QtCore.QPoint(400,300)).toPoint()
        self.resize(lRg1)  
        self.move(lRg2) 
    #&gt;
    lRg.endGroup()                     #close the group

    lRg.beginGroup("CadWindowState")   #now this other group
    self.restoreState(bytearray(lRg.value('State')))
    lRg.endGroup()                     #close the group
</t>
<t tx="1.20130426141258.3638">#readSettings&gt;

def writeSettings(self):
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=    
\\-4.# Method to save current settings at the application exit. 
\\-4.#-- - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=- - - - -=
    #-create application settings object (see: "readSettings") 
    lRg=QtCore.QSettings('PythonCAD','MDI Settings')

    lRg.beginGroup("CadWindow")        #-save this group of settings 
    lRg.setValue('pos',self.pos())
    lRg.setValue('size',self.size())
    lRg.setValue('maximized',self.isMaximized())
    lRg.endGroup()                     #close

    lRg.beginGroup("CadWindowState")   #-now this other group
    lRg.setValue("state",self.saveState())
    lRg.endGroup()                     #close
</t>
<t tx="1.20130426141258.3639">#writeSettings&gt;

# ########################################## END SETTINGS STORAGE
# ##########################################################

def activeMdiChild(self):
    activeSubWindow = self.mdiArea.activeSubWindow()
    if activeSubWindow:
        return activeSubWindow.widget()
    return None
</t>
<t tx="1.20130426141258.3640">def switchLayoutDirection(self):
    if self.layoutDirection() == QtCore.Qt.LeftToRight:
        QtWidgets.QApplication.setLayoutDirection(QtCore.Qt.RightToLeft)
    else:
        QtWidgets.QApplication.setLayoutDirection(QtCore.Qt.LeftToRight)
</t>
<t tx="1.20130426141258.3641">def setActiveSubWindow(self, window):
    if window:
        self.mdiArea.setActiveSubWindow(window)
</t>
<t tx="1.20130426141258.3642">def _getIcon(self, cmd):
    '''
    Create an QIcon object based on the command name.
    The name of the icon is ':/images/' + cmd + '.png'.
    If the cmd = 'Open', the name of the icon is ':/images/Open.png'.
    '''
    icon_name = cmd + '.png'
    icon_path = os.path.join(os.path.join(os.getcwd(), 'icons'), icon_name)
    # check if icon exist
    if os.path.exists(icon_path):
        icon = QtGui.QIcon(icon_path)
        return icon
    # icon not found, don't use an icon, return None
    return None
</t>
<t tx="1.20130426141258.3643">def keyPressEvent(self, event):
    if event.key()==QtCore.Qt.Key_Escape:
        self.resetCommand()

    super(CadWindowMdi, self).keyPressEvent(event)
</t>
<t tx="1.20130426141258.3644"># ########################################## SYMPY INTEGRATION
# ##########################################################

def plotFromSympy(self, objects):
    """
        plot the sympy Object into PythonCAD
    """
    if self.mdiArea.currentSubWindow()==None:
        self._onNewDrawing()
    for obj in objects:
        self.plotSympyEntity(obj)
</t>
<t tx="1.20130426141258.3645">def plotSympyEntity(self, sympyEntity):
    """
        plot the sympy entity
    """
    self.mdiArea.currentSubWindow().document.saveSympyEnt(sympyEntity)
</t>
<t tx="1.20130426141258.3646">def createSympyDocument(self):
    """
        create a new document to be used by sympy plugin
    """
    self._onNewDrawing()
</t>
<t tx="1.20130426141258.3647">def getSympyObject(self):
    """
        get an array of sympy object
    """
    #if self.Application.ActiveDocument==None:
    if self.mdiArea.currentSubWindow()==None:
        raise StructuralError("unable to get the active document")

    ents=self.mdiArea.currentSubWindow().scene.getAllBaseEntity()
    return [ents[ent].geoItem.getSympy() for ent in ents if ent!=None]
</t>
<t tx="1.20130426141258.3648"># ##########################################  CLASS STATUSBUTTON
# ##########################################################
# ##########################################################
# ##########################################################

class statusButton(QtWidgets.QToolButton):
    @others
</t>
<t tx="1.20130426141258.3649">def __init__(self, icon=None,  tooltip=None):
    super(statusButton, self).__init__()
    self.setCheckable(True)
    self.setFixedSize(30, 20)
    if icon:
        self.getIcon(icon)
    self.setToolTip(tooltip)
</t>
<t tx="1.20130426141258.3650">def getIcon(self, fileName):
    iconpath=os.path.join(os.getcwd(), 'icons', fileName)
    self.setIcon(QtGui.QIcon(iconpath))
</t>
<t tx="1.20130426141258.3651">def mousePressEvent(self, event):
    if event.button()==QtCore.Qt.LeftButton:
        self.click()
    elif event.button()==QtCore.Qt.RightButton:
        self.showMenu()
</t>
<t tx="1.20130426141258.3652"># -*- coding: utf-8 -*-

# Resource object code
#
# Created: 星期二 四月 23 21:28:19 2013
#      by: The Resource Compiler for PyQt (Qt v4.8.4)
#
# WARNING! All changes made in this file will be lost!


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
qInitResources()
</t>
<t tx="1.20130426141258.3653">from PyQt5 import QtCore

qt_resource_data = b"\
\x00\x00\x06\xc4\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
\x00\x00\x00\x04\x67\x41\x4d\x41\x00\x00\xd9\x04\xdc\xb2\xda\x02\
\x00\x00\x06\x7b\x49\x44\x41\x54\x58\xc3\xad\x57\x69\x4c\x54\x57\
\x14\x76\x21\x62\x95\x04\x97\xa8\x25\x18\x52\x1b\x0d\x11\x45\x04\
\xaa\xa4\x49\xb5\x56\x4d\x6c\x69\xb0\x68\xa3\xb6\xc5\xb2\x46\xfd\
\xa3\x2c\x61\x51\x48\x24\x08\x64\xc2\x12\xd0\x22\x42\x11\x59\x44\
\x40\x40\xf6\x91\x7d\x53\x36\x09\xb2\xa9\x08\x0e\x24\x0c\x62\x01\
\x83\x02\x82\x0b\x08\xa9\x5f\xcf\xb9\x99\x31\xa3\x80\x9d\xb4\xf3\
\x92\x2f\xf3\xde\xbc\x7b\xce\xf7\xdd\x73\xce\x3d\xf7\xbe\x79\xf3\
\x54\x2e\x3b\xbb\xe8\x2f\x1c\x1d\x23\x1d\x1d\x1d\x23\x02\x1d\x1c\
\x2e\x48\xd2\xd3\xab\x25\x97\x2e\x15\x56\x47\x46\xde\xac\x4d\x4c\
\xac\xa8\xad\xaa\x6a\xbf\x2f\x95\x36\x41\x89\x2b\x57\x4a\xdb\x8d\
\x8d\xf7\x7c\x49\xa6\xf3\xe7\x69\xe8\x5a\x68\x6f\xff\x47\xa1\xfc\
\xf1\x73\x4c\xff\x0d\xb5\x10\x10\x98\x3c\x48\x76\xc6\x1a\x13\xc1\
\x33\xf2\xf4\x4a\x7a\x3d\x36\x09\xa8\x03\xf9\xc0\x38\x2c\x2c\x7e\
\xce\x21\xd3\xb5\x9a\x8a\xc2\xfc\xc3\x87\xfd\xa3\x8a\xab\x64\x18\
\x7a\x0d\xb5\xe0\xe3\x1b\x3f\x4a\x76\x3f\x11\x3e\xd3\x88\x82\xed\
\xdb\x0f\xac\x3d\xeb\x97\x89\xde\x17\x50\x0b\xf9\xe5\x32\x18\x18\
\x18\xc7\x91\xe9\xe7\x1a\x8b\x82\xad\x6d\x58\x79\x63\xf7\x38\x64\
\xcf\xf1\xaf\xe0\x71\x16\x16\x07\x5b\xc8\xee\x2b\x82\x96\x46\x14\
\xd8\xd8\x04\xfb\xa4\x15\xc9\xd0\x3a\x08\xb5\x60\xe7\x18\xf4\x9c\
\xcc\x7e\x21\x2c\xd1\x88\x00\x4b\x4b\xaf\x8d\xa1\x97\xaa\xd0\xf0\
\x17\xd4\x42\x08\x8d\x25\x33\x7f\xc2\x0a\x8d\x2d\x49\x17\xf7\xa4\
\xfe\x4a\x39\xa0\x0e\x22\x92\x9a\xa0\xa7\x67\x28\xd5\xe4\x6a\x98\
\x47\xcd\xa8\x28\xbf\xfd\x2d\x8a\xba\x31\x27\x0a\xba\x80\xdc\x4e\
\x20\xb6\x74\x00\x86\x86\x3b\xea\xc9\xcc\x54\x63\x75\x60\x67\x17\
\x1e\xc4\x8e\xb3\x3a\x80\x8c\x36\x20\xad\x09\x48\x69\x00\x92\xea\
\x80\x84\x6a\x20\xa6\x1c\xc8\x6c\x04\x4a\x1e\x00\xf5\xed\xe3\x68\
\x6a\xea\x80\xaf\xaf\xef\x2b\x32\x35\xf8\xdf\xe4\x12\x89\x44\x2e\
\x95\x96\x20\xab\x70\x00\xa9\x52\x08\x94\x10\x31\x71\x50\xf3\x01\
\x7a\x9e\x8c\x61\x68\x68\x08\xbd\xbd\xbd\x78\xf8\xf0\x21\x1e\x3c\
\x78\x20\x7e\x13\x13\x13\xb1\x7b\xf7\xee\xda\x43\x87\x0e\x05\x58\
\x5a\x5a\x6e\xe4\x54\xfe\x27\x01\xa1\xa1\xa1\x7d\x13\x13\x13\x98\
\x9c\x9c\xc4\xd4\xd4\x14\xba\xba\xba\x70\xe7\xce\x1d\xdc\xbe\x7d\
\x1b\xf9\xf9\xf9\x28\x29\x29\x41\x55\x55\x15\xea\xeb\xeb\xd1\xdc\
\xdc\x2c\x04\x30\x92\x92\x92\x70\xe3\xc6\x0d\xe4\xe5\xe5\x89\xfb\
\x13\x27\x4e\xdc\xdd\xb1\x63\x87\x99\xda\x42\xec\xec\xec\x96\xd9\
\xda\xda\x7e\x17\x12\x12\xd2\xce\x33\x54\xa2\xb0\xb0\x50\x38\x56\
\x25\xcf\xca\xca\x42\x42\x42\x02\xc2\xc3\xc3\x11\x17\x17\x87\xab\
\x57\xaf\x0a\x81\x7d\x7d\x7d\xe8\xe9\xe9\x11\x36\x75\x75\x75\x38\
\x7d\xfa\xf4\x84\xb9\xb9\xf9\x6f\xe4\x5e\xfb\x93\xe4\x47\x8f\x1e\
\xb5\xa7\xc1\x2f\xa2\xa2\xa2\x10\x1d\x1d\x8d\x8c\x8c\x0c\xc4\xc6\
\xc6\x22\x37\x37\x17\x39\x39\x39\x88\x8c\x8c\x04\x09\x03\xbf\xbf\
\x76\xed\x1a\x2a\x2a\x2a\x44\xd8\x47\x46\x46\x30\x3c\x3c\x8c\x67\
\xcf\x9e\x09\xb1\x4f\x9f\x3e\xc5\xe0\xe0\x20\x06\x06\x06\x50\x50\
\x50\x80\x86\x86\x06\x78\x78\x78\x4c\x6e\xda\xb4\xc9\x69\xce\x76\
\x6d\x63\x63\xb3\x2b\x2c\x2c\x4c\x84\xba\xa3\xa3\x03\xf7\xee\xdd\
\x13\xbf\x72\xb9\x5c\x08\xb8\x7c\xf9\xb2\xf8\xef\xd5\xab\x57\x18\
\x1f\x1f\xc7\xd8\xd8\x18\x46\x47\x47\x3f\x49\xde\xdd\xdd\x8d\xca\
\xca\x4a\x11\xb9\xb6\xb6\x36\x1c\x38\x70\x60\x88\xa8\xbe\x99\x75\
\x95\x1c\x39\x72\x24\x4f\x26\x93\x89\xd0\xa9\x8a\x60\x43\x26\xe2\
\xfc\x96\x95\x95\x7d\x92\x9c\xc5\x36\x36\x36\x8a\xd0\x73\x0d\x30\
\x79\x6b\x6b\xab\x28\x54\xf6\x1b\x14\x14\x04\x13\x13\x93\xbc\x59\
\x7b\x05\x55\x6d\x0d\xab\x56\xe6\x4f\x55\x04\x3b\x61\x42\xbe\xe7\
\x9c\x2a\xc9\x79\xb6\xf7\xef\xdf\x17\xa9\xe0\xda\x60\x81\x2d\x2d\
\x2d\x82\xf0\xc9\x93\x27\x78\xfc\xf8\x31\x1e\x3d\x7a\x24\x8a\xb4\
\xa6\xa6\x06\xc1\xc1\xc1\xa0\x5a\xe8\x20\xba\xef\x67\xa4\x82\xc2\
\x53\xdb\xd9\xd9\x89\xb9\x44\xb4\xb7\xb7\x8b\x99\x73\xf1\x71\x11\
\x4a\xa5\x52\x14\x17\x17\x8b\x77\x4c\xa6\x0c\x3b\x93\xb2\x60\x26\
\xe4\x48\x30\x6e\xde\xbc\x29\x0a\xd4\xdd\xdd\x1d\x5b\xb7\x6e\x95\
\x11\xdd\xef\x04\x9d\x0f\x04\xec\xdf\xbf\xbf\x96\x0a\x50\x38\x9d\
\x4b\x04\x3f\xf3\xcc\xf9\x9d\x6a\xce\x95\x4b\x94\x0b\x8e\x57\x06\
\xd7\x4c\x76\x76\xb6\x28\x64\x3f\x3f\x3f\x38\x39\x39\xe1\xd8\xb1\
\x63\xf0\xf6\xf6\xe6\x14\xb0\x00\xfb\x19\x02\xa8\x69\x14\x14\x15\
\x15\x21\x26\x26\x06\xce\xce\xce\x48\x49\x49\x11\x8e\x55\x45\x70\
\x1d\x30\x31\xcf\x92\x43\xcd\x62\xd3\xd2\xd2\x70\xfd\xfa\x75\xb1\
\x62\x92\x93\x93\x71\xfe\xfc\x79\xae\x78\xb8\xba\xba\x82\x7a\x09\
\x32\x33\x33\xe1\x1b\xef\x0c\xef\xaa\xc3\x42\x84\xb1\xb1\xf1\xec\
\x02\xf6\xed\xdb\x17\x74\xf7\xee\x5d\x51\x64\xfd\xfd\xfd\x48\x4f\
\x4f\x87\x97\x97\x97\x58\x7a\x4c\xa6\x14\xc1\xa1\x8f\x8f\x8f\x17\
\x4d\x86\x09\x79\x75\x04\x04\x04\x88\xf0\x32\x31\x17\x1a\x0b\xe2\
\x34\x95\x97\x97\x8b\x94\xf9\x25\xba\xc2\x2b\xe7\x57\xee\x07\xd8\
\xbc\x79\xf3\xec\x02\xf6\xee\xdd\x2b\x61\xa2\x37\x6f\xde\x08\x11\
\x1c\x6a\x9e\x29\x3b\x63\x21\x11\x11\x11\x22\xaf\x1c\x62\x9e\xe5\
\xb9\x73\xe7\x44\xa4\x98\x98\x9f\x79\x1c\x8b\xe3\x9c\xab\x92\xb3\
\x0d\xe7\x9f\x7b\x01\x17\xa1\x91\x91\xd1\xec\x02\xa8\x7f\x4b\x78\
\xc9\x4d\x4f\x4f\x7f\x20\x82\xf3\xcc\x35\xc1\x85\xe4\xe9\xe9\x89\
\xe3\xc7\x8f\xc3\xc7\xc7\x47\x84\x97\xa3\xa0\xcc\xb9\x2a\x39\xa7\
\x92\xdf\x5d\xb8\x70\x01\x54\x5b\x5c\xf9\xe2\xff\x33\x67\xce\xd0\
\x8e\x69\x38\xbb\x80\x9d\x3b\x77\x4a\x58\xe9\xbb\x77\xef\xe6\x14\
\xc1\xc5\xc7\x4d\x45\x99\xf3\x8f\xc9\xb9\x7e\x02\x03\x03\x85\x50\
\xda\x15\xdf\xb7\x68\x1e\xcf\x4d\xce\xcd\xcd\x0d\xa6\xa6\xa6\x7d\
\x44\xe7\x34\x43\xc0\x86\x0d\x1b\xf4\x69\x89\x64\x50\x3f\x78\xcb\
\x61\x9b\x4b\x04\x13\xa9\x92\x73\x24\x4e\x9d\x3a\x05\x6a\x64\xa0\
\x7d\x04\x2e\x2e\x2e\x1f\x90\x73\x0b\xe7\x0d\x8b\x6d\x79\x53\xa3\
\x31\xc3\x44\xe7\x46\xd0\x9d\x71\x10\xe5\x7d\x5c\x57\x57\xd7\x63\
\xcb\x96\x2d\x72\x76\xca\x45\xf7\xb1\x88\xd2\xd2\xd2\xf7\xe4\x1c\
\x0d\xda\xe9\x60\x6d\x6d\x3d\x2b\x39\x37\x2d\xb6\xe1\xab\xa9\xa9\
\x09\x27\x4f\x9e\x1c\x25\xff\x7c\x68\xf1\x98\xeb\xe8\x36\x5f\xa1\
\xcc\x7c\xcd\x9a\x35\xd1\x66\x66\x66\x23\xfe\xfe\xfe\xc2\x89\x52\
\x04\x77\x3d\x65\xd8\xb3\xb3\xcb\x20\x91\x64\x51\x04\x7c\xde\x93\
\xf3\xe6\xc5\xdd\xf1\xe5\xcb\x97\xc2\x26\x35\x35\x15\x94\xde\xc1\
\xa5\x4b\x97\xd6\x92\xdf\x54\xc2\x59\xc5\x7e\xb0\xe8\x93\xe7\x41\
\xc2\x6a\xc2\x9e\x75\xeb\xd6\x95\xec\xda\xb5\x6b\x8a\x77\x40\x76\
\x78\xeb\xd6\x2d\xb1\x13\xf2\x0a\xb0\xb2\xb2\xa6\xa2\xf4\xc3\xc5\
\x8b\xd5\xb4\x4a\x8a\xa9\x5b\x76\x89\xd9\x72\xb8\x49\xcc\x34\x45\
\xb2\x6f\xf1\xe2\xc5\x95\xe4\xe7\x2a\xc1\x95\xf0\xb5\xc2\xef\x22\
\x75\xcf\x25\x3c\xd0\x40\x5b\x5b\xdb\x71\xfd\xfa\xf5\x6d\x56\x56\
\x56\xa0\x2d\x1b\xdb\xb6\x6d\x03\x3d\x0f\xae\x5a\xb5\xaa\x59\x47\
\x47\xa7\xd2\xc4\xc4\x7c\x88\x85\xa4\xa6\xe6\xc2\xc1\xc1\x61\x42\
\x4f\x4f\x4f\xa6\xa5\xa5\x55\x40\xb6\x7f\x12\x4e\x28\xce\x89\x2b\
\xfe\xcf\x59\x91\x2b\xd6\x68\xf9\xf2\xe5\x81\xfa\xfa\xfa\x8d\x0b\
\x16\x2c\x28\xa2\xe7\x44\x82\x3b\xe1\x07\x8e\xd4\xca\x95\x2b\xe3\
\x56\xaf\x5e\xdd\x40\xf7\x59\x84\x70\xc5\x37\x82\xa1\x22\xa5\x0b\
\x35\xf2\xb5\xa4\x98\x05\x87\xf1\x20\x0b\x22\x2c\x53\x9c\x72\xb4\
\x14\x9f\x65\xdf\x12\x7e\x54\x1c\x4a\x97\xa8\xf3\xc5\xfc\x0f\xd1\
\xc2\x47\xb4\x63\xf2\xc9\xfc\x00\x00\x00\x00\x49\x45\x4e\x44\xae\
\x42\x60\x82\
\x00\x00\x03\xd1\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
\x00\x00\x00\x04\x67\x41\x4d\x41\x00\x00\xd6\xd8\xd4\x4f\x58\x32\
\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\x72\x65\
\x00\x41\x64\x6f\x62\x65\x20\x49\x6d\x61\x67\x65\x52\x65\x61\x64\
\x79\x71\xc9\x65\x3c\x00\x00\x03\x63\x49\x44\x41\x54\x58\xc3\xc5\
\x97\xcd\x6f\x1b\x55\x14\xc5\x7f\x77\x66\x92\x89\xd3\x7c\xd4\xad\
\x17\x09\x20\xd2\x4d\x55\x51\x10\x08\x51\x84\xca\x0a\x09\xd8\x20\
\xc4\xa2\x52\x17\x2c\x2a\x24\x28\x6b\x36\x2c\x90\xfa\x1f\xc0\x82\
\x0d\xa8\x3b\x04\x2c\xd8\x82\x10\xaa\xda\x45\x05\x64\x07\x08\x04\
\xa1\x34\x40\x85\x11\x6e\x21\xb5\x13\x9c\xe6\xc3\xb5\xd3\x79\xef\
\x5d\x16\xf3\xec\x8c\x9d\xc4\xa6\xf5\x54\x1d\xe9\x4a\x1e\x69\x3c\
\xe7\xdc\x73\xce\xbb\xef\x8d\xa8\x2a\xf7\xf2\x0a\xb8\xc7\x57\xf4\
\x7f\x1e\x7a\xff\x35\x79\xf2\xe6\x16\x91\x55\xa4\x30\xca\x13\xc6\
\x12\xaa\x22\x00\x51\xc0\x4c\x18\x30\xeb\x94\xc0\x3a\x1a\xd5\x35\
\x3e\x7b\xfb\x73\xe6\x81\xa6\xaa\xba\x41\xef\x96\x41\x16\x9c\x7d\
\x5d\xce\x3c\xf8\xc8\x0b\xaf\x3a\xa7\xa1\xaa\x06\x0f\x1c\x7d\x76\
\xdc\x39\x15\x54\x05\x60\xaa\x34\x17\x8d\x17\xef\x1f\x09\xc2\x82\
\x98\xad\x86\x7e\xf1\xde\x89\xea\x77\x8b\xff\xbe\xfb\xe1\x57\x7c\
\x02\xd4\x55\xd5\xf6\x05\x50\xd5\xbe\x75\xf6\x34\x3f\xaa\xaa\xaa\
\x3a\x5f\xb6\xab\x9c\x5a\x6d\xb5\x6e\x6a\xb5\xba\xa4\xc6\x18\xbd\
\xb2\xf0\x75\xf2\xe6\x8b\x7c\xfb\xfc\xa3\xbc\x02\x14\xdb\x4d\xee\
\x55\x03\x33\xe0\x94\x10\x2c\x60\x7c\x39\xd2\xfb\xb4\x04\x8b\x31\
\xb7\x58\x5e\xae\x11\x86\x21\x87\x1e\x7a\x3a\x3a\xf9\xc6\x07\x8f\
\x1d\x9e\xe1\xe5\x97\x8e\xf1\x1c\x30\x21\x22\x72\xc7\x21\x4c\xbd\
\xd6\x2e\xd0\xb4\x1c\xe0\x50\x2c\xaa\x09\xcd\x66\x23\x0d\x55\x14\
\xf1\xf0\xf1\x93\xa3\xa7\xdf\xfa\xf8\x99\xb9\x12\xa7\x80\x43\x40\
\x61\xc8\x55\x90\x02\x81\x45\x31\x9e\x40\x02\x18\xc4\x93\xc9\xe6\
\x6d\xdf\xbe\x09\x8e\x3c\x75\x22\x2e\x4d\x72\x1c\x38\x0a\x4c\x0e\
\xb5\x0a\x14\x87\x60\xd2\xd4\x6e\xe7\x97\x54\x19\x08\x02\xc5\x98\
\x16\x17\x2f\x5e\x60\x6d\x6d\x83\x20\x80\xfd\xfb\x8b\x68\x54\x8c\
\x61\x75\x0e\x98\x00\xaa\x77\xac\x80\x64\x2c\xd0\x4e\x1e\x12\xda\
\xd9\x18\x1d\x15\x66\x66\x0f\xd2\x6c\xd6\xd9\xdc\xac\x61\xcc\x26\
\x85\xc2\x08\xad\xe6\x2a\x5e\xfe\x68\x48\x05\xac\x57\x40\x3b\x7d\
\x4b\x46\x85\x20\x54\xee\x9b\x2d\x31\x35\xf9\x38\xc6\x18\xa2\x28\
\x22\x8e\x0f\x70\x7e\x04\xcd\x65\x10\x09\xce\x77\x4c\xc6\x06\x45\
\x11\x04\x25\x10\x21\x8e\x85\x38\xce\x5a\x3d\x46\x18\x74\xa4\xd3\
\x1c\x32\x90\xf8\xb7\xa4\xa0\xda\x87\x6e\x4a\xce\xe5\x37\x8a\xdb\
\x5e\xb7\x3b\x6f\x83\x48\x4f\x2c\xb7\x1b\x15\xff\x9f\x9c\x08\x08\
\x0e\xcd\x58\xd0\x26\xa1\x3b\xd6\xc3\x36\x1d\xc9\x57\x81\xd4\x82\
\xfe\x24\x7b\xe9\xe5\x48\x40\xfd\xe0\x91\x2e\x03\xba\x41\xe9\x49\
\x9a\xe6\x69\x41\x56\x01\xd9\xa5\x63\x7a\x08\xe5\xae\x40\x9a\x01\
\xd3\xe9\x51\x76\x89\x1c\x3e\x96\xd2\x09\xa7\xcd\xdf\x82\xde\x5e\
\xa5\x13\xc6\x14\x7a\xfb\x79\xbd\x1b\x0a\x24\x3b\xe4\xee\xf6\x5c\
\xbb\x16\x67\xce\x0a\xec\x9c\x84\xba\xeb\x73\xd9\xdd\x43\xf3\x1f\
\x44\x83\x62\xd7\xfd\xfb\x2e\x0c\xa2\xac\xf3\xfd\x94\x68\x0f\xec\
\x5c\x97\x61\xba\x15\x0f\x3a\xe1\xc7\xc0\x38\x50\x64\x6d\x25\x70\
\x1b\x4d\x5a\xb9\x6d\x46\x3b\x2d\x80\xf4\x48\x39\x86\x30\x8d\x52\
\xa4\x56\x59\xb1\x95\xc5\xcb\xf6\xa7\x2f\x3f\x4a\xae\x2c\xfe\xd0\
\xb8\x74\x95\x3f\x80\x55\x60\x6b\x48\x05\xd4\x1f\x40\x15\x25\x04\
\x0a\x08\x53\x28\x07\xa8\x55\x56\xed\xc2\xfc\xb9\xe4\xd7\x6f\x3e\
\x35\xe5\x72\x79\xfd\xef\x3a\xcb\xdf\xff\xc9\x6f\xe5\x2a\x65\xe0\
\x1a\x70\x19\x58\x1f\x32\x03\xa0\x8c\xa1\x4c\x03\x07\x3d\xe8\x85\
\x0e\xe8\x2f\xd7\xa8\x5c\xaa\xf0\xfb\xd2\x0d\xfe\x02\x6a\xc0\x12\
\xf0\x8f\x3f\x86\xd5\x81\xcd\x21\x15\x38\x42\xad\xb2\x6c\x17\xe6\
\xcf\xef\x05\x7a\x1d\xb8\xea\x41\xeb\xc0\x86\x07\xdd\xd2\x01\x5f\
\x3e\x03\x09\xac\x37\x39\xf7\xce\xa9\xc2\xf4\xf5\x1b\xd8\x9f\x2b\
\x2c\xed\x01\xba\xe2\x65\x6e\x00\x89\xde\xc6\x17\xef\xc0\x4f\x33\
\x11\x29\x01\xc7\x80\xc3\xc0\x2d\x0f\x38\x14\xe8\xed\x12\x18\x01\
\xa6\xfd\xd1\xda\x7a\x69\x87\x02\xcd\x5e\xff\x01\xf9\x68\x10\x8e\
\x11\x57\x76\x24\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\
\x00\x00\x07\x66\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
\x00\x00\x07\x2d\x49\x44\x41\x54\x78\x5e\xb5\x56\x5d\x6f\x1c\x57\
\x19\x7e\xce\xc7\x7c\xec\x97\xd7\x6e\x9c\x38\xc6\x89\x03\x49\x9a\
\x26\x4d\x21\xaa\x08\x95\xb8\x40\xca\x25\x08\x89\xfb\x8a\x2b\xee\
\xb8\x41\x48\x48\x20\x21\x21\x04\x37\x5c\xf1\x03\xb8\x00\xa9\x70\
\x83\xa2\x0a\x51\x22\x01\x37\x20\x15\xd1\xa0\xe6\xb3\xad\x53\x2b\
\x49\x9b\xa4\xb1\xe3\x8f\xb5\xbd\x3b\x9b\x59\xef\xcc\xce\xce\xcc\
\x39\x87\xf3\x1e\x2d\x2b\xd3\x3a\xf5\x02\xe2\x58\x8f\xde\x39\xc7\
\x1a\x3f\xcf\xfb\xbc\xef\x79\xc7\xcc\x18\x83\xff\x75\x5d\xbc\xf8\
\x6d\x0e\x20\x54\xaa\xa8\x68\x5d\xd6\x19\xe3\x14\xa7\x74\xa9\xea\
\x5a\x95\x15\xad\xf4\x94\x31\x68\x7a\x15\xb9\xba\xbc\x7c\xf9\x4d\
\x00\x99\xe5\xd5\x00\x20\xf7\x12\x5c\xf8\xc2\xb7\xbe\x94\xa5\x83\
\x53\x40\x59\x63\xe0\x75\x3f\x0c\x6b\x42\x7a\x55\x18\x56\x07\x50\
\x63\x8c\xd5\x00\xd4\xc1\x10\x5a\xd0\x59\x08\x98\x0a\x98\x0e\xb5\
\x31\x81\x86\xf6\x34\x2b\x3d\x4b\x2a\x99\x27\xc5\xdc\xe9\xe7\xd9\
\xd9\x17\xcf\xf2\xc6\xcc\x0c\x13\xcd\x19\xf1\x97\x5f\xbd\xf6\x00\
\xc0\xab\x16\x14\xe3\x4f\x08\x38\x3c\x7f\xf8\x97\x5f\xfc\xca\xcb\
\x2f\x65\xda\x53\x79\x51\xb0\x3b\x37\xdf\x62\x1f\xdc\x7d\x17\x5e\
\xe0\x81\x0b\x30\xce\x01\x21\xb8\x83\xe7\x09\x16\x04\x92\x85\xa1\
\x8f\x8a\x45\xb5\x1a\xda\x18\xa2\x5e\xab\xa2\x56\xab\x60\xee\xe8\
\x02\x4e\x5f\xf8\x32\xae\x6c\x7f\x16\xed\xf6\x03\xf0\xd6\x32\x94\
\x2a\xe7\x01\xbc\x62\xd1\xd9\x57\xc0\xc9\x73\xa7\xce\x7f\xe3\x7b\
\xaf\xf2\xdf\xfd\x63\xc8\x3f\xba\xf9\x16\xe6\x16\x24\x7e\xf8\xdd\
\x1f\xa1\x54\x40\x18\x04\xf0\x3d\x89\x6a\xa5\x82\x30\x0c\x10\xf8\
\x9e\xdd\xfb\x90\x52\x40\x08\x01\xce\x18\x98\x05\x18\x20\xa5\xe7\
\xce\xb3\x5c\xe1\x27\x57\x3b\x78\x78\x7b\x09\xcf\x9b\x77\xe1\xab\
\x5c\x00\x20\x11\xa1\x05\x3e\x21\x60\x37\xc9\xb3\x37\x6f\x0f\x6b\
\xbf\xf9\xeb\x0a\x3a\xd7\x96\xf0\xcd\x53\x06\x5f\xff\xea\xd7\xb0\
\xb1\xbe\x8e\x7e\xd2\x47\x96\x0d\xa1\x94\x42\x59\x14\xc8\x87\x43\
\x68\xad\x61\x8c\x71\xb1\x2c\xcb\x31\xe8\xcc\x89\x11\x3e\x4e\x1e\
\x3a\x89\xf5\x13\xaf\xa0\x9a\xe7\x28\x57\xaf\x01\x00\x23\xec\x2b\
\x80\x5e\x54\xf4\xc7\x94\x71\x2f\x47\x4f\x63\xdc\x78\xfb\x2a\xd6\
\x36\xb7\x51\x14\x85\x23\xe3\x9c\xec\xa7\x0c\x25\xc1\x65\x4f\x8b\
\x44\xd0\xa2\xdf\xfb\xbe\x6f\xcb\x50\x43\xb5\xd1\x84\xfc\x40\x21\
\xac\x56\x21\x94\x40\xb9\x87\x6b\x5f\x01\x24\x5a\x0a\x8e\xc0\x13\
\x80\x64\x08\xc3\x0a\x16\x17\x17\xc1\xbd\x90\x32\x27\x01\x44\x48\
\xd9\x8d\x41\xcb\xed\x39\x07\xed\x38\xf5\x87\xf4\x5c\x3f\x88\xa0\
\x0a\xc9\x13\x04\x82\xc1\xe3\x40\x7e\x90\x00\x80\x41\x70\x06\x5f\
\x70\x80\x19\xd4\x6d\x16\x73\x9f\x39\x8a\x24\x2b\x9c\xfd\x45\x31\
\x1c\x59\x6e\xe0\x7e\x94\x86\x36\xe4\x9c\x76\x0e\x39\x94\x05\x54\
\xa9\xe0\x16\xb7\x42\x2a\x2f\xc2\xf7\x32\x27\x1c\x07\x3a\x60\x41\
\xdc\xbe\xc7\x20\x7d\x89\xa8\x1b\xe1\xf6\xf5\x9b\xd8\xdc\x89\xc8\
\xe2\xb1\xbd\x41\x10\x50\x19\xe8\x99\x1a\x93\x1c\xb0\x44\x15\xb2\
\x9f\x88\xdc\x79\xd5\xda\xee\x59\x07\x7e\xfd\x46\x8c\x40\x0a\x97\
\x18\xd8\x81\x0e\x18\x48\xce\xe0\x49\x61\x23\x50\xaf\xd7\xf1\xc2\
\xf9\xcf\x63\xb6\x13\x8d\xad\xfe\xb7\x12\xb8\x37\x00\xce\xc8\xb1\
\x71\x1c\x97\x85\x1a\x32\x94\x02\xa1\xa7\x21\x05\x3b\xd8\x01\x22\
\x90\x92\x23\xb0\x90\x8c\x51\x23\x59\xd4\x51\x14\xa5\x43\xa9\x4a\
\xa8\x51\x97\x13\x40\x11\xb0\x67\x64\x7d\x89\xe1\x30\x47\x59\x94\
\x50\xda\xf5\x0b\x0c\x97\xa8\x86\xc7\x10\xf8\x8a\x12\x9b\xac\x04\
\x94\x79\xe8\xb9\x46\x44\xa7\xbd\x83\x7b\xcb\x4b\x68\x77\x7b\x2e\
\x73\xcf\xf7\xdd\x3c\xa8\x84\x15\x04\x81\x0f\x3f\x08\x21\x3d\x39\
\xb6\x9e\x40\x37\xc3\x73\x65\xe1\xa0\xf5\xfb\xf5\x6d\x57\x02\x8f\
\xcc\x39\x48\x00\x29\xf0\x84\x73\xc0\x92\x79\x98\x3d\x64\xa7\xd9\
\x99\x73\x38\x39\xba\x7e\xd2\x35\xe7\x7e\x99\x18\x17\xb4\x32\xc8\
\x4a\x20\x4e\x34\xb2\x42\x21\xb7\xfb\x6a\x40\x25\x30\x93\x36\x21\
\x83\xeb\x01\x01\x54\x67\xe6\x30\x7f\xa6\x09\xe9\x79\x6e\x36\x64\
\x85\x41\x77\xa0\x90\xe4\x06\x69\xae\xd1\xb7\xb1\x3f\xd4\xd8\xcd\
\x34\x7a\x43\xe3\x62\x6c\x41\x67\x69\x6e\xa0\x0c\x5c\x89\x3a\x03\
\x8d\x66\x35\x04\x04\x0e\x16\xc0\x19\x29\x05\x7c\xa1\xec\xf5\x3b\
\x81\x3b\x9a\xe1\xfb\x57\x76\x30\x5b\x15\x18\x94\x06\x89\x25\x1c\
\x14\x06\x79\x39\x82\x02\x4a\x63\x50\x8e\x9e\x15\x18\xc0\x38\x04\
\x97\x60\xe4\x96\x2e\x1d\x6f\x73\x4a\xa0\xa0\xfd\x24\x73\x80\x6a\
\x15\x70\x86\xe9\xa9\x06\x4a\x0e\xdc\x6f\x15\xb8\x8b\x02\xca\xd0\
\xb0\x11\x60\x42\x42\xba\x9a\x73\x70\xc9\xc0\x8d\x86\x60\x39\xbc\
\xb2\x0f\x3d\xe8\x23\xdd\x8d\x30\xe8\x45\x28\x8b\x1c\x53\x47\x4f\
\x62\xfe\xd8\x09\x54\x7c\x01\x23\x30\xc9\x35\x84\xb3\x3f\xf4\x05\
\x18\x37\x90\x9e\xef\xb2\x28\xb3\x14\x26\xdd\x45\x96\xc6\xc8\x7a\
\x16\x49\x17\xc3\x24\x86\xca\xfa\x10\x6a\x80\x9a\xd4\x98\xae\x49\
\x1c\x6e\x56\x71\xee\xb9\x06\xe6\x4e\x37\x70\xe4\xd0\x34\x9a\x33\
\x1a\x6f\x74\x7c\xd7\x57\x1e\x4d\xca\xc9\x46\x31\x09\x90\x96\x34\
\xc6\xfa\x3b\x7f\x42\xda\xfa\x10\x53\x15\x89\x43\x8d\x10\x0b\xd3\
\x35\xcc\x1f\x6d\x62\x76\xba\x8e\x99\xc6\x09\x1c\x9d\x9d\xc6\x9c\
\xc5\x73\x53\x75\x54\x2b\x81\x6b\xd4\x52\x29\xa4\x83\x0c\xbb\xfd\
\x04\xbd\xfe\x10\x8b\x26\xc0\x40\x0b\xe4\x93\xcc\x01\x0e\x27\xc0\
\x5a\xe6\x63\x3b\x6a\xe1\xe2\x91\x1c\x3f\xfd\xf1\x77\xb0\xb1\xb9\
\x85\xcd\x8d\x75\xb4\x5a\x2d\x44\xdd\x36\x9a\xd0\x38\x73\xfc\x38\
\x82\x30\x74\x9f\xe1\x24\xcb\xa9\xeb\xdd\x1c\x31\xc6\x8c\x46\xb2\
\x86\x61\x40\x3d\x14\xd0\x05\x47\x3a\x89\x00\x8c\x1c\xf0\x03\x09\
\x66\x4a\x57\x0e\xc6\x04\xee\x7d\xf8\x08\x97\x2f\x5f\xc6\x60\x30\
\x70\x23\x76\x6a\x6a\x0a\xc7\x4e\x7c\xce\xcd\x81\x4f\x5b\x44\x19\
\xd0\xb5\x06\x0d\xb6\xfd\x9b\xf0\x63\xa7\xcc\x91\x06\xa3\x41\xc4\
\x19\x77\x83\x65\x7d\x7d\x9d\xc8\xdd\x97\xf1\xb8\xcd\x9c\xbe\x03\
\x93\x2e\x9f\x26\xab\xcf\xe0\xfb\xf2\x60\x01\x9c\x8d\x26\xa1\xe4\
\xee\x45\xce\x01\x03\x43\x84\xf4\xb1\x71\x1f\x19\x21\x04\xed\xc9\
\xee\xc9\x04\xf8\x1c\x01\x33\x28\xd2\x0e\x98\x19\xdb\xc0\x9e\xe1\
\x80\x13\xe0\xc8\x7d\xc1\x5d\x7d\x61\xc6\xdf\x89\x71\x8d\xff\x93\
\x15\x48\xa0\xfb\xf0\x06\x56\x97\xde\x47\xb7\xbb\xb2\x0e\x60\x68\
\x51\x3e\x53\x80\x10\x80\x27\xb9\x05\x95\xc0\x69\xfd\xaf\x17\xe9\
\x67\xfd\x16\xee\xfe\xed\x0f\xb8\x7f\xeb\xc1\xf6\xda\xda\x8d\xeb\
\x00\x56\x2c\x7a\xfb\xdf\x02\x3e\x6a\x42\xc9\x20\xe5\xbf\x32\x06\
\x14\x5d\xad\x34\xa5\x3e\x20\xfb\x69\xff\xa9\x25\x10\x82\xbb\x9a\
\x6b\x53\x62\xe5\xfa\x9f\x71\xef\xda\x72\x6f\x75\xe5\xd6\xad\xa2\
\x48\x48\xc0\x7b\x16\xdd\x7d\x05\xc0\x30\x67\x89\x20\x21\x16\x9c\
\x33\x68\xad\x31\x3b\x3b\x8b\x4b\x97\x2e\x61\x61\x61\x01\xd3\xd3\
\xd3\x68\x34\x1a\xee\x3f\x63\x29\x85\x8d\x9e\x7b\xe6\x5c\x20\xcf\
\x4b\x3c\x7d\x9a\x98\x76\xbb\xc7\xda\xed\x18\xbd\xdd\x0c\x77\xaf\
\x3d\x1a\x3e\x79\x7c\xe7\x4e\x92\x6c\xbd\x0d\xe0\x9a\xc5\x47\x16\
\xf9\x33\x07\x51\xa3\x0a\xcc\x1f\x06\xe2\xc3\x4d\x84\xba\x81\xbc\
\xc8\x71\xe1\xc2\x4b\x38\x7f\xfe\x05\x4b\x90\x43\x29\xed\x66\x7f\
\xb7\x9b\x22\x49\x62\xc4\x71\x86\x28\x4a\xcc\xf6\x76\x57\x6d\x6d\
\xed\x0c\xdb\xed\xad\x7e\xaf\x17\xc5\x69\xda\xe9\xc6\xf1\x56\x7b\
\x75\xf5\xe1\xd6\x60\xb0\xfb\x00\x00\x65\x7f\xdf\xa2\x6f\xec\xda\
\x57\x80\xe7\x4b\x7f\xd0\x4f\x71\xf5\xb7\xaf\x61\x63\xed\x09\xce\
\xce\x1f\x31\x0f\x1f\x6d\xe3\xf1\x4a\x8b\x45\x51\xdf\x92\x26\x26\
\x8a\x76\xcb\x4e\x27\xca\xba\xdd\x9d\x7e\x1c\xb7\xe3\x38\xde\x89\
\xba\xdd\xcd\x76\xbb\xbd\xd1\x4e\xd3\x5e\x44\x04\x16\xb1\x45\x6f\
\x14\x9f\x5a\xb4\x2c\x36\x69\x3f\x26\xdf\x4f\xc0\xe3\x47\x6b\x1b\
\x3f\xff\xc1\x2f\x16\xef\xbe\xf7\x7e\x91\x26\x59\xb1\x94\xdf\xcb\
\xae\xbc\xfe\xf7\x7e\xad\x86\xdd\x7e\x3f\xea\x46\xd1\x46\x7b\x67\
\x67\x6d\x7b\x38\x1c\x10\xc1\xee\x98\x64\x0c\xb7\x4f\x2c\x32\x8b\
\xe1\x9e\x98\x5b\xde\xf2\xc0\x49\x78\x6f\xe9\xf6\xcf\x7a\xbd\x27\
\x2f\xa7\x83\x56\x7d\x30\x88\x22\xad\x4b\x52\xdf\x27\xec\x21\x7c\
\x3a\x7a\x4e\x1d\xc1\x98\x64\x4c\xa4\x70\xf0\xda\x5f\xc0\xc3\x47\
\x7f\x7c\x1d\xc0\x3b\x16\xcd\x51\x26\xbd\xbd\x59\x7c\x8c\x48\x4f\
\xc8\x31\xb9\x80\x11\xe1\xf2\x68\x3e\x14\x23\x22\x83\xff\xe3\xfa\
\x27\x0a\xd7\x77\xe2\xf8\x4e\x6d\x80\x00\x00\x00\x00\x49\x45\x4e\
\x44\xae\x42\x60\x82\
\x00\x00\x06\xe8\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
\x00\x00\x00\x04\x67\x41\x4d\x41\x00\x00\xd6\xd8\xd4\x4f\x58\x32\
\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\x72\x65\
\x00\x41\x64\x6f\x62\x65\x20\x49\x6d\x61\x67\x65\x52\x65\x61\x64\
\x79\x71\xc9\x65\x3c\x00\x00\x06\x7a\x49\x44\x41\x54\x58\xc3\xed\
\x57\x09\x4c\x54\x57\x14\x1d\x6a\xed\xa6\x4d\x69\x69\xb5\x2e\x15\
\xf7\x1d\xb1\x20\x8a\x0a\x28\x2a\xb2\xa9\x88\xc0\x20\x28\x22\xae\
\xe0\x30\x08\x6e\x6c\x23\x42\x01\xc5\x71\x41\x76\x71\xa1\x0a\x28\
\xe2\x5a\xc0\x0a\x5a\x91\x60\xc0\x15\xad\x88\x68\xcd\x18\xd4\xaa\
\xd4\x5a\xb1\x2e\xe8\x8c\x0a\x9e\x9e\x0f\x3f\x8d\x52\x29\x9a\x9a\
\x36\x69\x9c\xe4\x64\x32\x33\xff\xdd\x73\xef\x39\xf7\xde\xff\x47\
\x02\x40\xf2\x5f\x42\xf2\x36\x81\xff\x65\x02\x66\x52\x85\x91\x99\
\x34\x58\x66\xea\x14\x14\x6f\xea\x18\x98\x66\xea\x18\x90\x3e\xd4\
\x7e\xc1\xaa\x81\xb6\xde\x93\x25\x12\xc9\xc7\x44\x33\xc9\x9b\x7e\
\x0d\x9b\x18\xd2\x97\xc4\x11\xc3\x9c\x17\x17\x7b\x2c\xdc\x7c\x39\
\x60\xf9\xe1\xdb\xa1\xd1\x17\xab\x15\x2b\xae\xa8\x15\xcb\xaf\xa8\
\x03\xa3\xce\x3c\x90\x29\x76\xdf\x1a\x6c\xe7\x97\x6f\x60\x31\x5d\
\xc6\x23\x9f\x10\xef\xbe\x01\xe2\xc5\x96\x24\x4d\x99\x34\x37\x59\
\x15\x91\x50\x76\x37\x3c\x41\x53\x2b\x0f\x07\x26\x2d\x00\xc6\x7a\
\x02\xa3\xa7\x02\x23\xdd\x00\x6b\x77\xc0\x7d\x1e\x10\x16\x5d\xf9\
\xc4\xc2\x75\xc9\xb5\xd6\xba\x7a\x52\x1e\xd7\xf9\xc7\xc4\xd3\x17\
\xa5\x56\x28\x93\xaf\x3e\x0c\x8c\x06\xdc\x02\x49\x24\x03\x4c\xa6\
\x01\x86\x93\x01\x3d\x29\xd0\xdb\x1e\xe8\x66\x4b\x8c\x06\xfa\xd9\
\x00\xd2\x39\xc0\x82\xf0\x22\x75\xaf\xc1\x13\x72\x18\xc6\xe0\xf5\
\x89\x9d\x17\xeb\x12\x8a\x49\xbe\xc9\xaa\x95\x1b\x49\xbc\x06\x70\
\x0d\x02\x2c\xe4\xc0\x50\x56\x6c\x4c\x0c\x64\x12\x83\xbc\x09\x92\
\xe9\x7b\x00\x3d\x5d\x80\x4e\x63\x00\x5d\x0b\x60\x88\x13\x10\x10\
\xa5\x7e\x36\xd0\x56\x56\xc9\x70\x4e\xaf\x45\x3e\x7c\x62\x88\xdc\
\xc6\x23\xaa\x2c\x3c\xbe\xa4\x2a\x3c\x19\x98\xba\x84\x15\xfb\x01\
\x66\x73\x89\xf9\x94\x5b\x01\xd8\x47\x01\x93\xa9\xc6\xd4\x38\x26\
\xc6\xf7\x71\xdf\x50\x11\x5f\xa0\xef\x14\xa0\xab\x1d\x60\xe4\x0c\
\xcc\xa5\x45\xe6\x4e\x01\x77\x19\xd2\xf7\xb5\xaa\x96\x2d\xd9\x71\
\x35\x26\x5d\x53\xeb\x4d\x92\xf1\x01\xf4\x96\xa4\x23\xfc\x01\x9b\
\x08\x92\x92\x70\x7e\x3a\xb0\x7c\x2f\xb0\xbe\x10\xd8\x54\x04\x24\
\xfc\x00\xf8\x6f\xa5\xec\x2b\xa8\x0e\x13\xed\xc3\x5e\x18\xcc\x5e\
\xf0\x5d\xc6\xe4\xbc\xe3\xab\x19\x5a\xf1\x0a\xe4\x0a\x27\xa1\xea\
\xc8\xc4\x92\xaa\x88\x75\x24\x0a\x63\xd5\x24\x1d\x45\xbf\x6d\x22\
\xd9\x6c\x09\xf4\x74\x1b\x10\x7b\x08\xc8\x2a\x03\xb6\x1e\x54\xd5\
\x84\xc4\xee\x51\x7b\x2c\x88\x7b\x18\xb9\x2e\x4f\xb3\xbd\x84\x92\
\x67\x50\x09\x5e\x6b\x4c\x6b\x46\xd1\x2a\x45\x2c\xed\x19\x23\xbf\
\xc7\xf0\x4b\xfe\x1c\x1f\x8e\x86\x31\xbf\xf8\x88\xd0\x7a\x5e\x72\
\x07\xcf\x98\x0b\xb1\x69\x37\x35\xf3\xe9\xb5\x53\x08\x60\x49\x99\
\xad\x59\xb1\x34\x06\x90\xb1\x62\xe5\x01\x60\x57\x29\xb0\xad\x40\
\x55\x33\xc6\x23\xf4\x41\x5f\xd3\x89\x57\x3b\xf4\x1a\x5a\xac\xd3\
\xae\xfb\x4e\x36\xda\xb1\xb5\xbb\x4a\x34\x89\xf9\xb4\x24\x91\x7d\
\x12\x54\x1f\x63\x55\x9a\xfa\x99\x91\xb5\xe7\xed\x3a\x05\x04\xf2\
\xc4\xd4\xb2\xdf\x0d\x2d\x67\x6d\xea\xd2\xdf\x62\xbc\xb8\x28\xb4\
\x98\x58\xf0\x0c\xff\xd4\x8a\xd8\x2d\x9a\x5a\x2f\x25\xbd\xe5\x41\
\x2b\xfa\x69\xbf\x0a\xf0\x48\x61\x15\x39\x40\xca\x31\x20\xfb\xf4\
\x9d\x5a\x59\xe8\x86\x47\x02\xf1\x97\x9d\xf4\xf3\x79\x76\x39\xe1\
\x45\x8c\x63\x3c\x7f\xdf\xc8\xf4\xdf\x32\x4f\x02\x3e\xa9\x4c\x9a\
\x71\x7c\xe3\x81\xc8\xa4\x13\x4f\xba\x1b\x8d\x39\xcf\x6b\xfc\x04\
\x05\x4a\x0b\x8f\x30\xab\x75\xa7\x1f\xe9\x9b\xbb\x65\xe9\x99\xb9\
\xc8\xb9\xc1\xb6\xf9\x45\xe4\x5c\x57\x6e\x06\xa6\xd1\x6f\x3b\xca\
\x6e\xcb\x77\x97\x24\x40\x9e\x09\xac\x2c\x00\xf6\x94\x03\x69\xfb\
\xcb\x9e\x8e\x70\xf6\xbf\xdf\xa1\xb7\x49\x09\x83\xad\x21\x3c\x09\
\x73\xa2\x33\xf1\x59\xff\x11\xee\x16\x5e\x21\x29\xd7\x77\xfd\x48\
\x1b\xb6\x53\x31\x5a\x18\x9f\x45\x05\xdd\x42\x1f\x68\xb7\xea\xb8\
\x9b\xd7\xb8\x08\x0d\x56\x96\xcb\x80\x2b\xf9\xa3\x97\xe2\x94\xda\
\x78\x9c\xef\x85\xf0\xa4\xeb\x1a\x7f\x7a\xeb\xb6\x94\xcb\x84\x72\
\xdb\x0b\x5d\xfd\x2d\x83\xb0\xc1\xd6\x1e\x07\xf2\xca\xd5\xcf\x16\
\x29\xb7\x70\x96\xed\x2b\x3e\x6f\xdf\x63\x5f\x9d\x97\x12\x89\x1d\
\xd1\xf5\xf9\x55\x6b\xe2\xb0\x68\xda\xb2\x0d\xfb\x7f\xcd\x64\x1f\
\x84\x91\x58\xf9\x1d\x10\x9e\x74\xf8\x71\x57\x03\x2b\xa1\xfa\x30\
\xc2\x58\xb0\xe0\xdc\xae\x5c\x60\x4e\x28\x3b\xdb\x07\x70\x5c\x54\
\x5d\xeb\x42\x52\x07\x62\x1c\xbb\x55\x4a\xc9\x66\x6d\x01\x42\xe9\
\x75\x2a\x2b\xc9\x2d\xbb\x53\x3b\x51\xae\xac\xee\xd4\x6f\x44\x29\
\x03\xc4\x10\x33\x89\x21\x44\xeb\x86\xab\x55\xb8\x17\x64\x1c\xbc\
\x58\x9d\xce\xa4\xe3\x38\x11\x69\x07\xef\xd4\x9a\x3b\xf9\xdf\x6f\
\xa1\xdd\x3a\x93\x3f\xbb\x12\x6d\xeb\x12\xd8\xb9\x9f\xbe\x72\xa6\
\x4d\xbc\x00\x53\x8e\x8b\x55\x58\x7d\xd5\x93\xd6\x03\x9e\x94\x6e\
\x29\x3b\x3c\x93\x92\xe7\x9c\xba\x51\x23\x4a\x7e\x92\x87\x95\x84\
\x83\x58\x75\x0b\xe2\x9d\x86\xf7\x06\xa9\x3c\xe6\x42\xf1\x65\x36\
\x28\x7b\x60\xe7\x51\xf5\x33\x47\x2f\x65\xb5\x78\x36\x98\x30\x24\
\x3e\xa8\x4b\x60\x0f\x09\x66\x2b\xeb\x67\x7a\x24\x95\xb0\x67\x87\
\x4f\xa1\xff\x3e\x94\x2c\x92\x33\x9d\x41\xf2\xb5\x59\x27\x9e\x8c\
\x24\x79\xbb\x6e\x03\x8f\xf0\x60\x24\x31\x96\x68\xdf\xd8\x0d\x45\
\x68\xee\xf4\xbc\xb2\xbb\x85\x2a\x20\xff\x02\x30\x2f\x72\x8b\x5a\
\x54\x4d\x48\xdc\x96\xf8\xa2\x6e\xe2\x84\x04\x72\x8a\xd9\x9d\xdc\
\x6c\x76\x4c\xc2\x81\x92\x4f\xe5\x78\x79\xd3\xb3\x10\xf6\x46\xf2\
\x19\x56\x70\xec\x46\x0d\x1b\xb4\x52\xbb\x95\x6e\x8e\xb8\x3c\xac\
\x88\x36\x8d\x91\x0b\xbb\xc3\xc3\x3f\x59\x55\xfe\x0b\x70\xfa\x2a\
\xf7\xc4\xd2\xad\x8f\x44\xdf\x57\x13\x13\x5e\x48\x5c\x48\x20\xef\
\x14\xc7\x8a\xdd\xed\xbe\x11\x98\xc1\xa5\x31\x97\xcd\x16\x4c\x55\
\xa2\x38\x66\x6b\x0a\xea\xc9\xdb\x77\x1f\x54\xc8\xcb\x17\x0a\xd6\
\x8a\xd9\xbf\xbc\x72\xa7\x20\x1d\x26\xb0\xf3\x50\xe9\x4d\x4d\x79\
\x25\xc9\xa3\xb6\x3e\x14\xc9\x85\x7e\x11\xee\x80\xba\x2f\x9c\x15\
\x12\x28\xa2\x44\x71\x5c\x16\x41\x9c\xed\xc5\x6c\xb6\x65\x5c\xa3\
\xd1\xec\xdc\xb5\xdc\x6c\x99\x97\xb8\x52\xb3\x4e\x3e\xee\x3d\x64\
\xc2\x51\x9d\xb6\xdd\x3c\xc5\xec\x1b\x7d\xa0\x60\xbc\x39\x71\x19\
\x45\xb7\x4a\x2a\x34\xb5\xce\xb2\x15\xf7\xba\x19\x5a\x97\x8b\x23\
\xea\x4c\x74\x24\x9a\x37\x3c\x70\xee\xec\xcf\xc0\xc1\x9f\x48\x56\
\x5a\xdf\x6c\x7b\xe8\x5b\x76\x05\xb0\x8f\xf2\x15\xdc\x00\xce\x56\
\x01\xeb\x76\x17\xa9\xfb\x98\x48\x77\xf0\x48\x1f\xe2\xfd\x46\x1e\
\x4a\xec\x42\x13\xf7\x5e\xcb\x3f\x7d\x53\x33\x76\x7a\xc4\xed\xce\
\xfa\xa3\x84\xfd\xb0\x52\xbc\xeb\xfd\x95\x5c\x9c\xd5\x8c\xec\xa2\
\xcb\x9a\xec\xe2\x4b\x4f\xb3\x8a\x54\x35\xd9\x47\x55\x35\x39\xc4\
\xde\x63\xc4\x71\x55\xcd\xf7\x44\xee\x09\x01\x97\x9e\xba\xfa\xae\
\xae\x6a\xa5\xab\xe7\x23\xfa\xaf\xd5\xe0\xf9\xa0\x87\x47\xc0\xfa\
\x8b\xab\xd3\x0a\xab\x0c\x2d\x67\x9e\xfb\xaa\xe7\xe0\x03\xfc\x3a\
\x82\xb0\x17\x65\x6f\xfe\x52\xc9\x0c\x46\xcf\x70\x19\x60\x35\xbb\
\xa0\xdf\xf0\xc9\xe7\xf5\xcc\x5c\x2f\x35\x8a\x61\xae\xaa\x36\x5d\
\x0c\x72\xc4\xb9\xef\xf2\x12\x1b\x9a\x75\x37\xb2\x35\xef\x3d\xd4\
\x71\xe3\x87\x2d\x3f\x8d\xe2\x67\x39\x31\x92\x68\xd7\xd4\xa3\x97\
\xb0\xb9\x06\x88\x8b\x61\x76\x13\x70\x13\x44\x13\x1f\xa5\xb4\x1a\
\xc4\x11\x3e\x6b\x13\x5f\x0b\xf7\x31\xd1\x2a\xed\x57\x79\xee\x6b\
\x26\x26\xd1\x46\x6c\xb0\xbf\x43\x9b\x26\x9e\x6a\xb5\xea\x96\x8b\
\x44\xd2\x92\x78\xef\x25\x49\xfe\xfb\xaf\xb7\xff\x8c\xde\x26\xd0\
\x14\xfe\x00\xc6\x8f\x6d\x5f\x51\xaa\x96\x24\x00\x00\x00\x00\x49\
\x45\x4e\x44\xae\x42\x60\x82\
"

qt_resource_name = b"\
\x00\x06\
\x07\x03\x7d\xc3\
\x00\x69\
\x00\x6d\x00\x61\x00\x67\x00\x65\x00\x73\
\x00\x09\
\x00\x57\xb8\x67\
\x00\x70\
\x00\x72\x00\x69\x00\x6e\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x07\
\x04\xca\x57\xa7\
\x00\x6e\
\x00\x65\x00\x77\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x08\xc8\x58\x67\
\x00\x73\
\x00\x61\x00\x76\x00\x65\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x04\xb2\x58\xc7\
\x00\x75\
\x00\x6e\x00\x64\x00\x6f\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x04\x00\x00\x00\x02\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x00\x54\x00\x00\x00\x00\x00\x01\x00\x00\x12\x07\
\x00\x00\x00\x2a\x00\x00\x00\x00\x00\x01\x00\x00\x06\xc8\
\x00\x00\x00\x3e\x00\x00\x00\x00\x00\x01\x00\x00\x0a\x9d\
"
</t>
<t tx="1.20130426141258.3654">def qInitResources():
    QtCore.qRegisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
</t>
<t tx="1.20130426141258.3655">def qCleanupResources():
    QtCore.qUnregisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
</t>
<t tx="1.20130426141258.3656">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3657">from PyQt5 import QtCore, QtGui, QtWidgets
from Generic.Kernel.document import *
from Interface.LayerIntf.layerdock  import LayerDock
from Interface.cadscene             import CadScene
from Interface.cadview              import CadView
</t>
<t tx="1.20130426141258.3658">class IDocument(QtWidgets.QMdiSubWindow):
    sequenceNumber = 1
    @others
</t>
<t tx="1.20130426141258.3659">def __init__(self, document, cmdInf, parent):
    super(IDocument, self).__init__(parent)
    IDocument.sequenceNumber += 1
    self.__document=document
    self.__document.handledErrorEvent+=self._errorEvent
    self.__cmdInf=cmdInf
    self.__cadwindow=parent
    self.setWindowTitle(document.dbPath + '[*]')
    self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
    self.isUntitled = True
    # layer list
    self.__layer_dock = LayerDock(self,self.__document)
    self._scene = CadScene(document, parent=self)
    self.__cmdInf.commandLine.evaluatePressed+=self.scene.textInput
    self.__view = CadView(self._scene, self)
    # the graphics view is the main/central component
    innerWindows = QtWidgets.QMainWindow()
    innerWindows.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.__layer_dock)
    innerWindows.setCentralWidget(self.__view)
    self.setWidget(innerWindows)
    #Inizialize scene
    self._scene.initDocumentEvents()
    self._scene.populateScene(document)
    self._scene.zoomWindows+=self.__view.zoomWindows
    self._scene.fireCommandlineFocus+=self.__cmdInf.commandLine.setFocus
    self._scene.fireKeyShortcut+=self.keyShortcut
    self._scene.fireKeyEvent+=self.keyEvent
    self._scene.fireWarning+=self.popUpWarning
    self._scene.fireCoords+=self.setStatusbarCoords
</t>
<t tx="1.20130426141258.3660">@property
def document(self):
    return self.__document
</t>
<t tx="1.20130426141258.3661">@property
def cmdInf(self):
    return self.__cmdInf
</t>
<t tx="1.20130426141258.3662">@property
def view(self):
    return self.__view
</t>
<t tx="1.20130426141258.3663">@property
def scene(self):
    return self._scene
</t>
<t tx="1.20130426141258.3664">@property
def application(self):
    """
    get the kernel application object
    """
    return self.__application
</t>
<t tx="1.20130426141258.3665">@property
def layerDock(self):
    """
    get the layer tree dockable window
    """
    return self.__layer_dock
</t>
<t tx="1.20130426141258.3666">@property
def fileName(self):
    """
        get the current file name
    """
    return self.document.dbPath
</t>
<t tx="1.20130426141258.3667">def unDo(self):
    """
        perform undo on the active document
    """
    self.document.unDo()
    self.__layer_dock.RefreshStructure()
</t>
<t tx="1.20130426141258.3668">def reDo(self):
    """
        perform redo on the active document
    """
    self.document.reDo()
    self.__layer_dock.RefreshStructure()
</t>
<t tx="1.20130426141258.3669">def importExternalFormat(self, file):
    """
        import an external document
    """
    self.document.importExternalFormat(file)
</t>
<t tx="1.20130426141258.3670">def renderCurrentScene(self, painter):
    """
        render the current scene for the printer
    """
    self.view.render(painter)
</t>
<t tx="1.20130426141258.3671">def wWellEWvent(self, event):
    self.__view.scaleFactor=math.pow(2.0, -event.delta() / 240.0)
    self.__view.scaleView(self.__view.scaleFactor)
</t>
<t tx="1.20130426141258.3672">def popUpWarning(self, msg):
    """
        popUp a warning mesage
    """
    ret = QtWidgets.QMessageBox.warning(self,"Warning",  msg)
    return
</t>
<t tx="1.20130426141258.3673">def popUpInfo(self, msg):
    """
        popUp a Info mesage
    """
    ret = QtWidgets.QMessageBox.information(self,"Information",  msg)
    return
</t>
<t tx="1.20130426141258.3674">def _errorEvent(self, err):
    """
        executed when the document rise an error
        the err is a dictionary like the one below
        _err={'object':, 'error':}
    """
    msgBox=QtWidgets.QMessageBox(self)
    msgBox.setIcon(QtWidgets.QMessageBox.Critical)
    msg="Error came from object %s"%(str(err['error']))
    dmsg=msg
    for _e in err['object'].getErrorList():
        dmsg=dmsg+"\n"+str(_e)
    msgBox.setWindowTitle("Error !!")
    msgBox.setText(msg)
    msgBox.setDetailedText(dmsg)
    msgBox.exec_()
    return
</t>
<t tx="1.20130426141258.3675">#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------MANAGE SCENE EVENTS
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def setStatusbarCoords(self, x, y, status):
    #set statusbar coordinates when mouse move on the scene
    if status=="abs":
        self.__cadwindow.coordLabel.setText("X="+str("%.3f" % x)+"\n"+"Y="+str("%.3f" % y)) # "%.3f" %  sets the precision decimals to 3
    elif status=="rel":
        self.__cadwindow.coordLabel.setText("dx="+str("%.3f" % x)+"\n"+"dy="+str("%.3f" % y)) # "%.3f" %  sets the precision decimals to 3
</t>
<t tx="1.20130426141258.3676">def keyEvent(self, event): #fire the key event in the scene to the commandline
    self.__cmdInf.commandLine._keyPress(event)
</t>
<t tx="1.20130426141258.3677">def keyShortcut(self, command):
    self.__cadwindow.statusBar().showMessage(str(command))
    self.__cadwindow.callCommand(command)
</t>
<t tx="1.20130426141258.3678">#
# Copyright (c) 2010 Matteo Boscolo, Gertwin Groen
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module contain global functions
#

# This is only needed for Python v2 but is harmless for Python v3.
#import sip
#sip.setapi('QString', 2)


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3679">from PyQt5 import QtGui, QtWidgets
</t>
<t tx="1.20130426141258.3680">class PyCadApp(object):
    '''
    PyCadApp contain static interface functions to the kernel application object.
    '''

    # kernel application object
    __application = None
    # main application window
    __cad_window = None
    
    
    @others
</t>
<t tx="1.20130426141258.3681">@staticmethod
def CadWindow():
    '''
    Gets the main window.
    The main window is an instance of the CadWindow object.
    '''
    return PyCadApp.__cad_window
</t>
<t tx="1.20130426141258.3682">@staticmethod
def SetCadWindow(cad_window):
    '''
    Sets the main window.
    The main window is an instance of the CadWindow object.
    '''
    PyCadApp.__cad_window = cad_window
</t>
<t tx="1.20130426141258.3683">@staticmethod
def Application():
    '''
    Gets the application object from the kernel.
    '''
    return PyCadApp.__application
</t>
<t tx="1.20130426141258.3684">@staticmethod
def SetApplication(application):
    '''
    Sets the application object from the kernel.
    '''
    PyCadApp.__application = application
</t>
<t tx="1.20130426141258.3685">@staticmethod
def ActiveDocument():
    '''
    Gets the current active document in the editor.
    '''
    if not PyCadApp.__application is None:
        return PyCadApp.__application.ActiveDocument
    return None
</t>
<t tx="1.20130426141258.3686">@staticmethod
def CreateNewDocument():
    '''
    Create a new document.
    '''
    if not PyCadApp.__application is None:
        PyCadApp.__application.newDocument()
        return PyCadApp.__application.ActiveDocument
    return None
</t>
<t tx="1.20130426141258.3687">@staticmethod
def OpenDocument(filename):
    '''
    Open an existing document.
    '''
    print("filename is:", filename)
    return None
    '''
    if not PyCadApp.__application is None:
        PyCadApp.__application.openDocument(filename)
        # return the opened, current active document
        return PyCadApp.ActiveDocument()
    return None
    '''
</t>
<t tx="1.20130426141258.3688">@staticmethod
def critical(text):
    '''
    Shows an critical message dialog
    '''
    dlg = QtWidgets.QMessageBox()
    dlg.setText(text)
    dlg.setIcon(QtWidgets.QMessageBox.Critical)
    dlg.exec_()
    return
</t>
<t tx="1.20130426141258.3689">@language python
@tabwidth -4
@others
#
# Copyright (c) 2002, Art Haas
#

#
# don't define an __all__ variable - the value of importing
# different front-end interfaces into a module seems very
# low right now ...
#
</t>
<t tx="1.20130426141258.3690"></t>
<t tx="1.20130426141258.3691">'''
Created on May 12, 2010

@author: gertwin
'''

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3692"># This is only needed for Python v2 but is harmless for Python v3.
#import sip
#sip.setapi('QString', 2)

from PyQt5 import QtCore, QtGui, QtWidgets
</t>
<t tx="1.20130426141258.3693">class CmdAction(QtWidgets.QAction):
    '''
    Derived action class to hold a command name.
    The FunctionHandler class handles signals emitted by this class.
    '''
    @others
</t>
<t tx="1.20130426141258.3694">def __init__(self, command, icon, text, parent, function_handler):
    '''
    Parameters:
        command: name of the command.
        function_handler: reference to the function_handler object. 
    '''
    if not icon is None:
        super(CmdAction, self).__init__(icon, text, parent, triggered=self._actionHandler)
    else:
        super(CmdAction, self).__init__(text, parent, triggered=self._actionHandler)
    # command name
    self.__command = command
    # function handler
    self.__function_handler = function_handler
    # visible 
    self.__visible=True
    return
</t>
<t tx="1.20130426141258.3695">def show(self):
    """
        show the command 
    """
    self.setEnabled(True)
</t>
<t tx="1.20130426141258.3696">def hide(self):
    """
        hide the command
    """
    self.setEnabled(False)
</t>
<t tx="1.20130426141258.3697">@property   
def command(self):
    """
        get the command name
    """
    return self.__command
</t>
<t tx="1.20130426141258.3698">def _actionHandler(self):
    '''
    All actions are handled by the function handler.
    From the function handler the command call-back is called.
    '''
    self.__function_handler.evaluate(self.__command)
    return
</t>
<t tx="1.20130426141258.3699">#
# Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Art Haas
# Copyright (c) 2009, 2010 Matteo Boscolo, Gertwin Groen
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the termscl_bo of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#




@language python
@tabwidth -4
@others
</t>
<t tx="1.20130426141258.3700">class CmdCategory(object):
    '''
    Defines all possible categories for the user input interface
    A category represents a menu or a tool-bar.
    '''
    @others
</t>
<t tx="1.20130426141258.3701">def __init__(self, main_window):
    '''
    Create category attributes from a string.
    Adding a category is adding it to the string categories.
    '''
    # list with menus
    self.__menus = {}
    # list with tool-bars
    self.__toolbars = {}
    # categories defines all possible categories
    self.__categories = 'File Edit Draw Dimension Modify View Snap Tools Windows Help'
    # create attributes from the categories string
    for number, category in enumerate(self.__categories.split()):
        # create menu
        menu_name = '&amp;' + category
        menu = main_window.menuBar().addMenu(menu_name)
        self.__menus[number] = menu
        # create tool-bar
        toolbar = main_window.addToolBar(category)
        toolbar.setObjectName(category)  #this is needed for remember toolbar position in cadwindow.writesettings(savestate)
        self.__toolbars[number] = toolbar
        # set attribute for category
        setattr(self, category, number)
    return
</t>
<t tx="1.20130426141258.3702">def getMenu(self, number):
    '''
    Gets an menu from the list.
    The number is the enumerated number from the categories string
    '''
    if number in self.__menus:
        return self.__menus[number]
    return None
</t>
<t tx="1.20130426141258.3703">@property
def getToolbarList(self):
    return self.__toolbars
</t>
<t tx="1.20130426141258.3704">def getToolbar(self, number):
    '''
    Gets an tool-bar from the list.
    The number is the enumerated number from the categories string
    '''
    if number in self.__toolbars:
        return self.__toolbars[number]
    return None
</t>
<t tx="1.20130426141258.3705">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3706">import os
import sys

# This is only needed for Python v2 but is harmless for Python v3.
#import sip
#sip.setapi('QString', 2)

from PyQt5 import QtCore, QtGui

from Interface.CmdIntf.cmdcategory  import CmdCategory
from Interface.CmdIntf.cmdaction    import CmdAction
from Interface.CmdIntf.cmdlinedock  import CmdLineDock
</t>
<t tx="1.20130426141258.3707">class CmdIntf(object):
    '''
    Future implementation:
        Dynamic read menu, toolbars and panels from a cui/xml definition file.
    Current implementation:
        Create static menu, toolbars and palettes.
    '''
    @others
</t>
<t tx="1.20130426141258.3708">def __init__(self, parent):
    # parent is the main_window object
    self.__main_window = parent
    # command line window
    self.__edit_ctrl = CmdLineDock('Command', self.__main_window)
    # dictionary with file action objects
    self.__actions = {}
    # categories in which commands are stored
    self.__category = CmdCategory(self.__main_window) 
    # icons search path
    self.__icon_dir = os.path.join(os.getcwd(), 'icons')
    #add custom event
    return
</t>
<t tx="1.20130426141258.3709">#-------- properties -----------#
@property
def commandLine(self):
    """
        Get the command line dock window
    """
    return self.__edit_ctrl
</t>
<t tx="1.20130426141258.3710">@property
def FunctionHandler(self):
    """
        Get the function handler object
    """
    return self.__edit_ctrl.FunctionHandler
</t>
<t tx="1.20130426141258.3711">@property 
def Category(self):
    """
        Get the category enumerator object
    """
    return self.__category   
</t>
<t tx="1.20130426141258.3712">#-------- properties -----------#
@QtCore.pyqtSlot(str)
def _actionHandler(self, expression):
    '''
    Callback function for all QAction objects.
    1) Look up command in the dictionary.
    2) Execute command by calling the FunctionHandler.Evaluate member.
    '''
    # evaluate command
    if len(expression) &gt; 0:
        # command is found, evaluate it
        self.__edit_ctrl.FunctionHandler.evaluate(expression)
    return
</t>
<t tx="1.20130426141258.3713">def _getIcon(self, cmd):
    '''
    Create an QIcon object based on the command name.
    The name of the icon is ':/images/' + cmd + '.png'.
    If the cmd = 'Open', the name of the icon is ':/images/Open.png'.
    '''
    icon_name = cmd + '.png'
    icon_path = os.path.join(self.__icon_dir, icon_name)
    # check if icon exist
    if os.path.exists(icon_path):
        icon = QtGui.QIcon(icon_path)
        return icon
    # icon not found, don't use an icon, return None
    return None
</t>
<t tx="1.20130426141258.3714">def registerCommand(self, category_enum, cmd, text=None, callback=None):
    '''
    Register a command with it's call-back in the command table.
    Commands are executed by a call to the evaluate function.
    params:
        category_enum: enumerated attribute value of CmdCategory
        cmd: command name
        text: menu entry text 
        callback: call-back function
    '''
    # get the menu for this category
    menu = self.__category.getMenu(category_enum)
    # get the tool-bar for this category
    toolbar = self.__category.getToolbar(category_enum)
    # Check for the special separator name: '-'
    # A separator is not a command, it defines an separator in the menu and tool-bar.
    if cmd == '-':
        # add a separator to the menu
        if not menu is None:
            menu.addSeparator()
\\-4.#            # add a separator to the tool-bar
        if not toolbar is None:
            toolbar.addSeparator()
    elif cmd=='&gt;':
        #add subMenu
        pass
    else:
        # register the command with the function handler
        self.__edit_ctrl.FunctionHandler.registerCommand(cmd, callback)
        # get an icon for command, needed for tool-bar
        icon = self._getIcon(cmd)
        # create action object for this command
        action = CmdAction(cmd, icon, text, self.__main_window, self.__edit_ctrl.FunctionHandler)
        #action.callback = self._actionHandler
        # add it to the action table for fast lookup
        self.__actions[cmd] = action
        # add action to menu
        if not menu is None:
            menu.addAction(action)
        # add action to tool-bar only if an icon if found
        if (not toolbar is None) and (not icon is None):
            toolbar.addAction(action)
    return
</t>
<t tx="1.20130426141258.3715">def evaluate(self, expression):
    '''
    Looks up the expression from the command table.
    If a command is found, it's callback function is called.
    If it is not a command the expression is evaluated.
    Return: command exit, the evaluated expression or "*error*"
    '''    
    self.__edit_ctrl.FunctionHandler.evaluate(expression)
    return
</t>
<t tx="1.20130426141258.3716">def evaluateInnerCommand(self, kernelCommand, selectedItems):
    '''
        evaluate a kernel command
    '''
    self.__edit_ctrl.FunctionHandler.evaluateInnerCommand(kernelCommand, selectedItems)
</t>
<t tx="1.20130426141258.3717">def evaluateMouseImput(self,view,event):
    '''
        get imput from viewport
    '''
    self.__edit_ctrl.FunctionHandler.evaluateMouseImput(event)
</t>
<t tx="1.20130426141258.3718">def resetCommand(self):
    """
        reset the active command 
    """
    self.__edit_ctrl.FunctionHandler.resetCommand()
</t>
<t tx="1.20130426141258.3719">def hideAction(self, name):
    """
        hide the name action
    """
    if name in self.__actions:
        self.__actions[name].hide()
</t>
<t tx="1.20130426141258.3720">def showAction(self, name):
    """
        show the name action
    """
    if name in self.__actions:
        self.__actions[name].show()
</t>
<t tx="1.20130426141258.3721">def setVisible(self, name, value):
    """
        set the action name to visible value
    """
    if name in self.__actions:
        if value:
            self.__actions[name].show()
        else:
            self.__actions[name].hide()
</t>
<t tx="1.20130426141258.3722">def updateText(self, name, text):
    """
        update the label text
    """
    if name in self.__actions:
        self.__actions[name].setText(text)
</t>
<t tx="1.20130426141258.3723"># This is only needed for Python v2 but is harmless for Python v3.
#import sip
#sip.setapi('QString', 2)



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3724">from PyQt5 import QtCore, QtGui, QtWidgets
from Interface.CmdIntf.functionhandler import FunctionHandler
from Kernel.pycadevent import PyCadEvent
</t>
<t tx="1.20130426141258.3725">class CmdLineDock(QtWidgets.QDockWidget):
    '''
        A dockable window containing a edit line object.
        The edit line is used to enter commands or expressions.
    '''
    @others
</t>
<t tx="1.20130426141258.3726">def __init__(self, title, parent):
    '''
        Creates an edit line in which commands or expressions are evaluated.
        Evaluation of expressions is done by the FunctionHandler object.
    '''
    super(CmdLineDock, self).__init__(title, parent)
    self.setMinimumHeight(100)
    self._remainder=[]
    self._remainderIndex=0
    # only dock at the bottom or top
    self.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
    self.dockWidgetContents = QtWidgets.QWidget()
    self.dockWidgetContents.setObjectName("dockWidgetContents")
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Ignored)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.dockWidgetContents.sizePolicy().hasHeightForWidth())
    self.dockWidgetContents.setSizePolicy(sizePolicy)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.dockWidgetContents)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    
    self.textEditOutput=PyCadTextView(self.dockWidgetContents)
    
    self.verticalLayout_2.addWidget(self.textEditOutput)
    self.__edit_ctrl = QtWidgets.QLineEdit(self, returnPressed=self._returnPressed)
    self.__edit_ctrl.keyPressEvent=self._keyPress
    
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.textEditOutput.sizePolicy().hasHeightForWidth())
    self.__edit_ctrl.setSizePolicy(sizePolicy)
    self.verticalLayout_2.addWidget(self.__edit_ctrl)
    self.setWidget(self.dockWidgetContents)
    self.__function_handler = FunctionHandler(self.__edit_ctrl,self.textEditOutput )
    #QtCore.QObject.connect(self.__edit_ctrl, QtCore.SIGNAL("returnPressed()"), self.textEditOutput.centerCursor)
    #
    self.evaluatePressed=PyCadEvent()
    
    self.setObjectName("CmdLineDock") #this is needed for remember toolbar position in cadwindow.writesettings(savestate)
</t>
<t tx="1.20130426141258.3727">#-------- properties -----------#
@property
def FunctionHandler(self):
    """
        Get the function handle object
    """
    return self.__function_handler
</t>
<t tx="1.20130426141258.3728">#-------- functions -----------#

def _returnPressed(self):
    '''
    Text entered on the command line is accepted by the user by pressing the return button
    '''
    expression = self.__edit_ctrl.text()
    self._remainder.append(expression)
    self._remainderIndex=len(self._remainder)
    self.evaluate(expression)
</t>
<t tx="1.20130426141258.3729">def _keyPress(self, keyEvent):
    """
        keyPressEvent
    """
    if keyEvent==QtGui.QKeySequence.MoveToNextLine:
        if self._remainderIndex&lt;len(self._remainder)-1:
            self._remainderIndex+=1
            self.__edit_ctrl.clear()
            self.__edit_ctrl.setText(self._remainder[self._remainderIndex])
        
    elif keyEvent==QtGui.QKeySequence.MoveToPreviousLine:
        if self._remainderIndex&gt;0:
            self._remainderIndex-=1
            self.__edit_ctrl.clear()
            self.__edit_ctrl.setText(self._remainder[self._remainderIndex])
    else:
        QtWidgets.QLineEdit.keyPressEvent(self.__edit_ctrl, keyEvent)
</t>
<t tx="1.20130426141258.3730">def evaluate(self, expression):
    '''
    Let the function handler evaluate the expression.
    * Commamds are executed.
    * Expressions are evaluated, the result is placed in the command line edit field.
    '''
    # evaluate the expression
    result = self.__function_handler.evaluate(expression)
    self.evaluatePressed(expression) # fire event 
    return result
</t>
<t tx="1.20130426141258.3731">def setFocus(self, scene, event):
    """
        set the focus into the text imput
    """
    self.__edit_ctrl.clear()
    self.__edit_ctrl.setFocus()
</t>
<t tx="1.20130426141258.3732">def printMsg(self, msg):
    """
        Print message in to the message windows
    """
    self.textEditOutput.printMsg(msg)
</t>
<t tx="1.20130426141258.3733">class PyCadTextView(QtWidgets.QTextEdit):
    """
        this class represent the text view that pyCad use for rendering the output
    """
    @others
</t>
<t tx="1.20130426141258.3734">def __init__(self, parent):
    super(PyCadTextView, self).__init__(parent)
    self.setObjectName("textEditOutput") 
    self.setReadOnly(True) 
    self.ensureCursorVisible()
</t>
<t tx="1.20130426141258.3735">def contextMenuEvent(self, event):
    menu = self.createStandardContextMenu(event.pos());
    clearAction=QtWidgets.QAction("Clear", self, triggered=self.clear)
    menu.addAction(clearAction);
    menu.exec_(event.globalPos())
    del(menu)
</t>
<t tx="1.20130426141258.3736">def printMsg(self, msg):
    """
        print a message withouth formatting in the last row
    """
    self.append(str(msg))
    self.scrollToBottom()
</t>
<t tx="1.20130426141258.3737">def scrollToBottom(self):    
    """
        scroll the qttext to the end
    """
    sb = self.verticalScrollBar()
    sb.setValue(sb.maximum())
</t>
<t tx="1.20130426141258.3738">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
# Copyright (c) 2010 Gertwin Geon
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module Provide custom exception for the db module and kernel
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3739">from Kernel.GeoEntity.point     import Point
from Kernel.GeoUtil.geolib      import Vector
from Kernel.pycadevent          import PyCadEvent
from Kernel.unitparser          import  convertLengh, convertAngle

from Interface.DrawingHelper.evaluator      import Evaluator
from Interface.Preview.factory              import getPreviewObject
</t>
<t tx="1.20130426141258.3740">class FunctionHandler(object):
    '''
        This object contains all known commands.
        Commands are registered by "registerCommand" before the are available.
        Evaluation of commands or expressions is done by "evaluate"
    '''
    @others
</t>
<t tx="1.20130426141258.3741">def __init__(self, edit_ctrl, edit_output):
    '''
        Defines an dictionary containing all known commands.
        Member 'registerCommand' add's a command to the table.
        Member 'evaluate' execute a command by call its call-back or evaluates an expression.
    '''
    # Input control
    self.__edit_ctrl = edit_ctrl
    # Output Control
    self.__edit_output=edit_output
    # current value
    self._value = None
    # command table
    self._command_table = {}
    # Global inner command evaluation
    self.evaluateInner=None
    #Evaluator
    self._eval=Evaluator(self.printCommand)
</t>
<t tx="1.20130426141258.3742">def registerCommand(self, name, callback):
    '''
    Register a command with it's callback in the command table.
    Commands are executed by a call to the evaluate function.
    '''
    # a command is at least one character
    if len(name) &gt; 0:
        # the callback is not None
        if not callback is None:
            # commands are always defined in upper case
            self._command_table[name.upper()] = callback
</t>
<t tx="1.20130426141258.3743">def evaluate(self, expression):
    '''
        Looks up the expression from the command table.
        If a command is found, it's callback function is called.
        If it is not a command the expression is evaluated.
        Return: command exit, the evaluated expression or "*error*"
    '''
    # commands are always defined in upper case
    command = str(expression).upper()
    # is it a command from the command table?
    self.__edit_ctrl.clear()
    if command in self._command_table:    # Interface command evaluation
        # call function
        # echo on the comand line
        self.printCommand(command)
        self._value = self._command_table[command]()
    else:
        try:
            # let python evaluate expression
            self.printCommand(expression)
            self._value=self._eval.evaluate(expression)
        except:
            self._value ="*error*"
        finally:
            self.__edit_ctrl.clear()
    # show result
    if self._value :
        self.printOutput(self._value)
    return self._value
</t>
<t tx="1.20130426141258.3744">def resetCommand(self, reflect=True):
    """
        reset the command if eny are set
    """
    if reflect:
        self.printOutput("Command Ended from the user")
</t>
<t tx="1.20130426141258.3745">def printCommand(self, msg):
    """
        print message
    """
    msg=str(msg)
    if len(msg)&gt;0:
        msg="&gt;&gt;&gt; "+msg
        self.__edit_output.printMsg(msg)
</t>
<t tx="1.20130426141258.3746">def printOutput(self, msg):
    """
        print a message in the output message windows
    """
    msg=str(msg)
    if len(msg)&gt;0:
        msg="&lt;PythonCAD&gt; : "+msg
        self.__edit_output.printMsg(msg)
</t>
<t tx="1.20130426141258.3747">@language python
@tabwidth -4
@others
#
# Copyright (c) 2010, PythonCad team
#
# Cui = custom user interface
# The custom user interface defines menu's, toolbars and palettes
# which are used to interact with the user.
</t>
<t tx="1.20130426141258.3748"></t>
<t tx="1.20130426141258.3749">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide a command to calculate the distance from 2 point
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3750">import math

from Kernel.exception                  import *
from Kernel.Command.basecommand        import *
</t>
<t tx="1.20130426141258.3751">class Distance2Point(BaseCommand):
    """
        This class rappresent the distance 2 point command
    """
    @others
</t>
<t tx="1.20130426141258.3752">def __init__(self, document, iDocument):
    BaseCommand.__init__(self, document)
    self.iDocuemnt=iDocument
    self.exception=[ExcPoint, ExcPoint]
    self.defaultValue=[None, None]
    self.message=["Give Me the first Point", 
                    "Give Me the second Point"]
</t>
<t tx="1.20130426141258.3753">def applyCommand(self):
    if len(self.value)&lt;1:
        raise PyCadWrongImputData("Wrong number of imput parameter")
    leng=self.value[0].dist(self.value[1])
    msg="Lenght: "+ str(leng)
    self.iDocuemnt.popUpInfo(msg)
</t>
<t tx="1.20130426141258.3754">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This Module provide a Interface Command managing the preview the and the snap
# system
#
# How it works:
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3755">import logging
#
#Kernel Import
#
from Kernel.GeoUtil.intersection    import *
from Kernel.pycadevent              import *
from Kernel.exception               import *
from Kernel.unitparser              import *
#
# Interface Import
#
from Interface.cadinitsetting       import RESTART_COMMAND_OPTION
from Interface.Dialogs.property     import Property
from Interface.Preview.factory      import *
from Interface.DrawingHelper.snap   import *
</t>
<t tx="1.20130426141258.3756">class ICommand(object):
    """
        this class provide base command operation
    """
    #self.scene.snappingPoint.activeSnap=SNAP_POINT_ARRAY["LIST"]  # Define the active snap system
    activeSnap = SNAP_POINT_ARRAY["LIST"]
    drawPreview=True                    # Enable the preview system
    automaticApply=True                 # Apply the command at the last insert value
    @others
</t>
<t tx="1.20130426141258.3757">#restartCommandOption=False         # moved to Interface.cadinitsetting  &gt; RESTART_COMMAND_OPTION

def __init__(self, scene):
    self._scene=scene              # This is needed for the preview creation
    self._previewItem=None
    self._point={}
    self._entity={}
    self._distance={}
    self._angle={}
    self._snap={}
    self._forceSnap={}
    self._index=-1
    self.updateInput=PyCadEvent()
    #self.scene.snappingPoint.activeSnap=#SNAP_POINT_ARRAY["LIST"]  # Define the active snap system
</t>
<t tx="1.20130426141258.3758">@property
def forceDirection(self):
    """
        get scene force direction
    """
    return self.scene.forceDirection
</t>
<t tx="1.20130426141258.3759">@property
def kernelCommand(self):
    """
        get scene the kernel command
    """
    return self.scene.activeKernelCommand
</t>
<t tx="1.20130426141258.3760">@property
def scene(self):
    """
        get scene
    """
    return self._scene
</t>
<t tx="1.20130426141258.3761">@property
def index(self):
    return self._index
</t>
<t tx="1.20130426141258.3762">def restartCommand(self):
    """
        reuse the command
    """
    if self.kernelCommand!=None:
        self.kernelCommand.reset()
    self._point={}
    self._entity={}
    self._distance={}
    self._angle={}
    self._snap={}
    self._forceSnap={}
    self._index=-1
    self.removePreviewItemToTheScene()
</t>
<t tx="1.20130426141258.3763">def addMauseEvent(self, point, entity,distance=None,angle=None , text=None, force=None, correct=True):
    """
        add value to a new slot of the command
    """
    #
    # Compute snap distance and position force
    #
    logging.debug("log: addMauseEvent [%s][%s][%s][%s][%s][%s]"%( str(point), str(entity), str(distance), str(angle), str(text), str(force)))
    if correct!=None:
        snap=self.scene.snappingPoint.getSnapPoint(point,self.getEntity(point))
        snap=self.correctPositionForcedDirection(snap, self._scene.forceDirection)
        
    else:
        snap=point
        
    if angle==None:
        angle=self.calculateAngle(snap)
        
    if distance==None:
        distance=self.getDistance(snap)
    #
    # Assing value to the object arrays
    #
    try:
        self.kernelCommand[self._index]=(snap,entity,distance, angle, text) #Here you got all the magic
        self.scene.fromPoint=snap
        if self.kernelCommand.activeException()==ExcPoint or self.kernelCommand.activeException()==ExcLenght:
            if snap!=None:
                self.scene.GuideHandler.place(snap.getx(), snap.gety())
            if self.scene.forceDirectionEnabled==True:
                self.scene.GuideHandler.show()
    except Exception as ex:
        self.updateInput("msg")
        self.updateInput(self.kernelCommand.activeMessage)
        self.scene.clearSelection()
        print("Error ",str(ex))
        return
    self._index+=1
    self._point[self._index]=(point)
    self._entity[self._index]=(entity)
    self._distance[self._index]=(distance)
    self._angle[self._index]=(angle)
    self._snap[self._index]=(snap)
    self._forceSnap[self._index]=(force)
    #self.updatePreview(point,distance,entity )
    try:
        next(self.kernelCommand)
    except StopIteration:
        self.applyCommand()
        return

    self.updateInput(self.kernelCommand.activeMessage)
    if self.automaticApply and self.kernelCommand.automaticApply:
        if(self._index&gt;=self.kernelCommand.lenght-1): #Apply the command
            self.applyCommand()

    if self.kernelCommand.activeException()==ExcDicTuple:
        dialog=Property(parent =self.scene.parent(),  entity=entity)
        if dialog.changed:
            self.kernelCommand[self._index]=(None,entity,None, None, dialog.value)
            self.applyCommand()
        else:
            self.restartCommand()
</t>
<t tx="1.20130426141258.3764">def addTextEvent(self, value):
    """
        compute imput from text
    """
    if str(value)=="":
        self.kernelCommand.applyDefault()
        self.applyCommand()
        return
    elif str(value).upper()=="UNDO":
        #TODO: perform a back operation to the command
        return
    elif str(value).upper()=="REDO":
        #TODO: perform a forward operation to the command
        return
    else:
        try:
            tValue=self.decodeText(str(value))
            self.addMauseEvent(tValue[0], tValue[1], tValue[2], tValue[3], tValue[4], correct=None)
        except PyCadWrongImputData as msg:
            print("Problem on ICommand.addTextEvent")
            self.updateInput(msg)
            self.updateInput(self.kernelCommand.activeMessage)
            return
</t>
<t tx="1.20130426141258.3765">def applyDefault(self):
    """
        apply the default value command
    """
    try:
        self.kernelCommand.performDefaultValue()
        next(self.kernelCommand)
        self.updateInput(self.kernelCommand.activeMessage)
    except NoDefaultValue:
        return
    except StopIteration:
            self.applyCommand()
            return
</t>
<t tx="1.20130426141258.3766">def applyCommand(self):
    """
        apply the command
    """
    #self.scene.hideSnapMarks()
    try:
        self.kernelCommand.applyCommand()
        if RESTART_COMMAND_OPTION and self.kernelCommand.autorestart:
                self.restartCommand()
                self.updateInput(self.kernelCommand.activeMessage)
                self.scene.clearSelection()
                self.scene.fromPoint=None
                self.scene.isGuided=None
                self.scene.isGuideLocked=None
                self.scene.GuideHandler.reset()
        else:
            self.scene.cancelCommand()
            self.updateInput("Ready")
            self.scene.clearPreview()
            self.removePreviewItemToTheScene()
            self=None
            return
        self.scene.clearPreview()
        self.removePreviewItemToTheScene()
    except Exception as e:
        print(type(e))     # the exception instance
        print("ICommand applyCommand Errore ", str(e))
        self.restartCommand()
</t>
<t tx="1.20130426141258.3767">def getEntity(self, position):
    """
        get the entity nearest at the mouse position
    """
    if position ==None:
        return None
    p=QtCore.QPointF(position.x, position.y*-1.0)
    ents=self._scene.items(p)
    if len(ents)&gt;1: # bug: it was 0
        #TODO: here it will be nice to have a sort of control for chosing one entity
        #in case of overlapping entity selection
        pass
    for e in ents:
        if isinstance(e, BaseEntity):
            return e
    return None
</t>
<t tx="1.20130426141258.3768">def updateMauseEvent(self, point, entity, distance=None, force=None):
    """
        update value to the active slot of the command
    """
    if self.index&gt;-1:
        updIndex=self.index+1
        self._point[updIndex]=point
        self._entity[updIndex]=entity
        
        if distance==None:
            distance=self.getDistance(point) 
        
        self._distance[updIndex]=distance
        self._snap[updIndex]=point
        self._forceSnap[updIndex]=force
    self.updatePreview(point, distance, entity) #   mange preview
</t>
<t tx="1.20130426141258.3769">def getDistance(self, point):
    """
        Get The distance from 2 points
    """
    prPoint=self.getActiveSnapClick()
    if prPoint!=None and point!=None:
        d=prPoint.dist(point)
        return d
    else:
        return None
</t>
<t tx="1.20130426141258.3770">def calculateAngle(self, snap):
    """
        calculate the angle betwin the point clicked
    """
    if snap==None:
        return None
    try:
        for snapPoint in self._snap:
            print("angle ",self._snap[snapPoint],snap) 
            v=Vector(self._snap[snapPoint],snap )
            return v.absAng
        else:
            return None
    except EntityMissing:
        return None
</t>
<t tx="1.20130426141258.3771">def decodeText(self, value):
    """
        encode the text given from the user
    """
    point=None
    distance=None
    entitys=None
    text=None
    angle=None
    value=str(value)
    
    def niceReturn():
        return (point,entitys, distance,angle, text)
    try:
        try:
            raise self.kernelCommand.activeException()(None)
        except ExcPoint:
            if value.find(',')&gt;-1:              # ABSOLUTE CARTESIAN INPUT
                x, y=value.split(',')
                point=Point(convertLengh(x), convertLengh(y))
                return niceReturn()
            elif value.find(';')&gt;-1:            # RELATIVE CARTESIAN INPUT
                x, y=value.split(';')
                x=self.scene.fromPoint.getx()+convertLengh(x)
                y=self.scene.fromPoint.gety()+convertLengh(y)
                point=Point(x, y)
                return niceReturn()
            elif value.find('&gt;')&gt;-1:
                ang, distance=value.split('&gt;')
                ang=convertAngle(ang)
                distance=convertLengh(distance)
                x=math.cos(float(ang))*float(distance)
                y=math.sin(float(ang))*float(distance)
                x=self.scene.fromPoint.getx()+float(x)
                y=self.scene.fromPoint.gety()+float(y)
                point=Point(x, y)
                return niceReturn()
            else: # DISTANCE+ANGLE FROM SCENE set coordinate based on distance input and angle from mouse position on the scene
                d=float(value)
                pX=self.scene.mouseOnSceneX
                pY=self.scene.mouseOnSceneY
                if self.scene.forceDirection is not None:
                    pc=Point(pX, pY)
                    pc=self.correctPositionForcedDirection(pc, self.scene.forceDirection)
                    pX, pY=pc.getCoords()
                #if frompoint is not none else exception
                dx=pX-self.scene.fromPoint.getx()
                dy=pY-self.scene.fromPoint.gety()
                a=math.atan2(dy, dx)
                x=self.scene.fromPoint.getx()+d*math.cos(a)
                y=self.scene.fromPoint.gety()+d*math.sin(a)
                point=Point(x, y)
                return niceReturn()
        except (ExcEntity,ExcMultiEntity):
            entitys=self.getIdsString(value)
            return niceReturn()
        except ExcEntityPoint:
            #(4@10,20)
            id, p=value.split('@')
            x, y=p.split(',')
            point=Point(float(x), float(y))
            entitys=self.getIdsString(id)
            return niceReturn()
        except (ExcLenght, ExcInt, ExcBool):
            distance=value
            return niceReturn()
        except(ExcAngle):
            angle=value
            return niceReturn()
        except(ExcText):
            text=value
            return niceReturn()
    except:
        raise PyCadWrongImputData("BaseCommand : Wrong imput parameter for the command")
    return niceReturn()
</t>
<t tx="1.20130426141258.3772">def getIdsString(self, value):
    """
        return the entity from a string value (id)
    """
    return self.scene.getEntFromId(value)
</t>
<t tx="1.20130426141258.3773">def updatePreview(self, point, distance, entity):
    """
        make update of the preview
    """
    if self.drawPreview:
        if self._previewItem==None:            #Create the Preview Item
            self._previewItem=getPreviewObject(self.kernelCommand)
            self.addPreviewItemToTheScene()
        else:                                   #Use the item already stored
            self._previewItem.updatePreview(point,
                                            distance,
                                                self.kernelCommand)
</t>
<t tx="1.20130426141258.3774">def addPreviewItemToTheScene(self):
    """
        add the preview item at the scene
    """
    if self._previewItem!=None:
        self._scene.addItem(self._previewItem)
</t>
<t tx="1.20130426141258.3775">def removePreviewItemToTheScene(self):
    """
        Remove all the preview items from the scene
    """
    if self._previewItem!=None:
        self._scene.clearPreview()
        self._previewItem=None
</t>
<t tx="1.20130426141258.3776">def getPointClick(self, index):
    """
        return the index clicked entity
    """
    return self.getDummyElement(self._point, index)
</t>
<t tx="1.20130426141258.3777">def getEntityClick(self, index):
    """
        return the index clicked entity
    """
    return self.getDummyElement(self._entity, index)
</t>
<t tx="1.20130426141258.3778">def getDistanceClick(self, index):
    """
        return the index clicked entity
    """
    return self.getDummyElement(self._distance, index)
</t>
<t tx="1.20130426141258.3779">def getSnapClick(self, index):
    """
        return the index clicked entity
    """
    return self.getDummyElement(self._snap, index)
</t>
<t tx="1.20130426141258.3780">def getForceSnap(self, index):
    """
        return the index clicked entity
    """
    return self.getDummyElement(self._forceSnap, index)
</t>
<t tx="1.20130426141258.3781">def getDummyElement(self, array, index):
    """
        generic function to get an item from a generic array
    """
    if len(array)&gt;=0 and index&lt;=self.index:
        return array[index]
    raise IndexError
</t>
<t tx="1.20130426141258.3782">def getDummyActive(self, func):
    """
        parametric function to return an element of an array
    """
    if self.index&gt;=0:
        return func(self.index)
    return None
</t>
<t tx="1.20130426141258.3783">def getActiveSnapClick(self):
    """
        get the clicked snap point
    """
    return self.getDummyActive(self.getSnapClick)
</t>
<t tx="1.20130426141258.3784">def getActiveDistanceClick(self):
    """
        get the clicked distance
    """
    return self.getDummyActive(self.getDistanceClick)
</t>
<t tx="1.20130426141258.3785">def getDummyBefore(self, func):
    """
        parametric function to return a previews element of an array
    """
    if self.index&gt;0:
        return func(self.index-1)
    return None
</t>
<t tx="1.20130426141258.3786">def getBeforeEntity(self):
    """
        get the before clicked entity
    """
    return self.getDummyBefore(self.getEntityClick)
</t>
<t tx="1.20130426141258.3787">def getBeforeSnapClick(self):
    """
        get the before clicked snap point
    """
    return self.getDummyBefore(self.getSnapClick)
</t>
<t tx="1.20130426141258.3788">def getLastForceSnap(self):
    """
        get the before forced snap type
    """
    return self.getDummyBefore(self.getForceSnap)
</t>
<t tx="1.20130426141258.3789">def correctPositionForcedDirection(self, point, force):
    """
        correct the POINT coords
        FORCE is the angle the defines the correction direction

        return the projection point of the POINT to the straight line defined by FORCE angle

        FORCE angle, in current inplementation, is setted by polarguides module when the mouse cursor is over a guide item
    """
    if point ==None:
        return None
    if force==None:
        return point
    lastSnap=self._scene.fromPoint
    pF=point
    if force!=None and lastSnap!=None:
        v=Vector(lastSnap, Point(lastSnap.x+10.0*math.cos(force),  lastSnap.y+10.0*math.sin(force)))
        v1=Vector(lastSnap,point)
        pF=v.map(v1.point).point
        pF=pF+lastSnap

\\-4.#            if abs(x-lastSnap.x)&gt;abs(y-lastSnap.y):
\\-4.#                y=lastSnap.y
\\-4.#            else:
\\-4.#                x=lastSnap.x

    return pF #Point(x, y)
</t>
<t tx="1.20130426141258.3790">def getIntersection(self, entity, point):
    """
        this function compute the  snap intersection point
    """
    returnVal=None
    distance=None
    if entity!=None:
        geoEntityFrom=entity.geoItem
        entityList=self._scene.collidingItems(entity)
        for ent in entityList:
            intPoint=find_intersections(ent.geoItem,geoEntityFrom)
            for tp in intPoint:
                iPoint=Point(tp[0], tp[1])
                if distance==None:
                    distance=iPoint.dist(point)
                    returnVal=iPoint
                else:
                    spoolDist=iPoint.dist(point)
                    if distance&gt;spoolDist:
                        distance=spoolDist
                        returnVal=iPoint
    return returnVal
</t>
<t tx="1.20130426141258.3791"></t>
<t tx="1.20130426141258.3792"></t>
<t tx="1.20130426141258.3793">##############################################################################
#
#    OmniaSolutions, Your own solutions
#    Copyright (C) 23/apr/2012 OmniaSolutions (&lt;http://www.omniasolutions.eu&gt;). All Rights Reserved
#    info@omniasolutions.eu
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
##############################################################################
'''    
Created on 23/apr/2012
@author: mboscolo
'''

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3794">from  PyQt5.QtCore    import *
from PyQt5.QtWidgets import *
from  PyQt5.QtGui     import *
</t>
<t tx="1.20130426141258.3795">class DataModel(QAbstractTableModel): 
    """
        abstract model for manage values
    """
    layoutChanged = pyqtSignal()
    dataChanged = pyqtSignal()

    @others
</t>
<t tx="1.20130426141258.3796">def __init__(self, datain, headerdata, parent=None, *args): 
    QAbstractTableModel.__init__(self, parent, *args) 
    self.arraydata = datain
    self.headerdata = headerdata 
    flags=[]      
    flags.append(Qt.ItemIsEditable)
    flags.append(Qt.ItemIsSelectable)
    flags.append(Qt.ItemIsEnabled)
    self._flags=flags
</t>
<t tx="1.20130426141258.3797">def rowCount(self,objParent): 
    """
        row count
    """
    return len(self.arraydata) 
</t>
<t tx="1.20130426141258.3798">def addNewRow(self):
    """
        add a new empty row to the abstract model
    """
    newRow=[]
    newRow.append(False)
    for i in range(1,len(self.headerdata)):
        newRow.append('')
    self.insertRow(self.rowCount(None)+1,[newRow]) 
</t>
<t tx="1.20130426141258.3799">def insertRow(self, pos, row):
    """
        insert row
    """
    self.insertRows(pos, 1, row)
    self.layoutChanged.emit()
</t>
<t tx="1.20130426141258.3800">def insertRows(self, pos, count, rows):
    """
        insert rows
    """
    self.beginInsertRows(QModelIndex(), pos, pos + count - 1)
    for row in rows:
        self.arraydata.append(row)
    self.endInsertRows()
    self.layoutChanged.emit()
    return True
</t>
<t tx="1.20130426141258.3801">def removeRow(self, pos):
    """
        remove row
    """
    self.removeRows(pos, 1)
    return True
</t>
<t tx="1.20130426141258.3802">def removeRows(self, row=-1, count=0, parent=QModelIndex()):
    """
        remove rows
    """
    if row == -1:
        self.beginRemoveRows(QModelIndex(), 0, len(self.arraydata) - 1)
        del self.arraydata[:]
    else:
        self.beginRemoveRows(QModelIndex(), row, row + count - 1)
        del self.arraydata[row:row + count]
    self.endRemoveRows()
    self.layoutChanged.emit()
    return True
</t>
<t tx="1.20130426141258.3803">def columnCount(self, parent): 
    """
        return the column count
    """
    if len(self.arraydata)&gt;0:
        return len(self.arraydata[0])
    return 0 
</t>
<t tx="1.20130426141258.3804">def _rule(self,index):
    """
        this class must be overloaded in order to control the background color
    """
    return False
</t>
<t tx="1.20130426141258.3805">def backgroudIndex(self,index):
    if self._rule(index):
        self.setData(index, Qt.QColor(Qt.red), Qt.BackgroundColorRole)
</t>
<t tx="1.20130426141258.3806">def data(self, index, role): 
    if not index.isValid(): 
        return QVariant() 
    elif role != Qt.DisplayRole: 
        return QVariant() 
    return QVariant(self.arraydata[index.row()][index.column()])
</t>
<t tx="1.20130426141258.3807">def headerData(self, col, orientation, role):
    if orientation == Qt.Horizontal and role == Qt.DisplayRole:
        return QVariant(self.headerdata[col])
    return QVariant()
</t>
<t tx="1.20130426141258.3808">def flags(self, index):
    """
        set the flag for the data model
    """
    flags = super(self.__class__,self).flags(index)
    for flag in self._flags:
        flags |= flag
        
    #flags |= QtCore.Qt.ItemIsDragEnabled
    #flags |= QtCore.Qt.ItemIsDropEnabled
    return flags
</t>
<t tx="1.20130426141258.3809">def enableRowEdit(self,index):
    """
        
    """
    pass
</t>
<t tx="1.20130426141258.3810">def setData(self, index, value, role=Qt.EditRole):
    row = index.row()
    col = index.column()
    self.arraydata[row][col] = str(value.toString())
    self.dataChanged.emit()
    return True
</t>
<t tx="1.20130426141258.3811">def getRowData(self,index):
    return self.arraydata[index.row()]
</t>
<t tx="1.20130426141258.3812">def populateTable(refTable,tableObject,header,backGroundFunction=False):
    """
        Create the table elements
    """
    modelTable=DataModel(tableObject,header)
    modelTable._flags=[Qt.ItemIsSelectable,Qt.ItemIsEnabled,Qt.ItemIsEditable]
    if backGroundFunction!=False:
        modelTable._rule=backGroundFunction
    refTable.setModel(modelTable)
    #
    # Set Table Behavior
    #
    refTable.resizeColumnsToContents()
    vh = refTable.verticalHeader()
    vh.setVisible(False)
    refTable.setAlternatingRowColors(True)
    # set horizontal header properties
    hh = refTable.horizontalHeader()
    hh.setStretchLastSection(True)
    # set column width to fit contents
    refTable.resizeColumnsToContents()
    # set row height
    nrows = len(tableObject)
    for row in range(nrows):
        refTable.setRowHeight(row, 18)
    #
    # Set Selection
    #        
    refTable.setEditTriggers(QAbstractItemView.DoubleClicked)
    refTable.setSelectionBehavior(QAbstractItemView.SelectRows)
    refTable.setSelectionMode(QAbstractItemView.ExtendedSelection) 
</t>
<t tx="1.20130426141258.3813">##############################################################################
#
#    OmniaSolutions, Your own solutions
#    Copyright (C) 24/apr/2012 OmniaSolutions (&lt;http://www.omniasolutions.eu&gt;). All Rights Reserved
#    info@omniasolutions.eu
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
##############################################################################
'''
Created on 24/apr/2012

@author: mboscolo
'''

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3814">from PyQt5.QtWidgets import    QDialog, QAbstractItemView
#from PyQt5.QtCore   import pyqtSignature

from .Ui_preferences    import Ui_preferences

from Interface.cadinitsetting import *
</t>
<t tx="1.20130426141258.3815">class Preferences(QDialog, Ui_preferences):
    """
        this class define the entity property dialog
        it automaticaly retrive the style property 
        and show it in the form
    """
    @others
</t>
<t tx="1.20130426141258.3816">def __init__(self, parent = None, entity=None):
    QDialog.__init__(self, parent)
    self.setupUi(self)
</t>
<t tx="1.20130426141258.3817">#@pyqtSignature("")
def on_buttonBox_accepted(self):
    """
        implements the accept button
    """
    self.close()
</t>
<t tx="1.20130426141258.3818">#@pyqtSignature("")
def on_buttonBox_rejected(self):
    """
        implements the accept button
    """
    self.close()
</t>
<t tx="1.20130426141258.3819">#
# Copyright (c) 2010,2011 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This Module provide a Interface Command managing the preview the and the snap
# system
#
# How it works:
# 
#
#
# Qt Import
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3820">from PyQt5.QtWidgets import    QDialog, QAbstractItemView, QMenu, QAction
#from PyQt5.QtCore   import pyqtSignature

from .Ui_property    import Ui_Dialog

from Interface.cadinitsetting import *
from Interface.Dialogs.dataModel import populateTable
</t>
<t tx="1.20130426141258.3821">class Property(QDialog, Ui_Dialog):
    """
        this class define the entity property dialog
        it automaticaly retrive the style property 
        and show it in the form
    """
    @others
</t>
<t tx="1.20130426141258.3822">def __init__(self, parent = None, entity=None):
    QDialog.__init__(self, parent)
    self.setupUi(self)
    self.containers={}
    self._isOk=False
    self.entity=entity
    styleprops=entity[0].style.props
    self.customProperty.contextMenuEvent=self.customPropertyContextMenuEvent
    for propName in styleprops:
        val=styleprops[propName]
        if propName in PYTHONCAD_STYLE_WIDGET:
            propDescription=PYTHONCAD_STYLE_DESCRIPTION[propName]
            self.containers[propName]=PYTHONCAD_STYLE_WIDGET[propName](None, oldValue=val,label=propDescription)
            self.propertyConteiner.addLayout(self.containers[propName])
    self.populateCustomProperty(entity)
    self.exec_()
</t>
<t tx="1.20130426141258.3823">def populateCustomProperty(self,entity):
    """
        populate the dialog with the custom property
    """
    tableObject=[[k,v] for k,v in list(entity[0]._entity.properties.items())]
    populateTable(self.customProperty,tableObject,['Name','Value'])
</t>
<t tx="1.20130426141258.3824">def customPropertyContextMenuEvent(self,event):
    contexMenu=QMenu(self)
    #
    # Create Actions
    #
    newAction   =   QAction("New", self, triggered=self._newCustomProperty)
    delAction   =   QAction("Delete", self, triggered=self._delCustomProperty)  
    #
    # Add action to the context menu   
    #
    contexMenu.addAction(newAction)
    contexMenu.addAction(delAction)
    #
    contexMenu.exec_(event.globalPos())
    del(contexMenu)       
</t>
<t tx="1.20130426141258.3825">def _newCustomProperty(self):
    """
        Open an empty ParameterUi
    """
    self.customProperty.model().addNewRow()
</t>
<t tx="1.20130426141258.3826">def _delCustomProperty(self):
    """
        Edit the selected parameter values
    """
    rows=self.customProperty.selectionModel().selectedRows()
    if len(rows)&gt;0:
        row=rows[0]
        self.customProperty.model().removeRow(row.row())
</t>
<t tx="1.20130426141258.3827">def uppdateCustomProperty(self):
    """
        update the custom property
    """ 
    self._properties = dict(self.customProperty.model().arraydata)
</t>
<t tx="1.20130426141258.3828">#@pyqtSignature("")
def on_buttonBox_accepted(self):
    """
        implements the accept button
    """
    self.uppdateCustomProperty()
    self._isOk=True
    self.close()
</t>
<t tx="1.20130426141258.3829">#@pyqtSignature("")
def on_buttonBox_rejected(self):
    """
        implements the accept button
    """
    self._isOk=False
    self.close()
</t>
<t tx="1.20130426141258.3830">@property 
def changed(self):
    """
        tells if the object is changed
    """
    return self._isOk
</t>
<t tx="1.20130426141258.3831">@property
def value(self):
    exitVal={}
    if self.changed:
        for name in self.containers:
            obj=self.containers[name]
            if obj.changed:
                exitVal[name]=obj.value
    #Update custom propertis
    if len(self._properties)&gt;0:
        exitVal['property']=self._properties
    return exitVal
</t>
<t tx="1.20130426141258.3832"># -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'D:\OmniaSolutions\Programming\EclipseWorkSpace\PythonCad\PythonCAD\Interface\Dialogs\preferencies.ui'
#
# Created: Tue Apr 24 08:38:50 2012
#      by: PyQt4 UI code generator 4.9
#
# WARNING! All changes made in this file will be lost!



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    preference = QtWidgets.QDialog()
    ui = Ui_preference()
    ui.setupUi(preference)
    preference.show()
    sys.exit(app.exec_())
</t>
<t tx="1.20130426141258.3833">from PyQt5 import QtCore, QtGui, QtWidgets

</t>
<t tx="1.20130426141258.3834">class Ui_preferences(object):
    @others
</t>
<t tx="1.20130426141258.3835">def setupUi(self, preference):
    preference.setObjectName("preference")
    preference.setWindowModality(QtCore.Qt.ApplicationModal)
    preference.resize(305, 234)
    self.verticalLayout = QtWidgets.QVBoxLayout(preference)
    self.verticalLayout.setObjectName("verticalLayout")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.verticalLayout.addLayout(self.verticalLayout_2)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout.addItem(spacerItem)
    self.buttonBox = QtWidgets.QDialogButtonBox(preference)
    self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.buttonBox.setObjectName("buttonBox")
    self.verticalLayout.addWidget(self.buttonBox)

    self.retranslateUi(preference)
    QtCore.QMetaObject.connectSlotsByName(preference)
</t>
<t tx="1.20130426141258.3836">def retranslateUi(self, preference):
    preference.setWindowTitle(QtCore.QCoreApplication.translate("preference", "Preferences", None))
</t>
<t tx="1.20130426141258.3837"># -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'D:\OmniaSolutions\Programming\EclipseWorkSpace\PythonCad\PythonCAD\Interface\Dialogs\property.ui'
#
# Created: Mon Apr 23 17:27:00 2012
#      by: PyQt4 UI code generator 4.9
#
# WARNING! All changes made in this file will be lost!



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())
</t>
<t tx="1.20130426141258.3838">from PyQt5 import QtCore, QtGui, QtWidgets

</t>
<t tx="1.20130426141258.3839">class Ui_Dialog(object):
    @others
</t>
<t tx="1.20130426141258.3840">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(254, 279)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.tabWidget = QtWidgets.QTabWidget(Dialog)
    self.tabWidget.setObjectName("tabWidget")
    self.tab = QtWidgets.QWidget()
    self.tab.setObjectName("tab")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.tab)
    self.verticalLayout.setObjectName("verticalLayout")
    self.propertyConteiner = QtWidgets.QVBoxLayout()
    self.propertyConteiner.setObjectName("propertyConteiner")
    self.verticalLayout.addLayout(self.propertyConteiner)
    spacerItem = QtWidgets.QSpacerItem(20, 178, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout.addItem(spacerItem)
    self.tabWidget.addTab(self.tab, "")
    self.tab_2 = QtWidgets.QWidget()
    self.tab_2.setObjectName("tab_2")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.tab_2)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.customProperty = QtWidgets.QTableView(self.tab_2)
    self.customProperty.setObjectName("customProperty")
    self.verticalLayout_3.addWidget(self.customProperty)
    self.tabWidget.addTab(self.tab_2, "")
    self.verticalLayout_2.addWidget(self.tabWidget)
    self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
    self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.buttonBox.setObjectName("buttonBox")
    self.verticalLayout_2.addWidget(self.buttonBox)

    self.retranslateUi(Dialog)
    self.tabWidget.setCurrentIndex(0)
    QtCore.QMetaObject.connectSlotsByName(Dialog)
</t>
<t tx="1.20130426141258.3841">def retranslateUi(self, Dialog):
    Dialog.setWindowTitle(QtCore.QCoreApplication.translate("Dialog", "Dialog", None))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), QtCore.QCoreApplication.translate("Dialog", "Geometrical Attributes", None))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), QtCore.QCoreApplication.translate("Dialog", "Custom Property", None))
</t>
<t tx="1.20130426141258.3842"></t>
<t tx="1.20130426141258.3843"></t>
<t tx="1.20130426141258.3844">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3845">from PyQt5 import QtCore, QtGui, QtWidgets

IdRole = QtCore.Qt.UserRole
</t>
<t tx="1.20130426141258.3846">class BaseContainer(QtWidgets.QHBoxLayout):
    @others
</t>
<t tx="1.20130426141258.3847">def __init__(self, parent=None, label="baseInfo"):
    super(BaseContainer, self).__init__(parent)
    label=QtWidgets.QLabel(label)
    self.addWidget(label)
    self.activeValue=None
    self._changed=False
</t>
<t tx="1.20130426141258.3848">@property
def value(self):
    """
        return the value of the object
    """
    return self.activeValue
</t>
<t tx="1.20130426141258.3849">@property
def changed(self):
    """
        tells if the value is changed
    """
    return self._changed
</t>
<t tx="1.20130426141258.3850">@changed.setter  
def changed(self, value):
    """
        tells if the value is changed
    """
    self._changed=value
</t>
<t tx="1.20130426141258.3851">class PyCadQColor(BaseContainer):
    @others
</t>
<t tx="1.20130426141258.3852">def __init__(self, parent=None, oldValue='green', label="Color"):
    super(PyCadQColor, self).__init__(parent=parent, label=label)
    r, g, b=oldValue
    self.activeValue=oldValue
    self.pushButton=QtWidgets.QPushButton()
    self.pushButton.clicked.connect(self.click)
    frameStyle = QtWidgets.QFrame.Sunken | QtWidgets.QFrame.Panel
    self.colorLabel = QtWidgets.QLabel()
    self.colorLabel.setFrameStyle(frameStyle)
    sColor=QtGui.QColor.fromRgb(r, g, b)
    self.colorLabel.setText(sColor.name())
    self.colorLabel.setPalette(QtGui.QPalette(sColor))
    self.colorLabel.setAutoFillBackground(True)
    self.addWidget(self.colorLabel)
    self.addWidget(self.pushButton)
</t>
<t tx="1.20130426141258.3853">def click(self):
    r, g, b=self.activeValue
    sColor=QtGui.QColor.fromRgb(r, g, b)
    color = QtWidgets.QColorDialog.getColor(sColor, parent=None)
    if color.isValid(): 
        self.colorLabel.setText(color.name())
        self.colorLabel.setPalette(QtGui.QPalette(color))
        self.colorLabel.setAutoFillBackground(True)
        self.activeValue=(color.red(), 
                          color.green(), 
                          color.blue()
                          )
        self.changed=True
</t>
<t tx="1.20130426141258.3854">class PyCadQLineType(BaseContainer):
    @others
</t>
<t tx="1.20130426141258.3855">def __init__(self, parent=None, oldValue=QtCore.Qt.SolidLine, label="&amp;Pen Style"):
    super(PyCadQLineType, self).__init__(parent=parent, label=label)
    self.activeValue=oldValue
    #define Active combo box
    self.penStyleComboBox = QtWidgets.QComboBox()
    self.penStyleComboBox.addItem("Solid", QtCore.Qt.SolidLine)
    self.penStyleComboBox.addItem("Dash", QtCore.Qt.DashLine)
    self.penStyleComboBox.addItem("Dot", QtCore.Qt.DotLine)
    self.penStyleComboBox.addItem("Dash Dot", QtCore.Qt.DashDotLine)
    self.penStyleComboBox.addItem("Dash Dot Dot", QtCore.Qt.DashDotDotLine)
    itemindex=self.penStyleComboBox.findData(oldValue)
    self.penStyleComboBox.setCurrentIndex(itemindex)
    #define label
    penStyleLabel = QtWidgets.QLabel("")
    penStyleLabel.setBuddy(self.penStyleComboBox)
    
    self.addWidget(penStyleLabel)
    self.addWidget(self.penStyleComboBox)
            
    self.penStyleComboBox.activated.connect(self.penChanged)
</t>
<t tx="1.20130426141258.3856">def penChanged(self):
    """
        change event 
    """
    value=self.penStyleComboBox.currentIndex()
    self.activeValue = QtCore.Qt.PenStyle(self.penStyleComboBox.itemData(value, IdRole).toInt()[0])
    self.changed=True
</t>
<t tx="1.20130426141258.3857">class PyCadQDouble(BaseContainer):
    @others
</t>
<t tx="1.20130426141258.3858">def __init__(self, parent=None, oldValue='0.0', label="Double"):
    super(PyCadQDouble, self).__init__(parent, label)
    self.activeValue=oldValue
    self.penWidthSpinBox = QtWidgets.QSpinBox()
    self.penWidthSpinBox.setRange(0, 20)
    self.penWidthSpinBox.setValue(int(oldValue))
    self.penWidthSpinBox.setSpecialValueText("0 (cosmetic pen)")
    self.penWidthSpinBox.valueChanged.connect(self.penChanged)
    
    self.addWidget(self.penWidthSpinBox)
</t>
<t tx="1.20130426141258.3859">def penChanged(self):
    """
        change event 
    """
    self.activeValue=self.penWidthSpinBox.value()
    self.changed=True
</t>
<t tx="1.20130426141258.3860">class PyCadQFont(BaseContainer ):
    @others
</t>
<t tx="1.20130426141258.3861">def __init__(self, parent=None, oldValue='green', label="Font"):
    super(PyCadQFont, self).__init__(parent, label)
</t>
<t tx="1.20130426141258.3862"></t>
<t tx="1.20130426141258.3863"></t>
<t tx="1.20130426141258.3864">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# evaluator Class to manage  command computation
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3865">from math import *
from Interface.pycadapp import PyCadApp
from sympy.physics import units as u

RESERVED_WORK=['self._print', 'self._error', 'self._ok','self._cadApplication','self.evaluate', 'self._eval', 'self._exec'  ]
</t>
<t tx="1.20130426141258.3866">class Evaluator(object):
    @others
</t>
<t tx="1.20130426141258.3867">def __init__(self, printFunction):
    self._print=printFunction
    self._error='*error*'
    self._ok='*Ok*'
    self._cadApplication=PyCadApp
</t>
<t tx="1.20130426141258.3868">def evaluate(self, value):
    """
        evaluate the string
    """
    if len(value)&lt;=0:
        return None
    if value in RESERVED_WORK:
        if value.count(value):
            return self._error + "-&gt;Reserved word"
    if value[0]=='&gt;': # eval
        return self._eval(value[1:])
    if value[0]=='@':
        return self._exec(value[1:])
    else:
        return value
</t>
<t tx="1.20130426141258.3869">def _eval(self, value):
    """
        evaluate the evaluated value
    """
    try:
        return eval(value)
    except:
        return self._error
</t>
<t tx="1.20130426141258.3870">def _exec(self, value):
    """
        exec value
    """
    try:
        value=str(value).replace('print', 'self._print')
        value=str(value).replace('pyCad', 'self._cadApplication')
        exec(value)
        return self._ok
    except:
        return self._error
</t>
<t tx="1.20130426141258.3871">#
# Copyright (c) 2010 Matteo Boscolo, Carlo Pavan
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This Module provide a polar guides management for the drawing scene and icommand
# 
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3872">import math

from PyQt5 import QtCore, QtGui, QtWidgets
</t>
<t tx="1.20130426141258.3873">def getPolarMenu():
    '''
    returns a menu to operate with guide objects STILL TO BE IMPLEMENTED
    '''
    menu=QtWidgets.QMenu()
    
    return menu
</t>
<t tx="1.20130426141258.3874">class GuideHandler(QtWidgets.QGraphicsItem):
    '''
    This class provide management of a guide Handler to be instanced by the scene
    on startup, and to be placed by iCommand when a point is succesfully added to a command
    '''
    @others
</t>
<t tx="1.20130426141258.3875">def __init__(self, parent, x, y, a):
    super(GuideHandler, self).__init__()
    self.scene=parent
    
    self.x=x
    self.y=y
    self.a=a
    
    self.guides=[]
    
    self.addGuidesByIncrement(math.pi/6)
</t>
<t tx="1.20130426141258.3876">def collidesWithItem(self,other,mode):
    return False
</t>
<t tx="1.20130426141258.3877">def setForceDirection(self, a):
    '''
    set scene.forceDirection to a angle
    '''
    self.scene.forceDirection=a
</t>
<t tx="1.20130426141258.3878">def setIsGuided(self, bool):
    '''
    set scene.isGuided to bool value
    '''
    self.scene.isGuided=bool
</t>
<t tx="1.20130426141258.3879">def setIsGuidLocked(self, bool):
    '''
    set scene.isGuideLocked to bool value
    '''
    self.scene.isGuideLocked=bool
</t>
<t tx="1.20130426141258.3880">def addGuideByAngle(self, a):
    '''
    add guide by a angle
    '''
    Guide(self, a)
    self.guides.append(a)
</t>
<t tx="1.20130426141258.3881">def addGuidesByIncrement(self, a=math.pi/2):
    '''
    add guides by a increment angle
    '''
    self.clearGuides()
    Guide(self, 0.0)
    i=0.0
    while i&lt;math.pi*2:
        g=Guide(self, i)
        self.guides.append(g)
        i=i+a
    return
</t>
<t tx="1.20130426141258.3882">def clearGuides(self):
    '''
    delete all guides   STILL DOESN'T WORK HELPPPPPPPPPPPPPPPPPPPPP
    '''
    for i in self.childItems():
        i.kill()
</t>
<t tx="1.20130426141258.3883">def place(self, x, y):
    '''
    set position of the handler (called by icommand)
    '''
    self.setPos(x, y*-1)
</t>
<t tx="1.20130426141258.3884">def reset(self):
    '''
    reset position of the handler and hides it
    '''
    try:
        self.scene.forceDirection=None
        self.setPos(0.0, 0.0)
        self.hide()
    except:
        return
</t>
<t tx="1.20130426141258.3885">def hideGuides(self):
    '''
    hides every guide children
    '''
    for i in self.childItems():
        i.hide()
</t>
<t tx="1.20130426141258.3886">def boundingRect(self):
    return self.childrenBoundingRect()
</t>
<t tx="1.20130426141258.3887">def paint(self, painte, option, widget):
    return
</t>
<t tx="1.20130426141258.3888">class Guide(QtWidgets.QGraphicsLineItem):
    '''
    This class provide a guide object and it's management
    it's added to the GuideHandler object
    '''
    @others
</t>
<t tx="1.20130426141258.3889">def __init__(self, parent=None, a=0.0):
    super(Guide, self).__init__(parent)
    self.handler=parent
    #Flags
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
    self.setFlag(QtWidgets.QGraphicsItem.ItemIgnoresTransformations, True)
    self.setAcceptHoverEvents(True)
    #Events
    
    self.a=parent.a+a
    line=QtCore.QLineF(0.0, 0.0, 20000*math.cos(a), (20000*math.sin(a))*-1)
    self.setLine(line)
    self.setToolTip("Guide [Press Shift to lock direction] "+ str(self.a)+"rad")
    
    self.highlightPen=QtGui.QPen(QtGui.QColor(150, 150, 150, 255), 1, QtCore.Qt.DotLine)
    self.hidePen=QtGui.QPen(QtGui.QColor(255, 50, 50, 0),1, QtCore.Qt.DotLine)
    
    self.setPen(self.hidePen)
    self.hide()
</t>
<t tx="1.20130426141258.3890">def collidesWithItem(self,other,mode):
    return False
</t>
<t tx="1.20130426141258.3891">def hide(self):
    self.setPen(self.hidePen)
    self.handler.setForceDirection(None)
    self.handler.setIsGuided(None)
</t>
<t tx="1.20130426141258.3892">def kill(self):
    
    del self
</t>
<t tx="1.20130426141258.3893">def shape(self):
    x=self.pos().x()
    y=self.pos().y()
    P1=QtCore.QPointF(x+10*math.cos(self.a-0.4), y-10*math.sin(self.a-0.4))
    P2=QtCore.QPointF(x+20000*math.cos(self.a-0.03), y-20000*math.sin(self.a-0.03))
    P3=QtCore.QPointF(x+20000*math.cos(self.a+0.03), y-20000*math.sin(self.a+0.03))
    P4=QtCore.QPointF(x+10*math.cos(self.a+0.4), y-10*math.sin(self.a+0.4))
    poly=QtGui.QPolygonF([P1, P2, P3, P4])
    #self.handler.scene.addPolygon(poly) #this is for checking the design of snapping guides
    shp=QtGui.QPainterPath()
    shp.addPolygon(poly)
    return shp
    
    return shp
</t>
<t tx="1.20130426141258.3894">def hoverEnterEvent(self, event):
    if self.handler.scene.isGuideLocked==None:
        self.handler.hideGuides()
        self.setPen(self.highlightPen)
        self.handler.setForceDirection(self.a)
        self.handler.setIsGuided(True)
    super(Guide, self).hoverEnterEvent(event)
    return
</t>
<t tx="1.20130426141258.3895">def hoverLeaveEvent(self, event):
    if self.handler.scene.isGuideLocked==None:
        self.hide()
        #self.update(self.boundingRect())
    super(Guide, self).hoverLeaveEvent(event)
</t>
<t tx="1.20130426141258.3896">#
# Copyright (c) 2010 Matteo Boscolo, Carlo Pavan
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This Module provide a snap management for the drawing scene and icommand
#
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3897">from PyQt5 import QtCore, QtGui, QtWidgets

from Kernel.initsetting             import SNAP_POINT_ARRAY, ACTIVE_SNAP_POINT, ACTIVE_SNAP_LIST
from Kernel.GeoEntity.point         import Point
from Kernel.GeoUtil.intersection    import *

from Interface.Entity.base          import BaseEntity
</t>
<t tx="1.20130426141258.3898">class SnapPoint():
    @others
</t>
<t tx="1.20130426141258.3899">def __init__(self, scene):
    self.activeSnap=ACTIVE_SNAP_POINT
    self._scene=scene
</t>
<t tx="1.20130426141258.3900">def getSnapPoint(self,  point, entity):
    """
        Get snapPoints
        Remarks:
        force:      [initsetting.SNAP_POINT_ARRAY element]
        fromPoint:  [Geoent.Pointfloat]
        fromEnt:    [GeoEnt.*]
    """
    def pointReturn(pointCalculated,realPoint):
        if pointCalculated==None:
            return realPoint
        return pointCalculated
        
    if self.activeSnap==SNAP_POINT_ARRAY["NONE"]:
        return point
    else:
        snapPoint=point
        if SNAP_POINT_ARRAY["MID"] == self.activeSnap:
            return pointReturn(self.getSnapMiddlePoint(entity),point)
        elif SNAP_POINT_ARRAY["END"] == self.activeSnap:
            return pointReturn(self.getSnapEndPoint(entity, point),point)
        elif SNAP_POINT_ARRAY["ORTHO"] == self.activeSnap:
            return pointReturn(self.getSnapOrtoPoint(entity, point),point)
        elif SNAP_POINT_ARRAY["CENTER"]== self.activeSnap:
            return pointReturn(self.getSnapCenterPoint(entity),point)
        elif SNAP_POINT_ARRAY["QUADRANT"]== self.activeSnap:
            return pointReturn(self.getSnapQuadrantPoint(entity, snapPoint),point)
        elif SNAP_POINT_ARRAY["ORIG"]== self.activeSnap:
            return Point(0.0, 0.0)
        elif SNAP_POINT_ARRAY["INTERSECTION"]== self.activeSnap:
            return pointReturn(self.getIntersection(entity,snapPoint ),point)
        elif SNAP_POINT_ARRAY["LIST"]== self.activeSnap:
            #TODO: this should be used when checklist of snap will be enabled
            snapPoints=[]
            if ACTIVE_SNAP_LIST.count(SNAP_POINT_ARRAY["MID"])&gt;0:
                pnt=self.getSnapMiddlePoint(entity)
                if pnt!=None:
                    snapPoints.append(pnt)

            if ACTIVE_SNAP_LIST.count(SNAP_POINT_ARRAY["END"])&gt;0:
                pnt=self.getSnapEndPoint(entity, snapPoint)
                if pnt!=None:
                    snapPoints.append(pnt)

            if ACTIVE_SNAP_LIST.count(SNAP_POINT_ARRAY["QUADRANT"])&gt;0:
                pnt=self.getSnapQuadrantPoint(entity, snapPoint)
                if pnt!=None:
                    snapPoints.append(pnt)

            if ACTIVE_SNAP_LIST.count(SNAP_POINT_ARRAY["ORTHO"])&gt;0:
                pnt=self.getSnapOrtoPoint(entity, snapPoint)
                if pnt!=None:
                    snapPoints.append(pnt)

            if ACTIVE_SNAP_LIST.count(SNAP_POINT_ARRAY["INTERSECTION"])&gt;0:
                pnt=self.getIntersection(entity, snapPoint)
                if pnt!=None:
                    snapPoints.append(pnt)

            outPoint=(None, None)
            for p in snapPoints:
                if p!=None:
                    distance=p.dist(snapPoint)
                    if outPoint[0]==None:
                        outPoint=(p, distance)
                    else:
                        if outPoint[1]&gt;distance:
                            outPoint=(p, distance)
            else:
                if outPoint[0]!=None:
                    snapPoint=outPoint[0]
        return pointReturn(snapPoint,point)
</t>
<t tx="1.20130426141258.3901">def getSnapOrtoPoint(self, entity, point):
    """
        this function compute the orto to point snap constraint
    """
    # Now only works for segments and arcs. USES THE getPROJECTION METHOD
    if self._scene.fromPoint==None or entity == None:
        #print "log: getSnapOrtoPoint :frompoint or entity is none "
        return None

    if getattr(entity, 'geoItem', None):
        if getattr(entity.geoItem, 'getProjection', None):
            pT=entity.geoItem.getProjection(self._scene.fromPoint)
            return pT
    else:
        return None
</t>
<t tx="1.20130426141258.3902">def getSnapTangentPoint(self, point):
    """
        this function compute the Tangent to point snap constraint
    """
    #TODO: getSnapTangentPoint
    returnVal=None
    #this function have to be implemented as follow
    #   1) get the Tangent point from the previews entity
    #   2) update the previews snap point
    return returnVal
</t>
<t tx="1.20130426141258.3903">def getSnapMiddlePoint(self, entity):
    """
        this function compute midpoint snap constraint to the entity argument
    """
    returnVal=None
    if getattr(entity, 'geoItem', None):
        if getattr(entity.geoItem, 'getMiddlePoint', None):
            returnVal=entity.geoItem.getMiddlePoint()
    return returnVal
</t>
<t tx="1.20130426141258.3904">def getSnapEndPoint(self, entity, point):
    """
        this function compute the  snap endpoint
    """
    if point == None or entity == None:
        return None

    if getattr(entity, 'geoItem', None):
        if getattr(entity.geoItem, 'getEndpoints', None):
            p1, p2=entity.geoItem.getEndpoints()
            if point.dist(p1)&lt;point.dist(p2):
                return p1
            else:
                return p2
    elif getattr(entity.geoItem, 'getPoint', None):
            return entity.geoItem.getPoint()
            
    else:
        return None
</t>
<t tx="1.20130426141258.3905">def getSnapCenterPoint(self, entity):
    """
        this function compute the  snap from the center of an entity
    """
    returnVal=None
    if getattr(entity, 'geoItem', None):
        geoEntity=entity.geoItem
        if getattr(geoEntity, 'getCenter', None):
            returnVal=geoEntity.center
        else:
            returnVal=None
    return returnVal
</t>
<t tx="1.20130426141258.3906">def getIntersection(self, entity, point):
    """
        this function compute the  snap intersection point
    """
    returnVal=None
    distance=None
    if entity!=None:
        geoEntityFrom=entity.geoItem
        entityList=self._scene.collidingItems(entity)
        for ent in entityList:
            if not isinstance(ent,BaseEntity):
                continue
            if isinstance(ent, BaseEntity):
                intPoint=find_intersections(ent.geoItem,geoEntityFrom)
                for tp in intPoint:
                    iPoint=Point(tp[0], tp[1])
                    if distance==None:
                        distance=iPoint.dist(point)
                        returnVal=iPoint
                    else:
                        spoolDist=iPoint.dist(point)
                        if distance&gt;spoolDist:
                            distance=spoolDist
                            returnVal=iPoint
    return returnVal
</t>
<t tx="1.20130426141258.3907">def getSnapQuadrantPoint(self, entity, point):
    """
        this function compute the  snap from the quadrant
    """
    returnVal=None
    if getattr(entity, 'geoItem', None):
        geoEntity=entity.geoItem
        if getattr(geoEntity, 'getQuadrant', None):
            dist=None
            for p in geoEntity.getQuadrant():
                if dist==None:
                    returnVal=p
                    dist=point.dist(p)
                    continue
                else:
                    newDist=point.dist(p)
                    if dist&gt;newDist:
                        dist=newDist
                        returnVal=p
    return returnVal
</t>
<t tx="1.20130426141258.3908">class SnapMark(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.3909">def __init__(self):
    super(SnapMark, self).__init__()
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
    self.setFlag(QtWidgets.QGraphicsItem.ItemIgnoresTransformations, True)
    self.hide()
</t>
<t tx="1.20130426141258.3910">def collidesWithItem(self,other,mode):
    return False
</t>
<t tx="1.20130426141258.3911">def shape(self):
    """
        overloading of the shape method
    """
    return self.definePath()
</t>
<t tx="1.20130426141258.3912">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.3913">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    painter.setPen(QtGui.QPen(QtGui.QColor(255, 50, 50), 2, join=QtCore.Qt.MiterJoin))
    painter.drawPath(self.definePath())
</t>
<t tx="1.20130426141258.3914">def move(self, x, y):
    """
        show the previously added mark and place it in snap position
    """
    self.show()
    self.setPos(x, y)
</t>
<t tx="1.20130426141258.3915">class SnapEndMark(SnapMark):
    @others
</t>
<t tx="1.20130426141258.3916">def __init__(self, x, y):
    super(SnapEndMark, self).__init__()
    self.setToolTip("EndPoint")
    self.x=x
    self.y=y
</t>
<t tx="1.20130426141258.3917">def collidesWithItem(self,other,mode):
    print("collidesWithItem")
    return False
</t>
<t tx="1.20130426141258.3918">def definePath(self):
    rect=QtCore.QRectF(self.x-5.0, self.y-5.0, 10.0, 10.0)
    path=QtGui.QPainterPath()
    path.addRect(rect)
    return path
</t>
<t tx="1.20130426141258.3919"></t>
<t tx="1.20130426141258.3920"></t>
<t tx="1.20130426141258.3921">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide class to manage geometrical CustomVector operation
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3922">import math

from PyQt5 import QtCore, QtGui, QtWidgets

from Kernel.pycadevent              import PyCadEvent
</t>
<t tx="1.20130426141258.3923">class CustomVector(object):
    """
        Provide a full 2d CustomVector operation and definition
    """
    @others
</t>
<t tx="1.20130426141258.3924">def __init__(self,p1,p2):
    """
        Default Constructor
    """
    x=p1.x()
    y=p1.y()
    x1=p2.x()
    y1=p2.y()
    self.X=x1-x
    self.Y=y1-y
</t>
<t tx="1.20130426141258.3925">@property    
def absAng(self):
    """
        return the angle from the cartesian reference
    """
    _y=self.Y
    ang=math.atan2(float(_y),float(self.X))
    if _y&lt;0:
        ang=ang+2*math.pi
    return ang
</t>
<t tx="1.20130426141258.3926">@property
def qtPoint(self):
    """
        get the qtPoint 
    """
    return QtCore.QPointF(self.X, self.Y)
</t>
<t tx="1.20130426141258.3927">def mag(self):
    """
        Get the versor
    """
    _a=self.absAng
    self.X=math.cos(_a)
    self.Y=math.sin(_a)
</t>
<t tx="1.20130426141258.3928">def mult(self,scalar):
    """
        Multiplae the CustomVector for a scalar value
    """
    self.X=scalar*self.norm*math.cos(self.absAng)
    self.Y=scalar*self.norm*math.sin(self.absAng)    
</t>
<t tx="1.20130426141258.3929">@property    
def norm(self):
    """
      Get The Norm Of the CustomVector
    """
    return math.sqrt(pow(self.X,2)+pow(self.Y,2))
</t>
<t tx="1.20130426141258.3930">class PositionHandler(QtWidgets.QGraphicsItem):
    """
        this class provide a custom object for easily moving entity into
        PythonCAD
    """
    @others
</t>
<t tx="1.20130426141258.3931">def __init__(self, position=None ):
    super(PositionHandler, self).__init__()
    self.setAcceptHoverEvents(True)
    self.circle=CirclePosition(self, QtCore.QPointF(5,5))
    self.circle.setAcceptHoverEvents(False)
    self.circle.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
    self.circle.setAcceptDrops(False)
    self.circle.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, False)
    self.ActionHandler=ActionHandler(self, QtCore.QPointF(0,0))
    self.ActionHandler.fireApply+=self._fireApply
    self.customAction=PyCadEvent()
    self.confirmEvent=PyCadEvent()
    self.fireApply=PyCadEvent()
    if position!=None:
        self.setPos(position)
    self.position=position
</t>
<t tx="1.20130426141258.3932">def _fireApply(self):
    print("Apply")
    self.fireApply()
</t>
<t tx="1.20130426141258.3933">def handlerUpdated(self, angle, position):
    """
        re fire the event to the upper class
    """
    self.customAction(item, angle, position, self.distance)
</t>
<t tx="1.20130426141258.3934">def updateSelected(self):
    pass
</t>
<t tx="1.20130426141258.3935">def boundingRect(self):
    """
        method overloaded
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.3936">def definePath(self):
    """
    method overloaded
    """
    p1=QtCore.QPointF(self.circle.pos().x()-5.0,self.circle.pos().y()-5.0)
    p2=QtCore.QPointF(self.ActionHandler.pos().x(),self.ActionHandler.pos().y())
    rect=QtCore.QRectF(p1,p2)
    rectPath=QtGui.QPainterPath()
    rectPath.addRect(rect)
    return rectPath
</t>
<t tx="1.20130426141258.3937">def shape(self):            
    """
        overloading of the shape method 
    """
    return self.definePath()
</t>
<t tx="1.20130426141258.3938">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    #painter.setBrush(QtCore.Qt.cyan);
    #painter.setPen(QtCore.Qt.darkCyan);
    #painter.drawPath(self.definePath())
    pass
</t>
<t tx="1.20130426141258.3939">@property
def distance(self):  
    """
        get the distance of the trasformation
    """  
    distance=self.deltaPos
    dis=math.sqrt(pow(distance.x()-5.0, 2)+pow(distance.y()-5.0, 2))
    return dis
</t>
<t tx="1.20130426141258.3940">@property
def angle(self):
    """
        get the angle of the trasformation
    """
    return self.ActionHandler.rotation()
</t>
<t tx="1.20130426141258.3941">@property
def scenePos(self):
    """
        get the scene position
    """
    scenePos=self.ActionHandler.scenePos()
    return QtCore.QPointF(scenePos.x()-5,scenePos.y()-5)
</t>
<t tx="1.20130426141258.3942">@property
def deltaPos(self):
    """
        get the position from the starting point
    """
    return self.circle.scenePos()-self.ActionHandler.scenePos()
</t>
<t tx="1.20130426141258.3943">class ActionHandler(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.3944">def __init__(self,parent=None, position=None ):
    super(ActionHandler, self).__init__(parent)
    # supported event 
    self.customAction=PyCadEvent()
    self.fireApply=PyCadEvent()
    # Center point 
    p0=QtCore.QPointF(5,5)
    self.circle=CirclePosition(self, p0)
    self.circle.customAction+=self.positionChanged
    self.circle.fireApply+=self._fireApply
    # Angle hendler
    self.arcAngle=ArcAngle(self, p0)
    self.arcAngle.customAction+=self.positionChanged
    self.arcAngle.fireApply+=self._fireApply
    p1=QtCore.QPointF(10,0)
    # Horizontal Arrow
    self.hArrow=ArrowItem(self,p1)
    p2=QtCore.QPointF(0,-10)
    self.hArrow.customAction+=self.positionChanged
    self.arcAngle.fireApply+=self._fireApply
    # Vertical Arrow
    self.vArrow=ArrowItem(self,p2, 90, QtGui.QPen(QtGui.QColor(79, 106, 25)))
    self.vArrow.customAction+=self.positionChanged
    self.arcAngle.fireApply+=self._fireApply
    # QGraphicsItem settings
    if position!=None:
        self.setPos(position)
    self.position=position
    self.setAcceptHoverEvents(True)
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, True)
</t>
<t tx="1.20130426141258.3945">def _fireApply(self):   
    print("ActionHandler apply") 
    self.fireApply()
</t>
<t tx="1.20130426141258.3946">def positionChanged(self):
    """
        notifies that some changed are made in position 
    """
    self.customAction(self.rotation(), self.scenePos())       
</t>
<t tx="1.20130426141258.3947">def boundingRect(self):
    return QtCore.QRectF()
</t>
<t tx="1.20130426141258.3948">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    self.parentItem().paint(painter,option,widget)
</t>
<t tx="1.20130426141258.3949">class ArcAngle(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.3950">def __init__(self,parent=None , position=None ):
    super(ArcAngle, self).__init__(parent)
    self.setAcceptHoverEvents(True)                        #Fire over events
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
    self.setAcceptDrops(True)
    if position!=None:
        self.setPos(position)
    self.position=position
    self.customAction=PyCadEvent()
    self.fireApply=PyCadEvent()
</t>
<t tx="1.20130426141258.3951">def updateSelected(self):
    pass    
</t>
<t tx="1.20130426141258.3952">def definePath(self):
    rectangle=QtCore.QRectF(-47.5,40, 105, -110)
    arrowPath=QtGui.QPainterPath()
    arrowPath.moveTo(5, -15)
    arrowPath.arcTo(rectangle, 0, -90)
    return arrowPath
</t>
<t tx="1.20130426141258.3953">def shape(self):            
    """
        overloading of the shape method 
    """
    return self.definePath()
</t>
<t tx="1.20130426141258.3954">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.3955">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    painter.setPen(QtGui.QPen(QtGui.QColor(79, 106, 25)))
    painter.setBrush(QtGui.QColor(0,0,128))
    painter.drawPath(self.definePath())
</t>
<t tx="1.20130426141258.3956">def mousePressEvent(self, event):
    self.update()
    r=self.parentItem().rotation()
    r1=abs(math.degrees(CustomVector(self.parentItem().scenePos(),event.scenePos()).absAng))
    if r&gt;=0 and r&lt;=90:
        if r1&gt;=270 and r1&lt;=360:
            r=abs(360+r)
    self.delta=abs(r-r1)
    super(ArcAngle, self).mousePressEvent(event)
</t>
<t tx="1.20130426141258.3957">def mouseMoveEvent(self, event):
    v=CustomVector(self.parentItem().scenePos(),event.scenePos())
    ang=abs(math.degrees(v.absAng))+self.delta
    self.setRotation(ang)
    super(ArcAngle, self).mouseMoveEvent(event)    
</t>
<t tx="1.20130426141258.3958">def setRotation(self, angle):
    """
        set the rotation angle
    """
    self.parentItem().setRotation(angle%360)
    self.customAction()
</t>
<t tx="1.20130426141258.3959">def contextMenuEvent(self, event) :
    self.menu=ContextMenu(self._keyPress, self._apply)
    self.menu.exec_(event.screenPos())
    del(self.menu)
</t>
<t tx="1.20130426141258.3960">def _keyPress(self, keyEvent):
    """
        keyPressEvent
    """
    if keyEvent.key()==16777220: # Return Pressed
        text=self.menu.qle.text()
        r=self.parentItem().rotation()
        self.setRotation(float(text)+r)
        return
    QtWidgets.QLineEdit.keyPressEvent(self.menu.qle, keyEvent)   
</t>
<t tx="1.20130426141258.3961">def _apply(self, event):
    self.fireApply()
</t>
<t tx="1.20130426141258.3962">class ContextMenu(QtWidgets.QMenu):
    @others
</t>
<t tx="1.20130426141258.3963">def __init__(self, keyPressFunction=None, confermationFunction=None):
    super(ContextMenu, self).__init__()
    #set action QLineEdit
    if keyPressFunction!= None:
        self.qle=QtWidgets.QLineEdit()
        self.qle.keyPressEvent=keyPressFunction
        wac=QtWidgets.QWidgetAction(self)
        wac.setDefaultWidget(self.qle)
        dummyAction=self.addAction(wac)
    #set apply action 
    if confermationFunction!=None:
        self.label=QtWidgets.QLabel()
        self.label.setText("Apply")
        self.label.mouseReleaseEvent=confermationFunction
        wac1=QtWidgets.QWidgetAction(self)
        wac1.setDefaultWidget(self.label)
        dummyAction=self.addAction(wac1);
</t>
<t tx="1.20130426141258.3964">class CirclePosition(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.3965">def __init__(self,parent=None , position=None ):
    super(CirclePosition, self).__init__(parent)
    self.setAcceptHoverEvents(True)                        #Fire over events
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
    self.setAcceptDrops(True)
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, False)
    if position!=None:
        self.setPos(position)
    self.customAction=PyCadEvent()
    self.fireApply=PyCadEvent()
</t>
<t tx="1.20130426141258.3966">def updateSelected(self):
    pass    
</t>
<t tx="1.20130426141258.3967">def definePath(self):
    ellipse=QtCore.QRectF(-10.0, -10.0, 10.0, 10.0)
    arrowPath=QtGui.QPainterPath()
    arrowPath.addEllipse(ellipse)
    return arrowPath
</t>
<t tx="1.20130426141258.3968">def shape(self):            
    """
        overloading of the shape method 
    """
    return self.definePath()
</t>
<t tx="1.20130426141258.3969">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.3970">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    painter.setPen(QtGui.QPen(QtGui.QColor(79, 106, 25)))
    painter.setBrush(QtGui.QColor(0,0,128))
    painter.drawPath(self.definePath())
</t>
<t tx="1.20130426141258.3971">def mousePressEvent(self, event):
    self.update()
    self.delta=event.pos()
    super(CirclePosition, self).mousePressEvent(event)
</t>
<t tx="1.20130426141258.3972">def mouseReleaseEvent(self, event):
    self.update()
    super(CirclePosition, self).mouseReleaseEvent(event)
</t>
<t tx="1.20130426141258.3973">def mouseMoveEvent(self, event):
    x=event.pos().x()-self.delta.x()+self.parentItem().pos().x()
    y=event.pos().y()-self.delta.y()+self.parentItem().pos().y()
    if self.parentItem()!= None:         
        p=QtCore.QPointF(x, y)
        self.parentItem().setPos(p)
    else:
        self.setPos(QtCore.QPointF(x, y))
        super(mouseMoveEvent, self).mouseMoveEvent(event)
    self.customAction() 
</t>
<t tx="1.20130426141258.3974">def contextMenuEvent(self, event):
    self.menu=ContextMenu(self._keyPress, self._apply)
    self.menu.exec_(event.screenPos())
    del(self.menu)
</t>
<t tx="1.20130426141258.3975">def _keyPress(self, keyEvent):
    """
        keyPressEvent
    """
    if keyEvent.key()==16777220: # Return Pressed
        text=self.menu.qle.text()
        x, y=text.split(',')
        p=QtCore.QPointF(float(x), float(y))
        self.parentItem().setPos(p)
        return
    QtWidgets.QLineEdit.keyPressEvent(self.menu.qle, keyEvent)   
</t>
<t tx="1.20130426141258.3976">def _apply(self, event):
    self.fireApply()
</t>
<t tx="1.20130426141258.3977">class ArrowItem(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.3978">def __init__(self,parent=None, position=None, rotation=None , arrowColor=None):
    super(ArrowItem, self).__init__(parent)
    self.setAcceptHoverEvents(True)                        #Fire over events
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
    self.setAcceptDrops(True)
    self.arrowColor=QtGui.QPen(QtGui.QColor(79, 106, 25))
    self._angle=0
    if arrowColor!=None:
        self.arrowColor=arrowColor
    if position!=None:
        self.setPos(position)
    if rotation!=None:
        self.rotate(-rotation)
        self._angle=rotation
    self.delta=0
    self.customAction=PyCadEvent()
    self.fireApply=PyCadEvent()
</t>
<t tx="1.20130426141258.3979">def updateSelected(self):
    pass
</t>
<t tx="1.20130426141258.3980">def definePath(self):
    poligonArrow=QtGui.QPolygonF()
    poligonArrow.append(QtCore.QPointF(0.0, 5.0))
    poligonArrow.append(QtCore.QPointF(60.0, 5.0))
    poligonArrow.append(QtCore.QPointF(60.0, 10.0))
    poligonArrow.append(QtCore.QPointF(80.0, 0.0))
    poligonArrow.append(QtCore.QPointF(60.0, -10.0))        
    poligonArrow.append(QtCore.QPointF(60.0, -5.0))
    poligonArrow.append(QtCore.QPointF(0.0, -5.0))
    poligonArrow.append(QtCore.QPointF(0.0, 5.0))
    arrowPath=QtGui.QPainterPath()
    arrowPath.addPolygon(poligonArrow)
    return arrowPath
</t>
<t tx="1.20130426141258.3981">def shape(self):            
    """
        overloading of the shape method 
    """
    return self.definePath()
</t>
<t tx="1.20130426141258.3982">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.3983">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    painter.setPen(self.arrowColor)
    painter.setBrush(QtGui.QColor(255,0,0))
    painter.drawPath(self.definePath())
</t>
<t tx="1.20130426141258.3984">def mousePressEvent(self, event):
    self.update()
    self.delta=event.pos()
    super(ArrowItem, self).mousePressEvent(event)
</t>
<t tx="1.20130426141258.3985">def mouseReleaseEvent(self, event):
    self.update()
    super(ArrowItem, self).mouseReleaseEvent(event)
</t>
<t tx="1.20130426141258.3986">def mouseMoveEvent(self, event):
    if self.parentItem()!= None:
        distance=event.pos().x()-self.delta.x()
        self.setDistance(distance)
    else:
        super(ArrowItem, self).mouseMoveEvent(event)
</t>
<t tx="1.20130426141258.3987">def setDistance(self, distance):
    ang=math.radians((self.parentItem().rotation()%360)-self._angle)
    x=distance*math.cos(ang)+self.parentItem().pos().x()
    y=distance*math.sin(ang)+self.parentItem().pos().y()
    self.parentItem().setPos(QtCore.QPointF(x, y))
    self.customAction()
</t>
<t tx="1.20130426141258.3988">def contextMenuEvent(self, event):
    self.menu=ContextMenu(self._keyPress, self._apply)
    self.menu.exec_(event.screenPos())
    del(self.menu)
</t>
<t tx="1.20130426141258.3989">def _keyPress(self, keyEvent):
    """
        keyPressEvent
    """
    if keyEvent.key()==16777220: # Return Pressed
        text=self.menu.qle.text()
        self.setDistance(float(text))
        return
    QtWidgets.QLineEdit.keyPressEvent(self.menu.qle, keyEvent)   
</t>
<t tx="1.20130426141258.3990">def _apply(self, event):
    print("ArrowItem apply")
    self.fireApply()
</t>
<t tx="1.20130426141258.3991">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt arc class
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3992">from PyQt5 import QtCore
from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.3993">class Arc(BaseEntity):
    """
        this class define the arcQT object 
    """
    @others
</t>
<t tx="1.20130426141258.3994">def __init__(self, entity):
    super(Arc, self).__init__(entity)
    geoEnt=self.geoItem  # get the geometry from kernel
    self.startPoint, p2=geoEnt.getEndpoints()     
    self.xc, self.yc=geoEnt.center.getCoords()
    startAngle=geoEnt.startAngle
    self.sa=startAngle
    spanAngle=geoEnt.endAngle
    self.yc=(-1.0*self.yc)- geoEnt.radius
    self.xc=self.xc-geoEnt.radius
    self.h=geoEnt.radius*2
    # By default, the span angle is 5760 (360 * 16, a full circle).
    # From pythoncad the angle are in radiant ..
    self.startAngle=(startAngle*180/math.pi)*16
    self.spanAngle=(spanAngle*180/math.pi)*16-self.startAngle
    return
</t>
<t tx="1.20130426141258.3995">def drawShape(self, painterPath):    
    """
        extending of the shape method 
    """
    qRect=QtCore.QRectF(self.xc,
                         self.yc,
                         self.h,
                         self.h)
    #x, y=self.startPoint.getCoords()
    painterPath.moveTo(self.xc, self.yc*-1.0)
    painterPath.arcTo(qRect,self.startAngle,self.spanAngle) 
    return
</t>
<t tx="1.20130426141258.3996">def drawGeometry(self, painter, option, widget):
    """
        extending of the paint method
    """
    #Create Arc/Circle
    qRect=QtCore.QRectF(self.xc,
                         self.yc,
                         self.h,
                         self.h)
    painter.drawArc(qRect,self.startAngle,  self.spanAngle)
</t>
<t tx="1.20130426141258.3997"> #QLinearGradient myGradient;
 #QPen myPen;
 #QPolygonF myPolygon;

 #QPainterPath myPath;
 #myPath.addPolygon(myPolygon);

 #QPainter painter(this);
 #painter.setBrush(myGradient);
 #painter.setPen(myPen);
 #painter.drawPath(myPath);



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.3998">import math
from PyQt5 import QtCore, QtGui, QtWidgets
</t>
<t tx="1.20130426141258.3999">class ArrowItem(QtWidgets.QGraphicsItem):
    @others
</t>
<t tx="1.20130426141258.4000">def definePath(self):
    poligonArrow=QtGui.QPolygonF()
    poligonArrow.append(QtCore.QPointF(0.0, 5.0))
    poligonArrow.append(QtCore.QPointF(60.0, 5.0))
    poligonArrow.append(QtCore.QPointF(60.0, 10.0))
    poligonArrow.append(QtCore.QPointF(80.0, 0.0))
    poligonArrow.append(QtCore.QPointF(60.0, -10.0))        
    poligonArrow.append(QtCore.QPointF(60.0, -5.0))
    poligonArrow.append(QtCore.QPointF(0.0, -5.0))
    poligonArrow.append(QtCore.QPointF(0.0, 5.0))
    
    arrowPath=QtGui.QPainterPath()
    arrowPath.addPolygon(poligonArrow)
    return arrowPath
</t>
<t tx="1.20130426141258.4001">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return QtCore.QRectF(-1,-250 ,80,50)
</t>
<t tx="1.20130426141258.4002">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    painter.setPen(QtGui.QPen(QtGui.QColor(79, 106, 25)))
    painter.setBrush(QtGui.QColor(122, 163, 39))
    painter.drawPath(self.definePath())
</t>
<t tx="1.20130426141258.4003">#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module provide basic class for all  the qtitems to be displayed
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4004">import sys
from PyQt5.QtWidgets import *
#if sys.version_info &lt;(2, 7):
#    import sip
#    sip.setapi('QString', 2)
#    sip.setapi('QVariant', 2)

import math
from PyQt5  import QtCore, QtGui,  QtWidgets

from Kernel.initsetting         import PYTHONCAD_HIGLITGT_COLOR, PYTHONCAD_COLOR, MOUSE_GRAPH_DIMENSION

from Kernel.GeoEntity.point     import Point
</t>
<t tx="1.20130426141258.4005">class BaseEntity(QtWidgets.QGraphicsItem):
    shapeSize=MOUSE_GRAPH_DIMENSION
    showShape=False #This Flag is used for debug porpoise
    showBBox=False  #This Flag is used for debug porpoise
    @others
</t>
<t tx="1.20130426141258.4006">def __init__(self, entity):
    super(BaseEntity, self).__init__()
    self.setAcceptHoverEvents(True)                        #Fire over events
    self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
    #Get the geometry
    self._entity=entity
    self.setToolTip(str(self.toolTipMessage))
    #Set color from style
    r, g, b= self.style.getStyleProp("entity_color")
    color = QtGui.QColor.fromRgb(r, g, b)
    #set line thickness
    lineWith=self.style.getStyleProp("entity_thickness")
    #set line style
    penStyle=self.style.getStyleProp("entity_linetype")
    pen=QtGui.QPen(color)
    #TODO: Actually disable because the line with is not very nice
    #in the drawing ..
    #pen.setWidthF(float(lineWith))
    pen.setStyle(int(penStyle))
    self.pen=pen
    return
</t>
<t tx="1.20130426141258.4007">def nearestSnapPoint(self, qtPointEvent, snapForceType=None, fromEntity=None):
    """
        compute the nearest point and return a qtPoint
    """
    pClick=Point(qtPointEvent.x(), qtPointEvent.y()*-1.0)
    ePoint=None
    for p in self.geoItem.getUpdatedSnapPoints(snapForceType, pClick,fromEntity):
        distance=p.dist(pClick)
        if ePoint==None:
            oldDistance=distance
            ePoint=p
        else:
            if oldDistance&gt;distance:
                oldDistance=distance
                ePoint=p
    if ePoint==None:
        return qtPointEvent
    return QtCore.QPointF(ePoint.x, ePoint.y*-1.0)
</t>
<t tx="1.20130426141258.4008">@property
def entity(self):
    return self._entity
</t>
<t tx="1.20130426141258.4009">@property
def ID(self):
    return self._entity.getId()
</t>
<t tx="1.20130426141258.4010">@property
def geoItem(self):
    return self._entity.toGeometricalEntity()
</t>
<t tx="1.20130426141258.4011">@property
def style(self):
    return self._entity.getInnerStyle()
</t>
<t tx="1.20130426141258.4012">@property
def toolTipMessage(self):
    toolTipMessage=self.geoItem.info
    return toolTipMessage
</t>
<t tx="1.20130426141258.4013">def updateSelected(self):
    self.setColor()
    self.update(self.boundingRect())
    return
</t>
<t tx="1.20130426141258.4014">def itemChange(self, change, value):
    if change == QtWidgets.QGraphicsItem.ItemSelectedChange:
        #self.setColor(value==1)
        self.update(self.boundingRect())
    return QtWidgets.QGraphicsItem.itemChange(self, change, value)
</t>
<t tx="1.20130426141258.4015">def setColor(self, forceHilight=None):
    if forceHilight==None:
        if self.isSelected() or forceHilight:
            r, g, b=PYTHONCAD_HIGLITGT_COLOR
        else:
            r, g, b=self.style.getStyleProp("entity_color")
    else:
        if forceHilight:
            r, g, b=PYTHONCAD_HIGLITGT_COLOR
        else:
            r, g, b=self.style.getStyleProp("entity_color")
    color = QtGui.QColor.fromRgb(r, g, b)
    self.pen.setColor(color)
    return
</t>
<t tx="1.20130426141258.4016">def setHiglight(self):
    r, g, b=PYTHONCAD_HIGLITGT_COLOR
    color = QtGui.QColor.fromRgb(r, g, b)
    self.pen.setColor(color)
    return
</t>
<t tx="1.20130426141258.4017">def hoverEnterEvent(self, event):
    self.setHiglight()
    super(BaseEntity, self).hoverEnterEvent(event)
    return
</t>
<t tx="1.20130426141258.4018">def hoverLeaveEvent(self, event):
    self.setColor()
    super(BaseEntity, self).hoverLeaveEvent(event)
    return
</t>
<t tx="1.20130426141258.4019">def drawGeometry(self, painter, option, widget):
    """
         this method must be inerit from qtPycadObject
    """
    pass
</t>
<t tx="1.20130426141258.4020">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    pass
</t>
<t tx="1.20130426141258.4021">def shape(self):
    """
        overloading of the shape method
    """
    painterStrock=QtGui.QPainterPathStroker()
    path=QtGui.QPainterPath()
    self.drawShape(path)
    painterStrock.setWidth(self.shapeSize)
    path1=painterStrock.createStroke(path)
    return path1
</t>
<t tx="1.20130426141258.4022">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    #draw geometry
    if self.showShape:
        r, g, b= PYTHONCAD_COLOR["cyan"]
        painter.setPen(QtGui.QPen(QtGui.QColor.fromRgb(r, g, b)))
        painter.drawPath(self.shape())

    if self.showBBox:
        r, g, b= PYTHONCAD_COLOR["darkblue"]
        painter.setPen(QtGui.QPen(QtGui.QColor.fromRgb(r, g, b)))
        painter.drawRect(self.boundingRect())

    painter.setPen(self.pen)
    self.drawGeometry(painter,option,widget)
    return
</t>
<t tx="1.20130426141258.4023">def getDistance(self, qtPointF_1, qtPointF_2):
    """
        calculate the distance betwing the two line
    """
    x=abs(qtPointF_1.x()-qtPointF_2.x())
    y=abs(qtPointF_1.y()- qtPointF_2.y())
    return math.sqrt(x**2+y**2)
</t>
<t tx="1.20130426141258.4024">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.4025">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt text class
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4026">from math import degrees

from Kernel.GeoUtil.geolib                 import Vector

from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.4027">class Dimension(BaseEntity):
    @others
</t>
<t tx="1.20130426141258.4028">def __init__(self, entity):
    super(Dimension, self).__init__(entity)
    self.updateInfo()
    self.location=self.calculateTextPoint()
    stileFont=self.style.getStyleProp("text_font")
    self.font=QtGui.QFont(stileFont) # This have to be derived from the geoent as son is implemented       return
    #self.setPos(QtCore.QPointF(self.firstPoint.x, self.firstPoint.y) )
    #self.rotate(self.angle)
</t>
<t tx="1.20130426141258.4029">def updateInfo(self):
    geoEnt=self.geoItem
    self.firstPoint=geoEnt.firstPoint
    self.secondPoint=geoEnt.secondPoint
    self.thirdPoint=geoEnt.thirdPoint
    self.angle=degrees(geoEnt.angle)
    self.text=str(geoEnt.distance)  # TODO : take care of style in case of
                                    #        additional info at the text
    self.segments=self.getDimensioLines()
</t>
<t tx="1.20130426141258.4030">def calculateTextPoint(self):       # TODO : test if the position is ok
    """
        calculate the text position
    """
    t=self.getDimensioLines()
    p1, p2=t[0]
    p1=Point(p1.x(), p1.y())
    v=Vector(p1, Point(p2.x(), p2.y()))
    vm=v.mag()
    vm.mult(v.norm/2)
    pe=p1+vm.point
    return QtCore.QPointF(pe.x, pe.y)
</t>
<t tx="1.20130426141258.4031">def getDimensioLines(self):
    """
        compute all the segment needed for the dimension
    """
    p1p2v=Vector(self.firstPoint, self.secondPoint)
    v=Vector(self.firstPoint,self.thirdPoint)
    pp=self.firstPoint+p1p2v.map(v.point).point
    p3ppv=Vector(pp, self.thirdPoint)
    #
    fp=self.firstPoint+p3ppv.point
    fp=QtCore.QPointF(fp.x, fp.y*-1.0)
    sp=self.secondPoint+p3ppv.point
    sp=QtCore.QPointF(sp.x, sp.y*-1.0)
    #
    fp1=QtCore.QPointF(self.firstPoint.x, self.firstPoint.y*-1.0)
    sp1=QtCore.QPointF(self.secondPoint.x, self.secondPoint.y*-1.0)
    #
    return [(fp, sp), (fp, fp1), (sp, sp1)]
</t>
<t tx="1.20130426141258.4032">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    painterPath.addText(self.location, self.font, self.text)
    for p1, p2 in self.segments:
        painterPath.moveTo(p1)
        painterPath.lineTo(p2)
    return
</t>
<t tx="1.20130426141258.4033">def drawGeometry(self, painter, option, widget):
    # Create Text
    painter.drawText(self.location,  self.text)
    for p1, p2 in self.segments:
        painter.drawLine(p1, p2)
</t>
<t tx="1.20130426141258.4034">#
# Copyright (c) 2010 Matteo Boscolo, Gertwin Groen
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This module the graphics scene class
#
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4035">import math

from PyQt5 import QtCore, QtGui, QtWidgets
from Kernel.pycadevent          import PyCadEvent
</t>
<t tx="1.20130426141258.4036">class DinamicEntryLine(QtWidgets.QLineEdit):
    @others
</t>
<t tx="1.20130426141258.4037">def __init__(self):
    super(DinamicEntryLine, self).__init__()
    self.hide()
    self.h=20
    self.w=60
    self.onEnter=PyCadEvent()
</t>
<t tx="1.20130426141258.4038">def setPos(self, x, y):
    self.setGeometry(x, y, self.w, self.h)
</t>
<t tx="1.20130426141258.4039">@property
def text(self):
    return super(DinamicEntryLine, self).text()
</t>
<t tx="1.20130426141258.4040">@text.setter
def text(self, value):
    super(DinamicEntryLine, self).settext(value)
</t>
<t tx="1.20130426141258.4041">def show(self):
    self.setFocus(7)
    super(DinamicEntryLine, self).show()  
</t>
<t tx="1.20130426141258.4042">def keyPressEvent(self, event):
    if event.key()==QtCore.Qt.Key_Return:
        self.onEnter()
        super(DinamicEntryLine, self).hide()  
    super(DinamicEntryLine, self).keyPressEvent(event)
</t>
<t tx="1.20130426141258.4043">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt ellipse class
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4044">from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.4045">class Ellipse(BaseEntity):
    @others
</t>
<t tx="1.20130426141258.4046">def __init__(self, entity):
    super(Ellipse, self).__init__(entity)
    geoEnt=self.geoItem
    self.xc,self.yc=geoEnt.center.getCoords()
    self.yc=self.yc*-1.0
    self.h=geoEnt.verticalRadius
    self.w=geoEnt.horizontalRadius
    self.setPos(QtCore.QPointF(self.xc, self.yc))
    self.rotate(0.0)
    return
</t>
<t tx="1.20130426141258.4047">def drawShape(self, painterPath):    
    """
        called from the shape method 
    """
    w2=self.w/2.0
    h2=self.h/2.0
    painterPath.addEllipse(-w2,-h2,self.w,self.h )     
</t>
<t tx="1.20130426141258.4048">def drawGeometry(self, painter, option, widget):
    """
        called from the paint method
    """
    #   Create Ellipse
    painter.drawEllipse(self.boundingRect())
</t>
<t tx="1.20130426141258.4049">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt pythoncad Point class
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4050">from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.4051">class Point(BaseEntity):
    """
        this class define the arcQT object
    """
    @others
</t>
<t tx="1.20130426141258.4052">def __init__(self, entity):
    super(Point, self).__init__(entity)
    self.xc,self.yc= self.geoItem.getCoords()
    self.yc=(-1.0*self.yc)
    return
</t>
<t tx="1.20130426141258.4053">def boundingRect(self):
    return QtCore.QRectF(self.xc-self.shapeSize/2,self.yc-self.shapeSize/2 ,self.shapeSize ,self.shapeSize)
</t>
<t tx="1.20130426141258.4054">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    painterPath.addRect(self.boundingRect())
</t>
<t tx="1.20130426141258.4055">def drawGeometry(self, painter, option, widget):
    """
        overloading of the paint method
    """
    #Create Arc/Circle
    p=QtCore.QPoint(self.xc, self.yc)
    painter.drawRect(self.boundingRect())
    painter.drawPoint(p)
</t>
<t tx="1.20130426141258.4056">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt arc class
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4057">from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.4058">class Polyline(BaseEntity):
    """
        this class define the polyline object 
    """
    @others
</t>
<t tx="1.20130426141258.4059">def __init__(self, entity):
    super(Polyline, self).__init__(entity)
    self.qtPoints=self.getQtPointF()
    return
</t>
<t tx="1.20130426141258.4060">def getQtPointF(self):
    qtPoints=[]
    geoPolyline=self.geoItem
    for p in geoPolyline.points():
        x, y=p.getCoords()
        qtPointf=QtCore.QPointF(x, y*-1.0 )
        qtPoints.append(qtPointf)
    return qtPoints
</t>
<t tx="1.20130426141258.4061">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    painterPath.moveTo(self.qtPoints[0])
    for i in range(1,len(self.qtPoints)):
        painterPath.lineTo(self.qtPoints[i])    
</t>
<t tx="1.20130426141258.4062">def drawGeometry(self, painter, option, widget):
    """
        overloading of the paint method
    """
    #Create poliline Object
    pol=QtGui.QPolygonF(self.qtPoints)
    painter.drawPolyline(pol)
    #painter.drawRect(self.boundingRect())
</t>
<t tx="1.20130426141258.4063"># Copyright (c) 2009,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# classes for interface segment
#


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4064">from Interface.Entity.base import *
</t>
<t tx="1.20130426141258.4065">class Segment(BaseEntity):
    @others
</t>
<t tx="1.20130426141258.4066">def __init__(self, entity):
    super(Segment, self).__init__(entity)
    p1, p2=self.geoItem.getEndpoints()
    self.x, self.y=p1.getCoords()
    self.x1, self.y1=p2.getCoords()
    self.y=self.y*-1.0
    self.y1=self.y1*-1.0
    return
</t>
<t tx="1.20130426141258.4067">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    painterPath.moveTo(self.x, self.y)
    painterPath.lineTo(self.x1, self.y1)
</t>
<t tx="1.20130426141258.4068">def drawGeometry(self, painter, option, widget):
    #Create Segment
    p1=QtCore.QPointF(self.x, self.y)
    p2=QtCore.QPointF(self.x1, self.y1)
    painter.drawLine(p1,p2)
</t>
<t tx="1.20130426141258.4069">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt text class
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4070">from Interface.Entity.base import *
from math import degrees
</t>
<t tx="1.20130426141258.4071">class Text(BaseEntity):
    @others
</t>
<t tx="1.20130426141258.4072">def __init__(self, entity):
    super(Text, self).__init__(entity)
    geoEnt=self.geoItem
    self.text=geoEnt.text #QtCore.QString(geoEnt.text)
    x, y=geoEnt.location.getCoords()
    self.angle=degrees(geoEnt.angle)
    self.location=QtCore.QPointF(float(x), -1.0*y)
    self.pointPosition=geoEnt.pointPosition
    self.font=QtGui.QFont() #This have to be derived from the geoent as son is implemented
    self.setPos(self.location)
    self.rotate(self.angle)
    return
</t>
<t tx="1.20130426141258.4073">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    painterPath.addText(QtCore.QPointF(0.0, 0.0), self.font, self.text)        
    return
</t>
<t tx="1.20130426141258.4074">def drawGeometry(self, painter, option, widget):
    #Create Text
    painter.drawText(self.boundingRect(),QtCore.Qt.AlignCenter,  self.text)
</t>
<t tx="1.20130426141258.4075"></t>
<t tx="1.20130426141258.4076"></t>
<t tx="1.20130426141258.4077">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module provide all the global variable to be used from the pythoncad Application
#
#
# Command List
#

# This is only needed for Python v2 but is harmless for Python v3.




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4078">import sys
from PyQt5.QtWidgets import *
#if sys.version_info &lt;(2, 7):
#    import sip
#    sip.setapi('QString', 2)
#    sip.setapi('QVariant', 2)
    
from PyQt5  import QtCore, QtGui,  QtWidgets


from Interface.pycadapp                         import PyCadApp

from Interface.LayerIntf.layertreeobject        import LayerTreeObject
</t>
<t tx="1.20130426141258.4079">class LayerDock(QtWidgets.QDockWidget):
    '''
        A dock able window containing a layer list object.
        The layer list contains all visible layers.
    '''
    @others
</t>
<t tx="1.20130426141258.4080">def __init__(self, parent, document):
    '''
    Creates an edit line in which commands or expressions are evaluated.
    Evaluation of expressions is done by the FunctionHandler object.
    '''
    super(LayerDock, self).__init__('Layers', parent)
    # only dock at the bottom or top
    self.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
    #self.__layer_ctrl = QtGui.QTreeWidget(self, itemDoubleClicked=self._itemActivated, itemActivated=self._itemActivated, itemSelectionChanged=self._itemSelectionChanged)
    #self.setWidget(self.__layer_ctrl)
    self._layerModel=LayerTreeObject(self, document)
    self.setWidget(self._layerModel)
</t>
<t tx="1.20130426141258.4081">def ShowAllLayers(self):
    '''
        Show all layers from the kernel in the control
    '''
    if self._layerTreeObject:
        self._populateLayerCtrl(self.__layer_ctrl.invisibleRootItem(), layer_tree)
    return
</t>
<t tx="1.20130426141258.4082">def RefreshStructure(self):
    """
        refresh the tree view
    """
    self._layerModel.updateTreeStructure(None)
</t>
<t tx="1.20130426141258.4083">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# This  module provide all the global variable to be used from the pythoncad Application
#
#
# This Class define a QTreeWidget implementation for showing the layer structure
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4084">import sys
from PyQt5.QtWidgets import *
#if sys.version_info &lt;(2, 7):
#    import sip
#    sip.setapi('QString', 2)
#    sip.setapi('QVariant', 2)

from PyQt5                              import QtCore, QtGui,  QtWidgets

from Kernel.initsetting                 import MAIN_LAYER
from Kernel.layer                       import Layer
from Kernel.exception                   import PythonCadWarning
</t>
<t tx="1.20130426141258.4085">class LayerItem(QtWidgets.QTreeWidgetItem):
    """
        Single item
    """
    @others
</t>
<t tx="1.20130426141258.4086">def __init__(self, kernelItem,type=0, id=None, active=True):
    super(LayerItem, self).__init__(type)
    self._kernelItem=kernelItem
    self._id=id
    self.setText(0, self.name)
    self.setActive(active)
    self.setVisible(kernelItem.Visible)
</t>
<t tx="1.20130426141258.4087">def setActive(self, activate):
    """
        overwrite the set active property
    """
    self.setExpanded(True)
    if activate:
        self.setBackground(0, QtCore.Qt.lightGray)
    else:
        self.setBackground(0, QtCore.Qt.white)
</t>
<t tx="1.20130426141258.4088">def setVisible(self, activate):        
    if activate:
        self.setText(1, "Visible")    
    else:
        self.setText(1, "Hide")
</t>
<t tx="1.20130426141258.4089">@property
def name(self):
    """
        get the layer name
    """
    return self._kernelItem.name
</t>
<t tx="1.20130426141258.4090">@property
def id(self):
    """
        Get the id of the layer
    """
    return self._id
</t>
<t tx="1.20130426141258.4091">class LayerTreeObject(QtWidgets.QTreeWidget):
    """
        Python
        CAD Layer tree Structure
    """
    @others
</t>
<t tx="1.20130426141258.4092">def __init__(self, parent, document):
    super(LayerTreeObject, self).__init__(parent)
    self._document=document
    self._document.getTreeLayer.setCurrentEvent=self.updateTreeStructure
    self._document.getTreeLayer.deleteEvent=self.updateTreeStructure
    self._document.getTreeLayer.insertEvent=self.updateTreeStructure
    self._document.getTreeLayer.update=self.updateTreeStructure
    self.setColumnCount(2)
    self.setHeaderLabels(("Layer Name ", "Visible"))
    self.TopLevelItem=None
    self.setSortingEnabled(True)
    self.populateStructure()
</t>
<t tx="1.20130426141258.4093">def itemDoubleClicked(self, qTreeWidgetItem ,column):
    return QtWidgets.QTreeWidget.itemDoubleClicked(self, qTreeWidgetItem, column)   
</t>
<t tx="1.20130426141258.4094">#
# Manage event
#
def updateTreeStructure(self, layer):
    """
        update the tree structure
    """
    self.populateStructure()
</t>
<t tx="1.20130426141258.4095">def populateStructure(self):
    """
        populate the tree view structure
    """
    self.clear()
    layerTreeStructure=self._document.getTreeLayer.getLayerTree()
    activeLayer=self._document.getTreeLayer.getActiveLater()
    def populateChild(layers, parentItem, activeLayerId):
        for key in layers:
            c, childs=layers[key]
            if key==activeLayerId:
                parent=LayerItem(c, id=key, active=True)
            else:
                parent=LayerItem(c, id=key, active=False)
            self.expandItem(parent)
            if parentItem==None:
                self.addTopLevelItem(parent)
                self.TopLevelItem=parent
            else:
                parentItem.addChild(parent)
            if childs!=None:
                populateChild(childs,parent,activeLayerId)
    populateChild(layerTreeStructure, None, activeLayerId=activeLayer.getId())
    if self.TopLevelItem!= None:
        self.expandItem(self.TopLevelItem)
</t>
<t tx="1.20130426141258.4096">def contextMenuEvent(self, event):
    """
        context menu event remapped
    """
    contexMenu=QtWidgets.QMenu(self)
    # Create Actions
    addAction=QtWidgets.QAction("Add Child", self, triggered=self._addChild)
    removeAction=QtWidgets.QAction("Remove", self, triggered=self._remove)
    renameAction=QtWidgets.QAction("Rename", self, triggered=self._rename)
    hideAction=QtWidgets.QAction("Hide", self, triggered=self._hide)
    showAction=QtWidgets.QAction("Show", self, triggered=self._show)
    setCurrentAction=QtWidgets.QAction("Set Current", self, triggered=self._setCurrent)
    #TODO : propertyAction=QtGui.QAction("Property", self, triggered=self._property)
    #
    contexMenu.addAction(addAction)
    contexMenu.addAction(removeAction)
    contexMenu.addAction(renameAction)
    contexMenu.addAction(hideAction)
    contexMenu.addAction(showAction)
    contexMenu.addAction(setCurrentAction)
    #contexMenu.addAction(propertyAction)
    #
    contexMenu.exec_(event.globalPos())
    del(contexMenu)
</t>
<t tx="1.20130426141258.4097">def _addChild(self):
    """
        Add a child layer
    """
    text, ok = QtWidgets.QInputDialog.getText(self, 'Input Dialog', 
                                            'Enter Layer Name :')
    if ok:
        layerName=text
        parentLayer=self._document.getTreeLayer.getActiveLater()
        newLayer=self._document.saveEntity(Layer(layerName))
        self._document.getTreeLayer.insert(newLayer, parentLayer)
</t>
<t tx="1.20130426141258.4098">def _remove(self):
    """
        Remove the selected layer
    """
    if self.currentIterfaceTreeObject.name==MAIN_LAYER:
        print("Put on popUp Unable to delate the main layer ")
        return
    layerId=self.currentIterfaceTreeObject.id      
    self._document.getTreeLayer.delete(layerId)
</t>
<t tx="1.20130426141258.4099">def _rename(self): 
    """
        rename the current layer
    """   
    text, ok = QtWidgets.QInputDialog.getText(self, 'Input Dialog', 
                                            'Enter Layer Name :')
    if ok:
        layerId=self.currentIterfaceTreeObject.id  
        self._document.getTreeLayer.rename(layerId, text)
</t>
<t tx="1.20130426141258.4100">def _hide(self):
    """
        Hide the selected layer
    """
    try:
        layerId=self.currentIterfaceTreeObject.id  
        self._document.getTreeLayer.Hide(layerId)
    except PythonCadWarning as e:
        QtWidgets.QMessageBox.information(self, 
                                            "PythonCad -Warning", 
                                            str(e) , 
                                            QtWidgets.QMessageBox.Ok)
</t>
<t tx="1.20130426141258.4101">def _show(self):
    """
        Show the selected layer
    """
    try:
        layerId=self.currentIterfaceTreeObject.id 
        self._document.getTreeLayer.Hide(layerId, False) 
    except PythonCadWarning as e:
        QtWidgets.QMessageBox.information(self, 
                                            "PythonCad -Warning", 
                                            str(e) , 
                                            QtWidgets.QMessageBox.Ok)
</t>
<t tx="1.20130426141258.4102">def _setCurrent(self):
    """
        set the current layer
    """
    cito=self.currentIterfaceTreeObject
    if cito!=None:
        self._document.getTreeLayer.setActiveLayer(cito.id)
        #cito.setActive(True)
</t>
<t tx="1.20130426141258.4103">def _property(self):
    """
        Show the layer property dialog
    """
    pass
</t>
<t tx="1.20130426141258.4104">@property
def currentIterfaceTreeObject(self):
    """
        return the current interface tree Object
    """
    exitLayer=None
    for item in self.selectedItems():
        if(item.id!=None):
            exitLayer=item           
        break
    return exitLayer
</t>
<t tx="1.20130426141258.4105">@language python
@tabwidth -4
@others
#
# Copyright (c) 2010, PythonCad team
#
# Cui = custom user interface
# The custom user interface defines menu's, toolbars and palettes
# which are used to interact with the user.
</t>
<t tx="1.20130426141258.4106"></t>
<t tx="1.20130426141258.4107">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# SegmentPreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4108">import math
from PyQt5 import QtCore
from Interface.Preview.base         import PreviewBase
from Interface.Entity.arc           import Arc
from Kernel.entity                  import Point
from Kernel.exception               import *
from Kernel.GeoEntity.point         import Point as GeoPoint
from Kernel.GeoUtil.geolib  import Vector
</t>
<t tx="1.20130426141258.4109">#TODO+: find a good way to retrive the geometry staff from a item in Interface.Entity.arc ..
#extend it for all the preview entity

class PreviewArc(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4110">def __init__(self,command):
    super(PreviewArc, self).__init__(command)
</t>
<t tx="1.20130426141258.4111">@property
def canDraw(self):
    if self.value[0]!=None:
        self.xc         =   self.value[0].x()
        self.yc         =   self.value[0].y()
        self.h          =   self.value[1]*2
      
        self.xc=self.xc-(self.h/2.0)
        self.yc=self.yc-(self.h/2.0)
        
        self.startAngle =  (self.value[2]*180/math.pi)*16
        self.spanAngle  =  (self.value[3]*180/math.pi)*16 
        return True       
    return False
</t>
<t tx="1.20130426141258.4112">def drawGeometry(self, painter,option,widget):
    """
        Overloading of the paint method
    """
    if self.canDraw:
        Arc.__dict__['drawGeometry'](self, painter,option,widget)
</t>
<t tx="1.20130426141258.4113">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    if self.canDraw:
        Arc.__dict__['drawShape'](self, painterPath)
</t>
<t tx="1.20130426141258.4114">def updatePreview(self,  position, distance, kernelCommand):
    """
        update the data at the preview item
    """
    self.prepareGeometryChange() #qtCommand for update the scene
    for i in range(0, len(kernelCommand.value)):
        self.value[i]=self.revertToQTObject(kernelCommand.value[i])
    # Assing Command Values
    index=kernelCommand.valueIndex
    try:
        raise kernelCommand.exception[index](None)
    except(ExcPoint):
        self.value[index]=self.revertToQTObject(position)
    except(ExcLenght, ExcInt):
        if not distance or distance !=None:
            self.value[index]=distance
    except(ExcAngle):
        p1 = kernelCommand.value[0]
        p2 = GeoPoint(position.x, position.y)
        ang=Vector(p1, p2).absAng
        if index==3:
            ang=ang-self.value[2]
        self.value[index]=ang
    except:
        print("updatePreview: Exception not managed")
        return
</t>
<t tx="1.20130426141258.4115">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#This module provide a class for the segment command
#





@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4116">import math

from PyQt5 import QtCore, QtGui, QtWidgets

from Kernel.exception       import *
from Kernel.GeoEntity.point import Point as GeoPoint
from Kernel.GeoUtil.geolib  import Vector
from Kernel.initsetting     import PYTHONCAD_COLOR, PYTHONCAD_PREVIEW_COLOR, MOUSE_GRAPH_DIMENSION
</t>
<t tx="1.20130426141258.4117">class PreviewBase(QtWidgets.QGraphicsItem):
    showShape=False # This Flag is used for debug porpoise
    showBBox=False  # This Flag is used for debug porpoise
    shapeSize=MOUSE_GRAPH_DIMENSION
    @others
</t>
<t tx="1.20130426141258.4118">def __init__(self, command):
    super(PreviewBase, self).__init__()
    self.updateColor()
    self.value=[]
    for dValue in command.defaultValue:
        val=self.revertToQTObject(dValue)
        self.value.append(val)
</t>
<t tx="1.20130426141258.4119">def updateColor(self):
    """
        update the preview color
    """
    r, g, b=PYTHONCAD_PREVIEW_COLOR
    self.color = QtGui.QColor.fromRgb(r, g, b)
</t>
<t tx="1.20130426141258.4120">def updatePreview(self,  position, distance, kernelCommand):
    """
        update the data at the preview item
    """
    self.prepareGeometryChange() #qtCommand for update the scene
    for i in range(0, len(kernelCommand.value)):
        self.value[i]=self.revertToQTObject(kernelCommand.value[i])
    # Assing Command Values
    index=kernelCommand.valueIndex
    try:
        raise kernelCommand.exception[index](None)
    except(ExcPoint):
        self.value[index]=self.revertToQTObject(position)
    except(ExcLenght, ExcInt):
        if not distance or distance !=None:
            self.value[index]=distance
    except(ExcAngle):
        p1=GeoPoint(0.0, 0.0)
        p2=GeoPoint(position.x, position.y)
        ang=Vector(p1, p2).absAng
        print("previewAngle ",ang)
        self.value[index]=ang
    except:
        print("updatePreview: Exception not managed")
        return
</t>
<t tx="1.20130426141258.4121">def paint(self, painter,option,widget):
    """
        overloading of the paint method
    """
    if self.showShape:
        r, g, b= PYTHONCAD_COLOR["cyan"]
        painter.setPen(QtGui.QPen(QtGui.QColor.fromRgb(r, g, b)))
        painter.drawPath(self.shape())

    if self.showBBox:
        r, g, b= PYTHONCAD_COLOR["darkblue"]
        painter.setPen(QtGui.QPen(QtGui.QColor.fromRgb(r, g, b)))
        painter.drawRect(self.boundingRect())

    self.drawGeometry(painter,option,widget)
    return
</t>
<t tx="1.20130426141258.4122">def convertToQTObject(self, value):
    """
        convert the input value in a proper value
    """
    if isinstance(value, (float, int)):
        return value
    elif isinstance(value, tuple):
        return QtCore.QPointF(value[0], value[1])
    elif isinstance(value, GeoPoint):
        return QtCore.QPointF(value.x, value.y)
    else:
        return value
</t>
<t tx="1.20130426141258.4123">def revertToQTObject(self, value):
    """
        convert the input value in a proper value GeoObject -&gt; qtObject
    """
    if isinstance(value, (float, int)):
        return value
    elif isinstance(value, tuple):
        return QtCore.QPointF(value[0], value[1]*-1.0)
    elif isinstance(value, GeoPoint):
        return QtCore.QPointF(value.x, value.y*-1.0)
    else:
        return value
</t>
<t tx="1.20130426141258.4124">def shape(self):
    """
        overloading of the shape method
    """
    PainterPath=QtGui.QPainterPath()
    self.drawShape(PainterPath)
    painterStrock=QtGui.QPainterPathStroker()
    painterStrock.setWidth(10)
    painterStrockPath=painterStrock.createStroke(PainterPath)
    return painterStrockPath
</t>
<t tx="1.20130426141258.4125">def drawShape(self, path):
    pass
</t>
<t tx="1.20130426141258.4126">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    return self.shape().boundingRect()
</t>
<t tx="1.20130426141258.4127">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# EllipsePreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4128">import math

from Interface.Preview.base         import *
</t>
<t tx="1.20130426141258.4129">class QtEllipseItem(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4130">def __init__(self, command):
    super(QtEllipseItem, self).__init__(command)
    # get the geometry
</t>
<t tx="1.20130426141258.4131">def drawGeometry(self, painter,option,widget):
    """
        overloading of the paint method
    """
    if self.center:
        xc=self.center.x()
        yc=self.center.y()
        painter.drawEllipse(xc-(self.major/2.0),yc-(self.minor/2.0),self.major ,self.minor)
</t>
<t tx="1.20130426141258.4132">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    if self.center:
        xc=self.center.x()
        yc=self.center.y()
        painterPath.drawEllipse(xc-(self.major/2.0),yc-(self.minor/2.0),self.major ,self.minor)
</t>
<t tx="1.20130426141258.4133">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    if self.center:
        xc=self.center.x()
        yc=self.center.y()
        return QtCore.QRectF(xc-(self.major/2.0),yc- (self.minor/2.0) ,self.major ,self.minor )
    return QtCore.QRectF(0,0 ,0.1,0.1)
</t>
<t tx="1.20130426141258.4134">@property
def center(self):
    return self.value[0]
</t>
<t tx="1.20130426141258.4135">@center.setter
def center(self, value):
    self.value[0]=value
    self.update(self.boundingRect())
</t>
<t tx="1.20130426141258.4136">@property
def major(self):
    return self.value[1]
</t>
<t tx="1.20130426141258.4137">@major.setter
def major(self, value):
    self.value[1] =value
    self.update(self.boundingRect())
</t>
<t tx="1.20130426141258.4138">@property
def minor(self):
    return self.value[2]
</t>
<t tx="1.20130426141258.4139">@minor.setter
def minor(self, value):
    self.value[2]=value
    self.update(self.boundingRect())
</t>
<t tx="1.20130426141258.4140">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This module provide a factory for the preview objects
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4141">from Kernel.Command.pointcommand        import PointCommand
from Kernel.Command.segmentcommand      import SegmentCommand
from Kernel.Command.arccommand          import ArcCommand
from Kernel.Command.circlecommand       import CircleCommand
from Kernel.Command.rectanglecommand    import RectangleCommand
from Kernel.Command.ellipsecommand      import EllipseCommand
from Kernel.Command.polylinecommand     import PolylineCommand
from Kernel.Command.polygoncommand      import PolygonCommand

from Interface.Preview.point        import PreviewPoint
from Interface.Preview.segment      import PreviewSegment
from Interface.Preview.arc          import PreviewArc
</t>
<t tx="1.20130426141258.4142">#from Interface.Preview.rectangle    import QtRectangleItem
#from Interface.Preview.ellipse      import QtEllipseItem
#from Interface.Preview.polyline     import QtPolylineItem
#from Interface.Preview.polygon      import QtPolygonItem

def getPreviewObject(command):
    if isinstance(command , PointCommand):
        return PreviewPoint(command)
    if isinstance(command , SegmentCommand):
        return PreviewSegment(command)
    elif isinstance(command , (ArcCommand,CircleCommand)):
        return PreviewArc(command)
#    elif isinstance(command , RectangleCommand):
#        return QtRectangleItem(command)
#    elif isinstance(command , EllipseCommand):
#        return QtEllipseItem(command)
#    elif isinstance(command , PolylineCommand):
#        return QtPolylineItem(command)
#    elif isinstance(command ,  PolygonCommand):
#        return QtPolygonItem(command)
    else:
        return None
</t>
<t tx="1.20130426141258.4143">#
# Copyright (c) ,2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# qt pythoncad Point class
#



@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4144">import math
#
from Interface.Preview.base         import *
from Kernel.GeoEntity.segment       import Segment as geoSegment
from Kernel.initsetting             import PYTHONCAD_PREVIEW_COLOR
#
from PyQt5 import QtCore
</t>
<t tx="1.20130426141258.4145">class PreviewPoint(PreviewBase):
    """
        this class define the arcQT object
    """
    @others
</t>
<t tx="1.20130426141258.4146">def __init__(self, command):

    super(PreviewPoint, self).__init__(command)
</t>
<t tx="1.20130426141258.4147">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    if len(self.value)&lt;0:
        return
    qtPoinfF = self.value[0]
    painterPath.addRect(QtCore.QRectF(qtPoinfF.x()-self.shapeSize/2,qtPoinfF.y()-self.shapeSize/2 ,self.shapeSize ,self.shapeSize))
</t>
<t tx="1.20130426141258.4148">def drawGeometry(self, painter, option, widget):
    """
        overloading of the paint method
    """
    if len(self.value)&lt;0:
        return
    qtPoinfF = self.value[0]
    painter.drawRect(QtCore.QRectF(qtPoinfF.x()-self.shapeSize/2,qtPoinfF.y()-self.shapeSize/2 ,self.shapeSize ,self.shapeSize))
    painter.drawPoint(qtPoinfF)
</t>
<t tx="1.20130426141258.4149">def boundingRect(self):
    if len(self.value)&lt;0:
        return QtCore.QRectF(0, 0, 0, 0)
    qtPoinfF = self.value[0]
    return QtCore.QRectF(qtPoinfF.x()-self.shapeSize/2,qtPoinfF.y()-self.shapeSize/2 ,self.shapeSize ,self.shapeSize)
</t>
<t tx="1.20130426141258.4150">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# SegmentPreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4151">import math

from Interface.Preview.base         import *
from Kernel.GeoUtil.geolib          import Vector
from Kernel.GeoEntity.point         import Point
</t>
<t tx="1.20130426141258.4152">class QtPolygonItem(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4153">def __init__(self, command):
    super(QtPolygonItem, self).__init__(command)
    self.command=command
    # get the geometry
</t>
<t tx="1.20130426141258.4154">@property
def polygonPoint(self):
    """
        get the poligon points
    """
    if self.side&lt;=0:
        self.side=6
    deltaAngle=(math.pi*2)/self.side
    cPoint=Point(self.center.x(), self.center.y())
    vPoint=Point(self.vertex.x(), self.vertex.y())
    vertexVector=Vector(cPoint, vPoint)
    radius=vertexVector.norm
    angle=vertexVector.absAng
    pol=QtGui.QPolygonF()
    pFirst=None
    for i in range(0, int(self.side)):
        angle=deltaAngle+angle
        xsP=cPoint.x+radius*math.cos(angle)*-1.0
        ysP=cPoint.y+radius*math.sin(angle)*-1.0
        p=QtCore.QPointF(xsP,ysP)
        pol.append(p)
        if not pFirst:
            pFirst=p
    if pFirst:        
        pol.append(pFirst)
    return pol
</t>
<t tx="1.20130426141258.4155">def drawGeometry(self, painter,option,widget):
    """
        overloading of the paint method
    """
    if self.center and self.vertex:
        painter.drawPolyline(self.polygonPoint)
</t>
<t tx="1.20130426141258.4156">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    if self.center and self.vertex:
        painter.drawPolyline(self.polygonPoint)
</t>
<t tx="1.20130426141258.4157">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    if self.center and self.vertex:
        return self.polygonPoint.boundingRect() 
    return QtCore.QRectF(0,0 ,0.1,0.1)
</t>
<t tx="1.20130426141258.4158">@property
def center(self):
    return self.value[0]
</t>
<t tx="1.20130426141258.4159">@center.setter
def center(self, value):
    self.value[0]=value
    self.update(self.boundingRect())
</t>
<t tx="1.20130426141258.4160">@property
def vertex(self):    
    return self.value[1]
</t>
<t tx="1.20130426141258.4161">@vertex.setter
def vertex(self, value):
    self.value[1]=value
    self.update(self.boundingRect())
</t>
<t tx="1.20130426141258.4162">@property
def side(self):
    return self.value[2]
</t>
<t tx="1.20130426141258.4163">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# SegmentPreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4164">import math

from Interface.Preview.base         import *
</t>
<t tx="1.20130426141258.4165">class QtPolylineItem(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4166">def __init__(self, command):
    super(QtPolylineItem, self).__init__(command)
</t>
<t tx="1.20130426141258.4167">def drawShape(self, painterPath):    
    """
        overloading of the shape method 
    """
    first=True
    for p in self.value:
        if p and first:
            painterPath.moveTo(p)
            first=false
        elif p:
            painterPath.lineTo(p)    
</t>
<t tx="1.20130426141258.4168">def boundingRect(self):
    """
        overloading of the qt bounding rectangle
    """
    X=[p.x() for p in self.value if p]
    Y=[p.y() for p in self.value if p]
    if X and Y:
        xmax=max(X)
        ymax=max(Y)
        xmin=min(X)
        ymin=min(Y)
        h=abs(xmin-xmax)
        w=abs(ymin-ymax)
        return QtCore.QRectF(xmin,ymin,h ,w)
    return QtCore.QRectF(0,0 ,0.1,0.1)
</t>
<t tx="1.20130426141258.4169">def drawGeometry(self, painter, option, widget):
    """
        overloading of the paint method
    """
    #Create polyline Object
    pol=QtGui.QPolygonF()
    points=[p for p in self.value if p]
    #points.reverse()
    for p in points:
        pol.append(p)
    if len(points)&gt;1:
        painter.drawPolyline(pol)
    
    #painter.drawRect(self.boundingRect())
</t>
<t tx="1.20130426141258.4170">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# SegmentPreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4171">import math

from Interface.Preview.base         import *
from Kernel.GeoEntity.segment       import Segment as geoSegment
</t>
<t tx="1.20130426141258.4172">class QtRectangleItem(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4173">def __init__(self,command):
    super(QtRectangleItem, self).__init__(command)
</t>
<t tx="1.20130426141258.4174">def drawGeometry(self, painter,option,widget):
    """
        Overloading of the paint method
    """
    if self.value[0]!=None and self.value[1]!=None:
        painter.drawRect(self.getRectangle())
</t>
<t tx="1.20130426141258.4175">def boundingRect(self):
    """
        Overloading of the qt bounding rectangle
    """
    if self.value[0]!=None and self.value[1]!=None :
        return self.getRectangle()
    return QtCore.QRectF(0.0,0.0 ,0.1,0.1)
</t>
<t tx="1.20130426141258.4176">def getRectangle(self):
    """
        Create the rectangle
    """
    x=min(self.value[0].x(), self.value[1].x())
    y=min(self.value[0].y(), self.value[1].y())
    d1=abs(self.value[0].x()-self.value[1].x())
    d2=abs(self.value[0].y()-self.value[1].y())
    return QtCore.QRectF(x,y ,d1,d2)
</t>
<t tx="1.20130426141258.4177">@first #!/usr/bin/env python

#
# Copyright (c) 2010 Matteo Boscolo
#
# This file is part of PythonCAD.
#
# PythonCAD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# PythonCAD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public Licensesegmentcmd.py
# along with PythonCAD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# SegmentPreview object
#




@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="1.20130426141258.4178">from Interface.Preview.base         import PreviewBase
from Interface.Entity.segment       import Segment 
</t>
<t tx="1.20130426141258.4179">#

class PreviewSegment(PreviewBase):
    @others
</t>
<t tx="1.20130426141258.4180">def __init__(self,command):
    super(PreviewSegment, self).__init__(command)
</t>
<t tx="1.20130426141258.4181">@property
def canDraw(self):
    if self.value[0]!=None and self.value[1]!=None:
        self.x=self.value[0].x()
        self.y=self.value[0].y()
        self.x1=self.value[1].x()
        self.y1=self.value[1].y()
        return True
    return False
</t>
<t tx="1.20130426141258.4182">def drawGeometry(self, painter,option,widget):
    """
        Overloading of the paint method
    """
    if self.canDraw:
        Segment.__dict__['drawGeometry'](self,painter,option,widget)
</t>
<t tx="1.20130426141258.4183">def drawShape(self, painterPath):
    """
        overloading of the shape method
    """
    if self.canDraw:
        Segment.__dict__['drawShape'](self,painterPath)
</t>
<t tx="1.20130426141258.4184"></t>
<t tx="amd_yen.20130426011410.8908"></t>
<t tx="amd_yen.20130426011410.8909">#!/usr/bin/env python
#
# 來源: https://code.google.com/p/pyeuclid/
# euclid graphics maths module
#
# Copyright (c) 2006 Alex Holkner
# Alex.Holkner@mail.google.com
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 2.1 of the License, or (at your
# option) any later version.
# 
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
# for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

'''euclid graphics maths module

Documentation and tests are included in the file "euclid.txt", or online
at http://code.google.com/p/pyeuclid
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id$'
__revision__ = '$Revision$'

import math
import operator
import types

# Some magic here.  If _use_slots is True, the classes will derive from
# object and will define a __slots__ class variable.  If _use_slots is
# False, classes will be old-style and will not define __slots__.
#
# _use_slots = True:   Memory efficient, probably faster in future versions
#                      of Python, "better".
# _use_slots = False:  Ordinary classes, much faster than slots in current
#                      versions of Python (2.4 and 2.5).
_use_slots = True

# If True, allows components of Vector2 and Vector3 to be set via swizzling;
# e.g.  v.xyz = (1, 2, 3).  This is much, much slower than the more verbose
# v.x = 1; v.y = 2; v.z = 3,  and slows down ordinary element setting as
# well.  Recommended setting is False.
_enable_swizzle_set = False

# Requires class to derive from object.
if _enable_swizzle_set:
    _use_slots = True

# Implement _use_slots magic.
class _EuclidMetaclass(type):
    def __new__(cls, name, bases, dct):
        if '__slots__' in dct:
            dct['__getstate__'] = cls._create_getstate(dct['__slots__'])
            dct['__setstate__'] = cls._create_setstate(dct['__slots__'])
        if _use_slots:
            return type.__new__(cls, name, bases + (object,), dct)
        else:
            if '__slots__' in dct:
                del dct['__slots__']
            return types.ClassType.__new__(types.ClassType, name, bases, dct)

    @classmethod
    def _create_getstate(cls, slots):
        def __getstate__(self):
            d = {}
            for slot in slots:
                d[slot] = getattr(self, slot)
            return d
        return __getstate__

    @classmethod
    def _create_setstate(cls, slots):
        def __setstate__(self, state):
            for name, value in state.items():
                setattr(self, name, value)
        return __setstate__

__metaclass__ = _EuclidMetaclass

class Vector2:
    __slots__ = ['x', 'y']
    __hash__ = None

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __copy__(self):
        return self.__class__(self.x, self.y)

    copy = __copy__

    def __repr__(self):
        return 'Vector2(%.2f, %.2f)' % (self.x, self.y)

    def __eq__(self, other):
        if isinstance(other, Vector2):
            return self.x == other.x and \
                   self.y == other.y
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return self.x == other[0] and \
                   self.y == other[1]

    def __ne__(self, other):
        return not self.__eq__(other)

    def __nonzero__(self):
        return self.x != 0 or self.y != 0

    def __len__(self):
        return 2

    def __getitem__(self, key):
        return (self.x, self.y)[key]

    def __setitem__(self, key, value):
        l = [self.x, self.y]
        l[key] = value
        self.x, self.y = l

    def __iter__(self):
        return iter((self.x, self.y))

    def __getattr__(self, name):
        try:
            return tuple([(self.x, self.y)['xy'.index(c)] \
                          for c in name])
        except ValueError:
            raise AttributeError, name

    if _enable_swizzle_set:
        # This has detrimental performance on ordinary setattr as well
        # if enabled
        def __setattr__(self, name, value):
            if len(name) == 1:
                object.__setattr__(self, name, value)
            else:
                try:
                    l = [self.x, self.y]
                    for c, v in map(None, name, value):
                        l['xy'.index(c)] = v
                    self.x, self.y = l
                except ValueError:
                    raise AttributeError, name

    def __add__(self, other):
        if isinstance(other, Vector2):
            # Vector + Vector -&gt; Vector
            # Vector + Point -&gt; Point
            # Point + Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector2
            else:
                _class = Point2
            return _class(self.x + other.x,
                          self.y + other.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(self.x + other[0],
                           self.y + other[1])
    __radd__ = __add__

    def __iadd__(self, other):
        if isinstance(other, Vector2):
            self.x += other.x
            self.y += other.y
        else:
            self.x += other[0]
            self.y += other[1]
        return self

    def __sub__(self, other):
        if isinstance(other, Vector2):
            # Vector - Vector -&gt; Vector
            # Vector - Point -&gt; Point
            # Point - Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector2
            else:
                _class = Point2
            return _class(self.x - other.x,
                          self.y - other.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(self.x - other[0],
                           self.y - other[1])

   
    def __rsub__(self, other):
        if isinstance(other, Vector2):
            return Vector2(other.x - self.x,
                           other.y - self.y)
        else:
            assert hasattr(other, '__len__') and len(other) == 2
            return Vector2(other.x - self[0],
                           other.y - self[1])

    def __mul__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(self.x * other,
                       self.y * other)

    __rmul__ = __mul__

    def __imul__(self, other):
        assert type(other) in (int, long, float)
        self.x *= other
        self.y *= other
        return self

    def __div__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.div(self.x, other),
                       operator.div(self.y, other))


    def __rdiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.div(other, self.x),
                       operator.div(other, self.y))

    def __floordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.floordiv(self.x, other),
                       operator.floordiv(self.y, other))


    def __rfloordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.floordiv(other, self.x),
                       operator.floordiv(other, self.y))

    def __truediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.truediv(self.x, other),
                       operator.truediv(self.y, other))


    def __rtruediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector2(operator.truediv(other, self.x),
                       operator.truediv(other, self.y))
    
    def __neg__(self):
        return Vector2(-self.x,
                        -self.y)

    __pos__ = __copy__
    
    def __abs__(self):
        return math.sqrt(self.x ** 2 + \
                         self.y ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.x ** 2 + \
               self.y ** 2

    def normalize(self):
        d = self.magnitude()
        if d:
            self.x /= d
            self.y /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d:
            return Vector2(self.x / d, 
                           self.y / d)
        return self.copy()

    def dot(self, other):
        assert isinstance(other, Vector2)
        return self.x * other.x + \
               self.y * other.y

    def cross(self):
        return Vector2(self.y, -self.x)

    def reflect(self, normal):
        # assume normal is normalized
        assert isinstance(normal, Vector2)
        d = 2 * (self.x * normal.x + self.y * normal.y)
        return Vector2(self.x - d * normal.x,
                       self.y - d * normal.y)

    def angle(self, other):
        """Return the angle to the vector other"""
        return math.acos(self.dot(other) / (self.magnitude()*other.magnitude()))

    def project(self, other):
        """Return one vector projected on the vector other"""
        n = other.normalized()
        return self.dot(n)*n

class Vector3:
    __slots__ = ['x', 'y', 'z']
    __hash__ = None

    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z

    def __copy__(self):
        return self.__class__(self.x, self.y, self.z)

    copy = __copy__

    def __repr__(self):
        return 'Vector3(%.2f, %.2f, %.2f)' % (self.x,
                                              self.y,
                                              self.z)

    def __eq__(self, other):
        if isinstance(other, Vector3):
            return self.x == other.x and \
                   self.y == other.y and \
                   self.z == other.z
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return self.x == other[0] and \
                   self.y == other[1] and \
                   self.z == other[2]

    def __ne__(self, other):
        return not self.__eq__(other)

    def __nonzero__(self):
        return self.x != 0 or self.y != 0 or self.z != 0

    def __len__(self):
        return 3

    def __getitem__(self, key):
        return (self.x, self.y, self.z)[key]

    def __setitem__(self, key, value):
        l = [self.x, self.y, self.z]
        l[key] = value
        self.x, self.y, self.z = l

    def __iter__(self):
        return iter((self.x, self.y, self.z))

    def __getattr__(self, name):
        try:
            return tuple([(self.x, self.y, self.z)['xyz'.index(c)] \
                          for c in name])
        except ValueError:
            raise AttributeError, name

    if _enable_swizzle_set:
        # This has detrimental performance on ordinary setattr as well
        # if enabled
        def __setattr__(self, name, value):
            if len(name) == 1:
                object.__setattr__(self, name, value)
            else:
                try:
                    l = [self.x, self.y, self.z]
                    for c, v in map(None, name, value):
                        l['xyz'.index(c)] = v
                    self.x, self.y, self.z = l
                except ValueError:
                    raise AttributeError, name


    def __add__(self, other):
        if isinstance(other, Vector3):
            # Vector + Vector -&gt; Vector
            # Vector + Point -&gt; Point
            # Point + Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector3
            else:
                _class = Point3
            return _class(self.x + other.x,
                          self.y + other.y,
                          self.z + other.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(self.x + other[0],
                           self.y + other[1],
                           self.z + other[2])
    __radd__ = __add__

    def __iadd__(self, other):
        if isinstance(other, Vector3):
            self.x += other.x
            self.y += other.y
            self.z += other.z
        else:
            self.x += other[0]
            self.y += other[1]
            self.z += other[2]
        return self

    def __sub__(self, other):
        if isinstance(other, Vector3):
            # Vector - Vector -&gt; Vector
            # Vector - Point -&gt; Point
            # Point - Point -&gt; Vector
            if self.__class__ is other.__class__:
                _class = Vector3
            else:
                _class = Point3
            return Vector3(self.x - other.x,
                           self.y - other.y,
                           self.z - other.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(self.x - other[0],
                           self.y - other[1],
                           self.z - other[2])

   
    def __rsub__(self, other):
        if isinstance(other, Vector3):
            return Vector3(other.x - self.x,
                           other.y - self.y,
                           other.z - self.z)
        else:
            assert hasattr(other, '__len__') and len(other) == 3
            return Vector3(other.x - self[0],
                           other.y - self[1],
                           other.z - self[2])

    def __mul__(self, other):
        if isinstance(other, Vector3):
            # TODO component-wise mul/div in-place and on Vector2; docs.
            if self.__class__ is Point3 or other.__class__ is Point3:
                _class = Point3
            else:
                _class = Vector3
            return _class(self.x * other.x,
                          self.y * other.y,
                          self.z * other.z)
        else: 
            assert type(other) in (int, long, float)
            return Vector3(self.x * other,
                           self.y * other,
                           self.z * other)

    __rmul__ = __mul__

    def __imul__(self, other):
        assert type(other) in (int, long, float)
        self.x *= other
        self.y *= other
        self.z *= other
        return self

    def __div__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.div(self.x, other),
                       operator.div(self.y, other),
                       operator.div(self.z, other))


    def __rdiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.div(other, self.x),
                       operator.div(other, self.y),
                       operator.div(other, self.z))

    def __floordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.floordiv(self.x, other),
                       operator.floordiv(self.y, other),
                       operator.floordiv(self.z, other))


    def __rfloordiv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.floordiv(other, self.x),
                       operator.floordiv(other, self.y),
                       operator.floordiv(other, self.z))

    def __truediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.truediv(self.x, other),
                       operator.truediv(self.y, other),
                       operator.truediv(self.z, other))


    def __rtruediv__(self, other):
        assert type(other) in (int, long, float)
        return Vector3(operator.truediv(other, self.x),
                       operator.truediv(other, self.y),
                       operator.truediv(other, self.z))
    
    def __neg__(self):
        return Vector3(-self.x,
                        -self.y,
                        -self.z)

    __pos__ = __copy__
    
    def __abs__(self):
        return math.sqrt(self.x ** 2 + \
                         self.y ** 2 + \
                         self.z ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.x ** 2 + \
               self.y ** 2 + \
               self.z ** 2

    def normalize(self):
        d = self.magnitude()
        if d:
            self.x /= d
            self.y /= d
            self.z /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d:
            return Vector3(self.x / d, 
                           self.y / d, 
                           self.z / d)
        return self.copy()

    def dot(self, other):
        assert isinstance(other, Vector3)
        return self.x * other.x + \
               self.y * other.y + \
               self.z * other.z

    def cross(self, other):
        assert isinstance(other, Vector3)
        return Vector3(self.y * other.z - self.z * other.y,
                       -self.x * other.z + self.z * other.x,
                       self.x * other.y - self.y * other.x)

    def reflect(self, normal):
        # assume normal is normalized
        assert isinstance(normal, Vector3)
        d = 2 * (self.x * normal.x + self.y * normal.y + self.z * normal.z)
        return Vector3(self.x - d * normal.x,
                       self.y - d * normal.y,
                       self.z - d * normal.z)

    def rotate_around(self, axis, theta):
        """Return the vector rotated around axis through angle theta. Right hand rule applies"""

        # Adapted from equations published by Glenn Murray.
        # http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
        x, y, z = self.x, self.y,self.z
        u, v, w = axis.x, axis.y, axis.z

        # Extracted common factors for simplicity and efficiency
        r2 = u**2 + v**2 + w**2
        r = math.sqrt(r2)
        ct = math.cos(theta)
        st = math.sin(theta) / r
        dt = (u*x + v*y + w*z) * (1 - ct) / r2
        return Vector3((u * dt + x * ct + (-w * y + v * z) * st),
                       (v * dt + y * ct + ( w * x - u * z) * st),
                       (w * dt + z * ct + (-v * x + u * y) * st))

    def angle(self, other):
        """Return the angle to the vector other"""
        return math.acos(self.dot(other) / (self.magnitude()*other.magnitude()))

    def project(self, other):
        """Return one vector projected on the vector other"""
        n = other.normalized()
        return self.dot(n)*n

# a b c 
# e f g 
# i j k 

class Matrix3:
    __slots__ = list('abcefgijk')

    def __init__(self):
        self.identity()

    def __copy__(self):
        M = Matrix3()
        M.a = self.a
        M.b = self.b
        M.c = self.c
        M.e = self.e 
        M.f = self.f
        M.g = self.g
        M.i = self.i
        M.j = self.j
        M.k = self.k
        return M

    copy = __copy__
    def __repr__(self):
        return ('Matrix3([% 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f])') \
                % (self.a, self.b, self.c,
                   self.e, self.f, self.g,
                   self.i, self.j, self.k)

    def __getitem__(self, key):
        return [self.a, self.e, self.i,
                self.b, self.f, self.j,
                self.c, self.g, self.k][key]

    def __setitem__(self, key, value):
        L = self[:]
        L[key] = value
        (self.a, self.e, self.i,
         self.b, self.f, self.j,
         self.c, self.g, self.k) = L

    def __mul__(self, other):
        if isinstance(other, Matrix3):
            # Caching repeatedly accessed attributes in local variables
            # apparently increases performance by 20%.  Attrib: Will McGugan.
            Aa = self.a
            Ab = self.b
            Ac = self.c
            Ae = self.e
            Af = self.f
            Ag = self.g
            Ai = self.i
            Aj = self.j
            Ak = self.k
            Ba = other.a
            Bb = other.b
            Bc = other.c
            Be = other.e
            Bf = other.f
            Bg = other.g
            Bi = other.i
            Bj = other.j
            Bk = other.k
            C = Matrix3()
            C.a = Aa * Ba + Ab * Be + Ac * Bi
            C.b = Aa * Bb + Ab * Bf + Ac * Bj
            C.c = Aa * Bc + Ab * Bg + Ac * Bk
            C.e = Ae * Ba + Af * Be + Ag * Bi
            C.f = Ae * Bb + Af * Bf + Ag * Bj
            C.g = Ae * Bc + Af * Bg + Ag * Bk
            C.i = Ai * Ba + Aj * Be + Ak * Bi
            C.j = Ai * Bb + Aj * Bf + Ak * Bj
            C.k = Ai * Bc + Aj * Bg + Ak * Bk
            return C
        elif isinstance(other, Point2):
            A = self
            B = other
            P = Point2(0, 0)
            P.x = A.a * B.x + A.b * B.y + A.c
            P.y = A.e * B.x + A.f * B.y + A.g
            return P
        elif isinstance(other, Vector2):
            A = self
            B = other
            V = Vector2(0, 0)
            V.x = A.a * B.x + A.b * B.y 
            V.y = A.e * B.x + A.f * B.y 
            return V
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Matrix3)
        # Cache attributes in local vars (see Matrix3.__mul__).
        Aa = self.a
        Ab = self.b
        Ac = self.c
        Ae = self.e
        Af = self.f
        Ag = self.g
        Ai = self.i
        Aj = self.j
        Ak = self.k
        Ba = other.a
        Bb = other.b
        Bc = other.c
        Be = other.e
        Bf = other.f
        Bg = other.g
        Bi = other.i
        Bj = other.j
        Bk = other.k
        self.a = Aa * Ba + Ab * Be + Ac * Bi
        self.b = Aa * Bb + Ab * Bf + Ac * Bj
        self.c = Aa * Bc + Ab * Bg + Ac * Bk
        self.e = Ae * Ba + Af * Be + Ag * Bi
        self.f = Ae * Bb + Af * Bf + Ag * Bj
        self.g = Ae * Bc + Af * Bg + Ag * Bk
        self.i = Ai * Ba + Aj * Be + Ak * Bi
        self.j = Ai * Bb + Aj * Bf + Ak * Bj
        self.k = Ai * Bc + Aj * Bg + Ak * Bk
        return self

    def identity(self):
        self.a = self.f = self.k = 1.
        self.b = self.c = self.e = self.g = self.i = self.j = 0
        return self

    def scale(self, x, y):
        self *= Matrix3.new_scale(x, y)
        return self

    def translate(self, x, y):
        self *= Matrix3.new_translate(x, y)
        return self 

    def rotate(self, angle):
        self *= Matrix3.new_rotate(angle)
        return self

    # Static constructors
    def new_identity(cls):
        self = cls()
        return self
    new_identity = classmethod(new_identity)

    def new_scale(cls, x, y):
        self = cls()
        self.a = x
        self.f = y
        return self
    new_scale = classmethod(new_scale)

    def new_translate(cls, x, y):
        self = cls()
        self.c = x
        self.g = y
        return self
    new_translate = classmethod(new_translate)

    def new_rotate(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.f = c
        self.b = -s
        self.e = s
        return self
    new_rotate = classmethod(new_rotate)

    def determinant(self):
        return (self.a*self.f*self.k 
                + self.b*self.g*self.i 
                + self.c*self.e*self.j 
                - self.a*self.g*self.j 
                - self.b*self.e*self.k 
                - self.c*self.f*self.i)

    def inverse(self):
        tmp = Matrix3()
        d = self.determinant()

        if abs(d) &lt; 0.001:
            # No inverse, return identity
            return tmp
        else:
            d = 1.0 / d

            tmp.a = d * (self.f*self.k - self.g*self.j)
            tmp.b = d * (self.c*self.j - self.b*self.k)
            tmp.c = d * (self.b*self.g - self.c*self.f)
            tmp.e = d * (self.g*self.i - self.e*self.k)
            tmp.f = d * (self.a*self.k - self.c*self.i)
            tmp.g = d * (self.c*self.e - self.a*self.g)
            tmp.i = d * (self.e*self.j - self.f*self.i)
            tmp.j = d * (self.b*self.i - self.a*self.j)
            tmp.k = d * (self.a*self.f - self.b*self.e)

            return tmp

# a b c d
# e f g h
# i j k l
# m n o p

class Matrix4:
    __slots__ = list('abcdefghijklmnop')

    def __init__(self):
        self.identity()

    def __copy__(self):
        M = Matrix4()
        M.a = self.a
        M.b = self.b
        M.c = self.c
        M.d = self.d
        M.e = self.e 
        M.f = self.f
        M.g = self.g
        M.h = self.h
        M.i = self.i
        M.j = self.j
        M.k = self.k
        M.l = self.l
        M.m = self.m
        M.n = self.n
        M.o = self.o
        M.p = self.p
        return M

    copy = __copy__


    def __repr__(self):
        return ('Matrix4([% 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
                '         % 8.2f % 8.2f % 8.2f % 8.2f])') \
                % (self.a, self.b, self.c, self.d,
                   self.e, self.f, self.g, self.h,
                   self.i, self.j, self.k, self.l,
                   self.m, self.n, self.o, self.p)

    def __getitem__(self, key):
        return [self.a, self.e, self.i, self.m,
                self.b, self.f, self.j, self.n,
                self.c, self.g, self.k, self.o,
                self.d, self.h, self.l, self.p][key]

    def __setitem__(self, key, value):
        L = self[:]
        L[key] = value
        (self.a, self.e, self.i, self.m,
         self.b, self.f, self.j, self.n,
         self.c, self.g, self.k, self.o,
         self.d, self.h, self.l, self.p) = L

    def __mul__(self, other):
        if isinstance(other, Matrix4):
            # Cache attributes in local vars (see Matrix3.__mul__).
            Aa = self.a
            Ab = self.b
            Ac = self.c
            Ad = self.d
            Ae = self.e
            Af = self.f
            Ag = self.g
            Ah = self.h
            Ai = self.i
            Aj = self.j
            Ak = self.k
            Al = self.l
            Am = self.m
            An = self.n
            Ao = self.o
            Ap = self.p
            Ba = other.a
            Bb = other.b
            Bc = other.c
            Bd = other.d
            Be = other.e
            Bf = other.f
            Bg = other.g
            Bh = other.h
            Bi = other.i
            Bj = other.j
            Bk = other.k
            Bl = other.l
            Bm = other.m
            Bn = other.n
            Bo = other.o
            Bp = other.p
            C = Matrix4()
            C.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
            C.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
            C.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
            C.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
            C.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
            C.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
            C.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
            C.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
            C.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
            C.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
            C.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
            C.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
            C.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
            C.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
            C.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
            C.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
            return C
        elif isinstance(other, Point3):
            A = self
            B = other
            P = Point3(0, 0, 0)
            P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
            P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
            P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
            return P
        elif isinstance(other, Vector3):
            A = self
            B = other
            V = Vector3(0, 0, 0)
            V.x = A.a * B.x + A.b * B.y + A.c * B.z
            V.y = A.e * B.x + A.f * B.y + A.g * B.z
            V.z = A.i * B.x + A.j * B.y + A.k * B.z
            return V
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Matrix4)
        # Cache attributes in local vars (see Matrix3.__mul__).
        Aa = self.a
        Ab = self.b
        Ac = self.c
        Ad = self.d
        Ae = self.e
        Af = self.f
        Ag = self.g
        Ah = self.h
        Ai = self.i
        Aj = self.j
        Ak = self.k
        Al = self.l
        Am = self.m
        An = self.n
        Ao = self.o
        Ap = self.p
        Ba = other.a
        Bb = other.b
        Bc = other.c
        Bd = other.d
        Be = other.e
        Bf = other.f
        Bg = other.g
        Bh = other.h
        Bi = other.i
        Bj = other.j
        Bk = other.k
        Bl = other.l
        Bm = other.m
        Bn = other.n
        Bo = other.o
        Bp = other.p
        self.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
        self.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
        self.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
        self.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
        self.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
        self.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
        self.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
        self.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
        self.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
        self.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
        self.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
        self.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
        self.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
        self.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
        self.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
        self.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
        return self

    def transform(self, other):
        A = self
        B = other
        P = Point3(0, 0, 0)
        P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
        P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
        P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
        w =   A.m * B.x + A.n * B.y + A.o * B.z + A.p
        if w != 0:
            P.x /= w
            P.y /= w
            P.z /= w
        return P

    def identity(self):
        self.a = self.f = self.k = self.p = 1.
        self.b = self.c = self.d = self.e = self.g = self.h = \
        self.i = self.j = self.l = self.m = self.n = self.o = 0
        return self

    def scale(self, x, y, z):
        self *= Matrix4.new_scale(x, y, z)
        return self

    def translate(self, x, y, z):
        self *= Matrix4.new_translate(x, y, z)
        return self 

    def rotatex(self, angle):
        self *= Matrix4.new_rotatex(angle)
        return self

    def rotatey(self, angle):
        self *= Matrix4.new_rotatey(angle)
        return self

    def rotatez(self, angle):
        self *= Matrix4.new_rotatez(angle)
        return self

    def rotate_axis(self, angle, axis):
        self *= Matrix4.new_rotate_axis(angle, axis)
        return self

    def rotate_euler(self, heading, attitude, bank):
        self *= Matrix4.new_rotate_euler(heading, attitude, bank)
        return self

    def rotate_triple_axis(self, x, y, z):
        self *= Matrix4.new_rotate_triple_axis(x, y, z)
        return self

    def transpose(self):
        (self.a, self.e, self.i, self.m,
         self.b, self.f, self.j, self.n,
         self.c, self.g, self.k, self.o,
         self.d, self.h, self.l, self.p) = \
        (self.a, self.b, self.c, self.d,
         self.e, self.f, self.g, self.h,
         self.i, self.j, self.k, self.l,
         self.m, self.n, self.o, self.p)

    def transposed(self):
        M = self.copy()
        M.transpose()
        return M

    # Static constructors
    def new(cls, *values):
        M = cls()
        M[:] = values
        return M
    new = classmethod(new)

    def new_identity(cls):
        self = cls()
        return self
    new_identity = classmethod(new_identity)

    def new_scale(cls, x, y, z):
        self = cls()
        self.a = x
        self.f = y
        self.k = z
        return self
    new_scale = classmethod(new_scale)

    def new_translate(cls, x, y, z):
        self = cls()
        self.d = x
        self.h = y
        self.l = z
        return self
    new_translate = classmethod(new_translate)

    def new_rotatex(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.f = self.k = c
        self.g = -s
        self.j = s
        return self
    new_rotatex = classmethod(new_rotatex)

    def new_rotatey(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.k = c
        self.c = s
        self.i = -s
        return self    
    new_rotatey = classmethod(new_rotatey)
    
    def new_rotatez(cls, angle):
        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        self.a = self.f = c
        self.b = -s
        self.e = s
        return self
    new_rotatez = classmethod(new_rotatez)

    def new_rotate_axis(cls, angle, axis):
        assert(isinstance(axis, Vector3))
        vector = axis.normalized()
        x = vector.x
        y = vector.y
        z = vector.z

        self = cls()
        s = math.sin(angle)
        c = math.cos(angle)
        c1 = 1. - c
        
        # from the glRotate man page
        self.a = x * x * c1 + c
        self.b = x * y * c1 - z * s
        self.c = x * z * c1 + y * s
        self.e = y * x * c1 + z * s
        self.f = y * y * c1 + c
        self.g = y * z * c1 - x * s
        self.i = x * z * c1 - y * s
        self.j = y * z * c1 + x * s
        self.k = z * z * c1 + c
        return self
    new_rotate_axis = classmethod(new_rotate_axis)

    def new_rotate_euler(cls, heading, attitude, bank):
        # from http://www.euclideanspace.com/
        ch = math.cos(heading)
        sh = math.sin(heading)
        ca = math.cos(attitude)
        sa = math.sin(attitude)
        cb = math.cos(bank)
        sb = math.sin(bank)

        self = cls()
        self.a = ch * ca
        self.b = sh * sb - ch * sa * cb
        self.c = ch * sa * sb + sh * cb
        self.e = sa
        self.f = ca * cb
        self.g = -ca * sb
        self.i = -sh * ca
        self.j = sh * sa * cb + ch * sb
        self.k = -sh * sa * sb + ch * cb
        return self
    new_rotate_euler = classmethod(new_rotate_euler)

    def new_rotate_triple_axis(cls, x, y, z):
      m = cls()
      
      m.a, m.b, m.c = x.x, y.x, z.x
      m.e, m.f, m.g = x.y, y.y, z.y
      m.i, m.j, m.k = x.z, y.z, z.z
      
      return m
    new_rotate_triple_axis = classmethod(new_rotate_triple_axis)

    def new_look_at(cls, eye, at, up):
      z = (eye - at).normalized()
      x = up.cross(z).normalized()
      y = z.cross(x)
      
      m = cls.new_rotate_triple_axis(x, y, z)
      m.d, m.h, m.l = eye.x, eye.y, eye.z
      return m
    new_look_at = classmethod(new_look_at)
    
    def new_perspective(cls, fov_y, aspect, near, far):
        # from the gluPerspective man page
        f = 1 / math.tan(fov_y / 2)
        self = cls()
        assert near != 0.0 and near != far
        self.a = f / aspect
        self.f = f
        self.k = (far + near) / (near - far)
        self.l = 2 * far * near / (near - far)
        self.o = -1
        self.p = 0
        return self
    new_perspective = classmethod(new_perspective)

    def determinant(self):
        return ((self.a * self.f - self.e * self.b)
              * (self.k * self.p - self.o * self.l)
              - (self.a * self.j - self.i * self.b)
              * (self.g * self.p - self.o * self.h)
              + (self.a * self.n - self.m * self.b)
              * (self.g * self.l - self.k * self.h)
              + (self.e * self.j - self.i * self.f)
              * (self.c * self.p - self.o * self.d)
              - (self.e * self.n - self.m * self.f)
              * (self.c * self.l - self.k * self.d)
              + (self.i * self.n - self.m * self.j)
              * (self.c * self.h - self.g * self.d))

    def inverse(self):
        tmp = Matrix4()
        d = self.determinant();

        if abs(d) &lt; 0.001:
            # No inverse, return identity
            return tmp
        else:
            d = 1.0 / d;

            tmp.a = d * (self.f * (self.k * self.p - self.o * self.l) + self.j * (self.o * self.h - self.g * self.p) + self.n * (self.g * self.l - self.k * self.h));
            tmp.e = d * (self.g * (self.i * self.p - self.m * self.l) + self.k * (self.m * self.h - self.e * self.p) + self.o * (self.e * self.l - self.i * self.h));
            tmp.i = d * (self.h * (self.i * self.n - self.m * self.j) + self.l * (self.m * self.f - self.e * self.n) + self.p * (self.e * self.j - self.i * self.f));
            tmp.m = d * (self.e * (self.n * self.k - self.j * self.o) + self.i * (self.f * self.o - self.n * self.g) + self.m * (self.j * self.g - self.f * self.k));
            
            tmp.b = d * (self.j * (self.c * self.p - self.o * self.d) + self.n * (self.k * self.d - self.c * self.l) + self.b * (self.o * self.l - self.k * self.p));
            tmp.f = d * (self.k * (self.a * self.p - self.m * self.d) + self.o * (self.i * self.d - self.a * self.l) + self.c * (self.m * self.l - self.i * self.p));
            tmp.j = d * (self.l * (self.a * self.n - self.m * self.b) + self.p * (self.i * self.b - self.a * self.j) + self.d * (self.m * self.j - self.i * self.n));
            tmp.n = d * (self.i * (self.n * self.c - self.b * self.o) + self.m * (self.b * self.k - self.j * self.c) + self.a * (self.j * self.o - self.n * self.k));
            
            tmp.c = d * (self.n * (self.c * self.h - self.g * self.d) + self.b * (self.g * self.p - self.o * self.h) + self.f * (self.o * self.d - self.c * self.p));
            tmp.g = d * (self.o * (self.a * self.h - self.e * self.d) + self.c * (self.e * self.p - self.m * self.h) + self.g * (self.m * self.d - self.a * self.p));
            tmp.k = d * (self.p * (self.a * self.f - self.e * self.b) + self.d * (self.e * self.n - self.m * self.f) + self.h * (self.m * self.b - self.a * self.n));
            tmp.o = d * (self.m * (self.f * self.c - self.b * self.g) + self.a * (self.n * self.g - self.f * self.o) + self.e * (self.b * self.o - self.n * self.c));
            
            tmp.d = d * (self.b * (self.k * self.h - self.g * self.l) + self.f * (self.c * self.l - self.k * self.d) + self.j * (self.g * self.d - self.c * self.h));
            tmp.h = d * (self.c * (self.i * self.h - self.e * self.l) + self.g * (self.a * self.l - self.i * self.d) + self.k * (self.e * self.d - self.a * self.h));
            tmp.l = d * (self.d * (self.i * self.f - self.e * self.j) + self.h * (self.a * self.j - self.i * self.b) + self.l * (self.e * self.b - self.a * self.f));
            tmp.p = d * (self.a * (self.f * self.k - self.j * self.g) + self.e * (self.j * self.c - self.b * self.k) + self.i * (self.b * self.g - self.f * self.c));

        return tmp;
        

class Quaternion:
    # All methods and naming conventions based off 
    # http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions

    # w is the real part, (x, y, z) are the imaginary parts
    __slots__ = ['w', 'x', 'y', 'z']

    def __init__(self, w=1, x=0, y=0, z=0):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    def __copy__(self):
        Q = Quaternion()
        Q.w = self.w
        Q.x = self.x
        Q.y = self.y
        Q.z = self.z
        return Q

    copy = __copy__

    def __repr__(self):
        return 'Quaternion(real=%.2f, imag=&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.w, self.x, self.y, self.z)

    def __mul__(self, other):
        if isinstance(other, Quaternion):
            Ax = self.x
            Ay = self.y
            Az = self.z
            Aw = self.w
            Bx = other.x
            By = other.y
            Bz = other.z
            Bw = other.w
            Q = Quaternion()
            Q.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
            Q.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
            Q.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
            Q.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
            return Q
        elif isinstance(other, Vector3):
            w = self.w
            x = self.x
            y = self.y
            z = self.z
            Vx = other.x
            Vy = other.y
            Vz = other.z
            ww = w * w
            w2 = w * 2
            wx2 = w2 * x
            wy2 = w2 * y
            wz2 = w2 * z
            xx = x * x
            x2 = x * 2
            xy2 = x2 * y
            xz2 = x2 * z
            yy = y * y
            yz2 = 2 * y * z
            zz = z * z
            return other.__class__(\
               ww * Vx + wy2 * Vz - wz2 * Vy + \
               xx * Vx + xy2 * Vy + xz2 * Vz - \
               zz * Vx - yy * Vx,
               xy2 * Vx + yy * Vy + yz2 * Vz + \
               wz2 * Vx - zz * Vy + ww * Vy - \
               wx2 * Vz - xx * Vy,
               xz2 * Vx + yz2 * Vy + \
               zz * Vz - wy2 * Vx - yy * Vz + \
               wx2 * Vy - xx * Vz + ww * Vz)
        else:
            other = other.copy()
            other._apply_transform(self)
            return other

    def __imul__(self, other):
        assert isinstance(other, Quaternion)
        Ax = self.x
        Ay = self.y
        Az = self.z
        Aw = self.w
        Bx = other.x
        By = other.y
        Bz = other.z
        Bw = other.w
        self.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
        self.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
        self.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
        self.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
        return self

    def __abs__(self):
        return math.sqrt(self.w ** 2 + \
                         self.x ** 2 + \
                         self.y ** 2 + \
                         self.z ** 2)

    magnitude = __abs__

    def magnitude_squared(self):
        return self.w ** 2 + \
               self.x ** 2 + \
               self.y ** 2 + \
               self.z ** 2 

    def identity(self):
        self.w = 1
        self.x = 0
        self.y = 0
        self.z = 0
        return self

    def rotate_axis(self, angle, axis):
        self *= Quaternion.new_rotate_axis(angle, axis)
        return self

    def rotate_euler(self, heading, attitude, bank):
        self *= Quaternion.new_rotate_euler(heading, attitude, bank)
        return self

    def rotate_matrix(self, m):
        self *= Quaternion.new_rotate_matrix(m)
        return self

    def conjugated(self):
        Q = Quaternion()
        Q.w = self.w
        Q.x = -self.x
        Q.y = -self.y
        Q.z = -self.z
        return Q

    def normalize(self):
        d = self.magnitude()
        if d != 0:
            self.w /= d
            self.x /= d
            self.y /= d
            self.z /= d
        return self

    def normalized(self):
        d = self.magnitude()
        if d != 0:
            Q = Quaternion()
            Q.w = self.w / d
            Q.x = self.x / d
            Q.y = self.y / d
            Q.z = self.z / d
            return Q
        else:
            return self.copy()

    def get_angle_axis(self):
        if self.w &gt; 1:
            self = self.normalized()
        angle = 2 * math.acos(self.w)
        s = math.sqrt(1 - self.w ** 2)
        if s &lt; 0.001:
            return angle, Vector3(1, 0, 0)
        else:
            return angle, Vector3(self.x / s, self.y / s, self.z / s)

    def get_euler(self):
        t = self.x * self.y + self.z * self.w
        if t &gt; 0.4999:
            heading = 2 * math.atan2(self.x, self.w)
            attitude = math.pi / 2
            bank = 0
        elif t &lt; -0.4999:
            heading = -2 * math.atan2(self.x, self.w)
            attitude = -math.pi / 2
            bank = 0
        else:
            sqx = self.x ** 2
            sqy = self.y ** 2
            sqz = self.z ** 2
            heading = math.atan2(2 * self.y * self.w - 2 * self.x * self.z,
                                 1 - 2 * sqy - 2 * sqz)
            attitude = math.asin(2 * t)
            bank = math.atan2(2 * self.x * self.w - 2 * self.y * self.z,
                              1 - 2 * sqx - 2 * sqz)
        return heading, attitude, bank

    def get_matrix(self):
        xx = self.x ** 2
        xy = self.x * self.y
        xz = self.x * self.z
        xw = self.x * self.w
        yy = self.y ** 2
        yz = self.y * self.z
        yw = self.y * self.w
        zz = self.z ** 2
        zw = self.z * self.w
        M = Matrix4()
        M.a = 1 - 2 * (yy + zz)
        M.b = 2 * (xy - zw)
        M.c = 2 * (xz + yw)
        M.e = 2 * (xy + zw)
        M.f = 1 - 2 * (xx + zz)
        M.g = 2 * (yz - xw)
        M.i = 2 * (xz - yw)
        M.j = 2 * (yz + xw)
        M.k = 1 - 2 * (xx + yy)
        return M

    # Static constructors
    def new_identity(cls):
        return cls()
    new_identity = classmethod(new_identity)

    def new_rotate_axis(cls, angle, axis):
        assert(isinstance(axis, Vector3))
        axis = axis.normalized()
        s = math.sin(angle / 2)
        Q = cls()
        Q.w = math.cos(angle / 2)
        Q.x = axis.x * s
        Q.y = axis.y * s
        Q.z = axis.z * s
        return Q
    new_rotate_axis = classmethod(new_rotate_axis)

    def new_rotate_euler(cls, heading, attitude, bank):
        Q = cls()
        c1 = math.cos(heading / 2)
        s1 = math.sin(heading / 2)
        c2 = math.cos(attitude / 2)
        s2 = math.sin(attitude / 2)
        c3 = math.cos(bank / 2)
        s3 = math.sin(bank / 2)

        Q.w = c1 * c2 * c3 - s1 * s2 * s3
        Q.x = s1 * s2 * c3 + c1 * c2 * s3
        Q.y = s1 * c2 * c3 + c1 * s2 * s3
        Q.z = c1 * s2 * c3 - s1 * c2 * s3
        return Q
    new_rotate_euler = classmethod(new_rotate_euler)
    
    def new_rotate_matrix(cls, m):
      if m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] &gt; 0.00000001:
        t = m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          s*t,
          (m[1*4 + 2] - m[2*4 + 1])*s,
          (m[2*4 + 0] - m[0*4 + 2])*s,
          (m[0*4 + 1] - m[1*4 + 0])*s
          )
        
      elif m[0*4 + 0] &gt; m[1*4 + 1] and m[0*4 + 0] &gt; m[2*4 + 2]:
        t = m[0*4 + 0] - m[1*4 + 1] - m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[1*4 + 2] - m[2*4 + 1])*s,
          s*t,
          (m[0*4 + 1] + m[1*4 + 0])*s,
          (m[2*4 + 0] + m[0*4 + 2])*s
          )
        
      elif m[1*4 + 1] &gt; m[2*4 + 2]:
        t = -m[0*4 + 0] + m[1*4 + 1] - m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[2*4 + 0] - m[0*4 + 2])*s,
          (m[0*4 + 1] + m[1*4 + 0])*s,
          s*t,
          (m[1*4 + 2] + m[2*4 + 1])*s
          )
        
      else:
        t = -m[0*4 + 0] - m[1*4 + 1] + m[2*4 + 2] + 1.0
        s = 0.5/math.sqrt(t)
        
        return cls(
          (m[0*4 + 1] - m[1*4 + 0])*s,
          (m[2*4 + 0] + m[0*4 + 2])*s,
          (m[1*4 + 2] + m[2*4 + 1])*s,
          s*t
          )
    new_rotate_matrix = classmethod(new_rotate_matrix)
    
    def new_interpolate(cls, q1, q2, t):
        assert isinstance(q1, Quaternion) and isinstance(q2, Quaternion)
        Q = cls()

        costheta = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z
        if costheta &lt; 0.:
            costheta = -costheta
            q1 = q1.conjugated()
        elif costheta &gt; 1:
            costheta = 1

        theta = math.acos(costheta)
        if abs(theta) &lt; 0.01:
            Q.w = q2.w
            Q.x = q2.x
            Q.y = q2.y
            Q.z = q2.z
            return Q

        sintheta = math.sqrt(1.0 - costheta * costheta)
        if abs(sintheta) &lt; 0.01:
            Q.w = (q1.w + q2.w) * 0.5
            Q.x = (q1.x + q2.x) * 0.5
            Q.y = (q1.y + q2.y) * 0.5
            Q.z = (q1.z + q2.z) * 0.5
            return Q

        ratio1 = math.sin((1 - t) * theta) / sintheta
        ratio2 = math.sin(t * theta) / sintheta

        Q.w = q1.w * ratio1 + q2.w * ratio2
        Q.x = q1.x * ratio1 + q2.x * ratio2
        Q.y = q1.y * ratio1 + q2.y * ratio2
        Q.z = q1.z * ratio1 + q2.z * ratio2
        return Q
    new_interpolate = classmethod(new_interpolate)

# Geometry
# Much maths thanks to Paul Bourke, http://astronomy.swin.edu.au/~pbourke
# ---------------------------------------------------------------------------

class Geometry:
    def _connect_unimplemented(self, other):
        raise AttributeError, 'Cannot connect %s to %s' % \
            (self.__class__, other.__class__)

    def _intersect_unimplemented(self, other):
        raise AttributeError, 'Cannot intersect %s and %s' % \
            (self.__class__, other.__class__)

    _intersect_point2 = _intersect_unimplemented
    _intersect_line2 = _intersect_unimplemented
    _intersect_circle = _intersect_unimplemented
    _connect_point2 = _connect_unimplemented
    _connect_line2 = _connect_unimplemented
    _connect_circle = _connect_unimplemented

    _intersect_point3 = _intersect_unimplemented
    _intersect_line3 = _intersect_unimplemented
    _intersect_sphere = _intersect_unimplemented
    _intersect_plane = _intersect_unimplemented
    _connect_point3 = _connect_unimplemented
    _connect_line3 = _connect_unimplemented
    _connect_sphere = _connect_unimplemented
    _connect_plane = _connect_unimplemented

    def intersect(self, other):
        raise NotImplementedError

    def connect(self, other):
        raise NotImplementedError

    def distance(self, other):
        c = self.connect(other)
        if c:
            return c.length
        return 0.0

def _intersect_point2_circle(P, C):
    return abs(P - C.c) &lt;= C.r
    
def _intersect_line2_line2(A, B):
    d = B.v.y * A.v.x - B.v.x * A.v.y
    if d == 0:
        return None

    dy = A.p.y - B.p.y
    dx = A.p.x - B.p.x
    ua = (B.v.x * dy - B.v.y * dx) / d
    if not A._u_in(ua):
        return None
    ub = (A.v.x * dy - A.v.y * dx) / d
    if not B._u_in(ub):
        return None

    return Point2(A.p.x + ua * A.v.x,
                  A.p.y + ua * A.v.y)

def _intersect_line2_circle(L, C):
    a = L.v.magnitude_squared()
    b = 2 * (L.v.x * (L.p.x - C.c.x) + \
             L.v.y * (L.p.y - C.c.y))
    c = C.c.magnitude_squared() + \
        L.p.magnitude_squared() - \
        2 * C.c.dot(L.p) - \
        C.r ** 2
    det = b ** 2 - 4 * a * c
    if det &lt; 0:
        return None
    sq = math.sqrt(det)
    u1 = (-b + sq) / (2 * a)
    u2 = (-b - sq) / (2 * a)
    if not L._u_in(u1):
        u1 = max(min(u1, 1.0), 0.0)
    if not L._u_in(u2):
        u2 = max(min(u2, 1.0), 0.0)

    # Tangent
    if u1 == u2:
        return Point2(L.p.x + u1 * L.v.x,
                      L.p.y + u1 * L.v.y)

    return LineSegment2(Point2(L.p.x + u1 * L.v.x,
                               L.p.y + u1 * L.v.y),
                        Point2(L.p.x + u2 * L.v.x,
                               L.p.y + u2 * L.v.y))

def _connect_point2_line2(P, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((P.x - L.p.x) * L.v.x + \
         (P.y - L.p.y) * L.v.y) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    return LineSegment2(P, 
                        Point2(L.p.x + u * L.v.x,
                               L.p.y + u * L.v.y))

def _connect_point2_circle(P, C):
    v = P - C.c
    v.normalize()
    v *= C.r
    return LineSegment2(P, Point2(C.c.x + v.x, C.c.y + v.y))

def _connect_line2_line2(A, B):
    d = B.v.y * A.v.x - B.v.x * A.v.y
    if d == 0:
        # Parallel, connect an endpoint with a line
        if isinstance(B, Ray2) or isinstance(B, LineSegment2):
            p1, p2 = _connect_point2_line2(B.p, A)
            return p2, p1
        # No endpoint (or endpoint is on A), possibly choose arbitrary point
        # on line.
        return _connect_point2_line2(A.p, B)

    dy = A.p.y - B.p.y
    dx = A.p.x - B.p.x
    ua = (B.v.x * dy - B.v.y * dx) / d
    if not A._u_in(ua):
        ua = max(min(ua, 1.0), 0.0)
    ub = (A.v.x * dy - A.v.y * dx) / d
    if not B._u_in(ub):
        ub = max(min(ub, 1.0), 0.0)

    return LineSegment2(Point2(A.p.x + ua * A.v.x, A.p.y + ua * A.v.y),
                        Point2(B.p.x + ub * B.v.x, B.p.y + ub * B.v.y))

def _connect_circle_line2(C, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((C.c.x - L.p.x) * L.v.x + (C.c.y - L.p.y) * L.v.y) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    point = Point2(L.p.x + u * L.v.x, L.p.y + u * L.v.y)
    v = (point - C.c)
    v.normalize()
    v *= C.r
    return LineSegment2(Point2(C.c.x + v.x, C.c.y + v.y), point)

def _connect_circle_circle(A, B):
    v = B.c - A.c
    d = v.magnitude()
    if A.r &gt;= B.r and d &lt; A.r:
        #centre B inside A
        s1,s2 = +1, +1
    elif B.r &gt; A.r and d &lt; B.r:
        #centre A inside B
        s1,s2 = -1, -1
    elif d &gt;= A.r and d &gt;= B.r:
        s1,s2 = +1, -1
    v.normalize()
    return LineSegment2(Point2(A.c.x + s1 * v.x * A.r, A.c.y + s1 * v.y * A.r),
                        Point2(B.c.x + s2 * v.x * B.r, B.c.y + s2 * v.y * B.r))


class Point2(Vector2, Geometry):
    def __repr__(self):
        return 'Point2(%.2f, %.2f)' % (self.x, self.y)

    def intersect(self, other):
        return other._intersect_point2(self)

    def _intersect_circle(self, other):
        return _intersect_point2_circle(self, other)

    def connect(self, other):
        return other._connect_point2(self)

    def _connect_point2(self, other):
        return LineSegment2(other, self)
    
    def _connect_line2(self, other):
        c = _connect_point2_line2(self, other)
        if c:
            return c._swap()

    def _connect_circle(self, other):
        c = _connect_point2_circle(self, other)
        if c:
            return c._swap()

class Line2(Geometry):
    __slots__ = ['p', 'v']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point2) and \
                   isinstance(args[1], Vector2) and \
                   type(args[2]) == float
            self.p = args[0].copy()
            self.v = args[1] * args[2] / abs(args[1])
        elif len(args) == 2:
            if isinstance(args[0], Point2) and isinstance(args[1], Point2):
                self.p = args[0].copy()
                self.v = args[1] - args[0]
            elif isinstance(args[0], Point2) and isinstance(args[1], Vector2):
                self.p = args[0].copy()
                self.v = args[1].copy()
            else:
                raise AttributeError, '%r' % (args,)
        elif len(args) == 1:
            if isinstance(args[0], Line2):
                self.p = args[0].p.copy()
                self.v = args[0].v.copy()
            else:
                raise AttributeError, '%r' % (args,)
        else:
            raise AttributeError, '%r' % (args,)
        
        if not self.v:
            raise AttributeError, 'Line has zero-length vector'

    def __copy__(self):
        return self.__class__(self.p, self.v)

    copy = __copy__

    def __repr__(self):
        return 'Line2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.v.x, self.v.y)

    p1 = property(lambda self: self.p)
    p2 = property(lambda self: Point2(self.p.x + self.v.x, 
                                      self.p.y + self.v.y))

    def _apply_transform(self, t):
        self.p = t * self.p
        self.v = t * self.v

    def _u_in(self, u):
        return True

    def intersect(self, other):
        return other._intersect_line2(self)

    def _intersect_line2(self, other):
        return _intersect_line2_line2(self, other)

    def _intersect_circle(self, other):
        return _intersect_line2_circle(self, other)

    def connect(self, other):
        return other._connect_line2(self)

    def _connect_point2(self, other):
        return _connect_point2_line2(other, self)

    def _connect_line2(self, other):
        return _connect_line2_line2(other, self)

    def _connect_circle(self, other):
        return _connect_circle_line2(other, self)

class Ray2(Line2):
    def __repr__(self):
        return 'Ray2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.v.x, self.v.y)

    def _u_in(self, u):
        return u &gt;= 0.0

class LineSegment2(Line2):
    def __repr__(self):
        return 'LineSegment2(&lt;%.2f, %.2f&gt; to &lt;%.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.x + self.v.x, self.p.y + self.v.y)

    def _u_in(self, u):
        return u &gt;= 0.0 and u &lt;= 1.0

    def __abs__(self):
        return abs(self.v)

    def magnitude_squared(self):
        return self.v.magnitude_squared()

    def _swap(self):
        # used by connect methods to switch order of points
        self.p = self.p2
        self.v *= -1
        return self

    length = property(lambda self: abs(self.v))

class Circle(Geometry):
    __slots__ = ['c', 'r']

    def __init__(self, center, radius):
        assert isinstance(center, Vector2) and type(radius) == float
        self.c = center.copy()
        self.r = radius

    def __copy__(self):
        return self.__class__(self.c, self.r)

    copy = __copy__

    def __repr__(self):
        return 'Circle(&lt;%.2f, %.2f&gt;, radius=%.2f)' % \
            (self.c.x, self.c.y, self.r)

    def _apply_transform(self, t):
        self.c = t * self.c

    def intersect(self, other):
        return other._intersect_circle(self)

    def _intersect_point2(self, other):
        return _intersect_point2_circle(other, self)

    def _intersect_line2(self, other):
        return _intersect_line2_circle(other, self)

    def connect(self, other):
        return other._connect_circle(self)

    def _connect_point2(self, other):
        return _connect_point2_circle(other, self)

    def _connect_line2(self, other):
        c = _connect_circle_line2(self, other)
        if c:
            return c._swap()

    def _connect_circle(self, other):
        return _connect_circle_circle(other, self)

# 3D Geometry
# -------------------------------------------------------------------------

def _connect_point3_line3(P, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((P.x - L.p.x) * L.v.x + \
         (P.y - L.p.y) * L.v.y + \
         (P.z - L.p.z) * L.v.z) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    return LineSegment3(P, Point3(L.p.x + u * L.v.x,
                                  L.p.y + u * L.v.y,
                                  L.p.z + u * L.v.z))

def _connect_point3_sphere(P, S):
    v = P - S.c
    v.normalize()
    v *= S.r
    return LineSegment3(P, Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z))

def _connect_point3_plane(p, plane):
    n = plane.n.normalized()
    d = p.dot(plane.n) - plane.k
    return LineSegment3(p, Point3(p.x - n.x * d, p.y - n.y * d, p.z - n.z * d))

def _connect_line3_line3(A, B):
    assert A.v and B.v
    p13 = A.p - B.p
    d1343 = p13.dot(B.v)
    d4321 = B.v.dot(A.v)
    d1321 = p13.dot(A.v)
    d4343 = B.v.magnitude_squared()
    denom = A.v.magnitude_squared() * d4343 - d4321 ** 2
    if denom == 0:
        # Parallel, connect an endpoint with a line
        if isinstance(B, Ray3) or isinstance(B, LineSegment3):
            return _connect_point3_line3(B.p, A)._swap()
        # No endpoint (or endpoint is on A), possibly choose arbitrary
        # point on line.
        return _connect_point3_line3(A.p, B)

    ua = (d1343 * d4321 - d1321 * d4343) / denom
    if not A._u_in(ua):
        ua = max(min(ua, 1.0), 0.0)
    ub = (d1343 + d4321 * ua) / d4343
    if not B._u_in(ub):
        ub = max(min(ub, 1.0), 0.0)
    return LineSegment3(Point3(A.p.x + ua * A.v.x,
                               A.p.y + ua * A.v.y,
                               A.p.z + ua * A.v.z),
                        Point3(B.p.x + ub * B.v.x,
                               B.p.y + ub * B.v.y,
                               B.p.z + ub * B.v.z))

def _connect_line3_plane(L, P):
    d = P.n.dot(L.v)
    if not d:
        # Parallel, choose an endpoint
        return _connect_point3_plane(L.p, P)
    u = (P.k - P.n.dot(L.p)) / d
    if not L._u_in(u):
        # intersects out of range, choose nearest endpoint
        u = max(min(u, 1.0), 0.0)
        return _connect_point3_plane(Point3(L.p.x + u * L.v.x,
                                            L.p.y + u * L.v.y,
                                            L.p.z + u * L.v.z), P)
    # Intersection
    return None

def _connect_sphere_line3(S, L):
    d = L.v.magnitude_squared()
    assert d != 0
    u = ((S.c.x - L.p.x) * L.v.x + \
         (S.c.y - L.p.y) * L.v.y + \
         (S.c.z - L.p.z) * L.v.z) / d
    if not L._u_in(u):
        u = max(min(u, 1.0), 0.0)
    point = Point3(L.p.x + u * L.v.x, L.p.y + u * L.v.y, L.p.z + u * L.v.z)
    v = (point - S.c)
    v.normalize()
    v *= S.r
    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
                        point)

def _connect_sphere_sphere(A, B):
    v = B.c - A.c
    d = v.magnitude()
    if A.r &gt;= B.r and d &lt; A.r:
        #centre B inside A
        s1,s2 = +1, +1
    elif B.r &gt; A.r and d &lt; B.r:
        #centre A inside B
        s1,s2 = -1, -1
    elif d &gt;= A.r and d &gt;= B.r:
        s1,s2 = +1, -1

    v.normalize()
    return LineSegment3(Point3(A.c.x + s1* v.x * A.r,
                               A.c.y + s1* v.y * A.r,
                               A.c.z + s1* v.z * A.r),
                        Point3(B.c.x + s2* v.x * B.r,
                               B.c.y + s2* v.y * B.r,
                               B.c.z + s2* v.z * B.r))

def _connect_sphere_plane(S, P):
    c = _connect_point3_plane(S.c, P)
    if not c:
        return None
    p2 = c.p2
    v = p2 - S.c
    v.normalize()
    v *= S.r
    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
                        p2)

def _connect_plane_plane(A, B):
    if A.n.cross(B.n):
        # Planes intersect
        return None
    else:
        # Planes are parallel, connect to arbitrary point
        return _connect_point3_plane(A._get_point(), B)

def _intersect_point3_sphere(P, S):
    return abs(P - S.c) &lt;= S.r
    
def _intersect_line3_sphere(L, S):
    a = L.v.magnitude_squared()
    b = 2 * (L.v.x * (L.p.x - S.c.x) + \
             L.v.y * (L.p.y - S.c.y) + \
             L.v.z * (L.p.z - S.c.z))
    c = S.c.magnitude_squared() + \
        L.p.magnitude_squared() - \
        2 * S.c.dot(L.p) - \
        S.r ** 2
    det = b ** 2 - 4 * a * c
    if det &lt; 0:
        return None
    sq = math.sqrt(det)
    u1 = (-b + sq) / (2 * a)
    u2 = (-b - sq) / (2 * a)
    if not L._u_in(u1):
        u1 = max(min(u1, 1.0), 0.0)
    if not L._u_in(u2):
        u2 = max(min(u2, 1.0), 0.0)
    return LineSegment3(Point3(L.p.x + u1 * L.v.x,
                               L.p.y + u1 * L.v.y,
                               L.p.z + u1 * L.v.z),
                        Point3(L.p.x + u2 * L.v.x,
                               L.p.y + u2 * L.v.y,
                               L.p.z + u2 * L.v.z))

def _intersect_line3_plane(L, P):
    d = P.n.dot(L.v)
    if not d:
        # Parallel
        return None
    u = (P.k - P.n.dot(L.p)) / d
    if not L._u_in(u):
        return None
    return Point3(L.p.x + u * L.v.x,
                  L.p.y + u * L.v.y,
                  L.p.z + u * L.v.z)

def _intersect_plane_plane(A, B):
    n1_m = A.n.magnitude_squared()
    n2_m = B.n.magnitude_squared()
    n1d2 = A.n.dot(B.n)
    det = n1_m * n2_m - n1d2 ** 2
    if det == 0:
        # Parallel
        return None
    c1 = (A.k * n2_m - B.k * n1d2) / det
    c2 = (B.k * n1_m - A.k * n1d2) / det
    return Line3(Point3(c1 * A.n.x + c2 * B.n.x,
                        c1 * A.n.y + c2 * B.n.y,
                        c1 * A.n.z + c2 * B.n.z), 
                 A.n.cross(B.n))

class Point3(Vector3, Geometry):
    def __repr__(self):
        return 'Point3(%.2f, %.2f, %.2f)' % (self.x, self.y, self.z)

    def intersect(self, other):
        return other._intersect_point3(self)

    def _intersect_sphere(self, other):
        return _intersect_point3_sphere(self, other)

    def connect(self, other):
        return other._connect_point3(self)

    def _connect_point3(self, other):
        if self != other:
            return LineSegment3(other, self)
        return None

    def _connect_line3(self, other):
        c = _connect_point3_line3(self, other)
        if c:
            return c._swap()
        
    def _connect_sphere(self, other):
        c = _connect_point3_sphere(self, other)
        if c:
            return c._swap()

    def _connect_plane(self, other):
        c = _connect_point3_plane(self, other)
        if c:
            return c._swap()

class Line3:
    __slots__ = ['p', 'v']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point3) and \
                   isinstance(args[1], Vector3) and \
                   type(args[2]) == float
            self.p = args[0].copy()
            self.v = args[1] * args[2] / abs(args[1])
        elif len(args) == 2:
            if isinstance(args[0], Point3) and isinstance(args[1], Point3):
                self.p = args[0].copy()
                self.v = args[1] - args[0]
            elif isinstance(args[0], Point3) and isinstance(args[1], Vector3):
                self.p = args[0].copy()
                self.v = args[1].copy()
            else:
                raise AttributeError, '%r' % (args,)
        elif len(args) == 1:
            if isinstance(args[0], Line3):
                self.p = args[0].p.copy()
                self.v = args[0].v.copy()
            else:
                raise AttributeError, '%r' % (args,)
        else:
            raise AttributeError, '%r' % (args,)
        
        # XXX This is annoying.
        #if not self.v:
        #    raise AttributeError, 'Line has zero-length vector'

    def __copy__(self):
        return self.__class__(self.p, self.v)

    copy = __copy__

    def __repr__(self):
        return 'Line3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)

    p1 = property(lambda self: self.p)
    p2 = property(lambda self: Point3(self.p.x + self.v.x, 
                                      self.p.y + self.v.y,
                                      self.p.z + self.v.z))

    def _apply_transform(self, t):
        self.p = t * self.p
        self.v = t * self.v

    def _u_in(self, u):
        return True

    def intersect(self, other):
        return other._intersect_line3(self)

    def _intersect_sphere(self, other):
        return _intersect_line3_sphere(self, other)

    def _intersect_plane(self, other):
        return _intersect_line3_plane(self, other)

    def connect(self, other):
        return other._connect_line3(self)

    def _connect_point3(self, other):
        return _connect_point3_line3(other, self)

    def _connect_line3(self, other):
        return _connect_line3_line3(other, self)

    def _connect_sphere(self, other):
        return _connect_sphere_line3(other, self)

    def _connect_plane(self, other):
        c = _connect_line3_plane(self, other)
        if c:
            return c

class Ray3(Line3):
    def __repr__(self):
        return 'Ray3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)

    def _u_in(self, u):
        return u &gt;= 0.0

class LineSegment3(Line3):
    def __repr__(self):
        return 'LineSegment3(&lt;%.2f, %.2f, %.2f&gt; to &lt;%.2f, %.2f, %.2f&gt;)' % \
            (self.p.x, self.p.y, self.p.z,
             self.p.x + self.v.x, self.p.y + self.v.y, self.p.z + self.v.z)

    def _u_in(self, u):
        return u &gt;= 0.0 and u &lt;= 1.0

    def __abs__(self):
        return abs(self.v)

    def magnitude_squared(self):
        return self.v.magnitude_squared()

    def _swap(self):
        # used by connect methods to switch order of points
        self.p = self.p2
        self.v *= -1
        return self

    length = property(lambda self: abs(self.v))

class Sphere:
    __slots__ = ['c', 'r']

    def __init__(self, center, radius):
        assert isinstance(center, Vector3) and type(radius) == float
        self.c = center.copy()
        self.r = radius

    def __copy__(self):
        return self.__class__(self.c, self.r)

    copy = __copy__

    def __repr__(self):
        return 'Sphere(&lt;%.2f, %.2f, %.2f&gt;, radius=%.2f)' % \
            (self.c.x, self.c.y, self.c.z, self.r)

    def _apply_transform(self, t):
        self.c = t * self.c

    def intersect(self, other):
        return other._intersect_sphere(self)

    def _intersect_point3(self, other):
        return _intersect_point3_sphere(other, self)

    def _intersect_line3(self, other):
        return _intersect_line3_sphere(other, self)

    def connect(self, other):
        return other._connect_sphere(self)

    def _connect_point3(self, other):
        return _connect_point3_sphere(other, self)

    def _connect_line3(self, other):
        c = _connect_sphere_line3(self, other)
        if c:
            return c._swap()

    def _connect_sphere(self, other):
        return _connect_sphere_sphere(other, self)

    def _connect_plane(self, other):
        c = _connect_sphere_plane(self, other)
        if c:
            return c

class Plane:
    # n.p = k, where n is normal, p is point on plane, k is constant scalar
    __slots__ = ['n', 'k']

    def __init__(self, *args):
        if len(args) == 3:
            assert isinstance(args[0], Point3) and \
                   isinstance(args[1], Point3) and \
                   isinstance(args[2], Point3)
            self.n = (args[1] - args[0]).cross(args[2] - args[0])
            self.n.normalize()
            self.k = self.n.dot(args[0])
        elif len(args) == 2:
            if isinstance(args[0], Point3) and isinstance(args[1], Vector3):
                self.n = args[1].normalized()
                self.k = self.n.dot(args[0])
            elif isinstance(args[0], Vector3) and type(args[1]) == float:
                self.n = args[0].normalized()
                self.k = args[1]
            else:
                raise AttributeError, '%r' % (args,)

        else:
            raise AttributeError, '%r' % (args,)
        
        if not self.n:
            raise AttributeError, 'Points on plane are colinear'

    def __copy__(self):
        return self.__class__(self.n, self.k)

    copy = __copy__

    def __repr__(self):
        return 'Plane(&lt;%.2f, %.2f, %.2f&gt;.p = %.2f)' % \
            (self.n.x, self.n.y, self.n.z, self.k)

    def _get_point(self):
        # Return an arbitrary point on the plane
        if self.n.z:
            return Point3(0., 0., self.k / self.n.z)
        elif self.n.y:
            return Point3(0., self.k / self.n.y, 0.)
        else:
            return Point3(self.k / self.n.x, 0., 0.)

    def _apply_transform(self, t):
        p = t * self._get_point()
        self.n = t * self.n
        self.k = self.n.dot(p)

    def intersect(self, other):
        return other._intersect_plane(self)

    def _intersect_line3(self, other):
        return _intersect_line3_plane(other, self)

    def _intersect_plane(self, other):
        return _intersect_plane_plane(self, other)

    def connect(self, other):
        return other._connect_plane(self)

    def _connect_point3(self, other):
        return _connect_point3_plane(other, self)

    def _connect_line3(self, other):
        return _connect_line3_plane(other, self)

    def _connect_sphere(self, other):
        return _connect_sphere_plane(other, self)

    def _connect_plane(self, other):
        return _connect_plane_plane(other, self)
</t>
<t tx="amd_yen.20130426011410.8912">https://github.com/vmlaker/pythonwildmagic

這是一個 http://www.geometrictools.com/ C++ 程式庫的 Python 3 介面套件.</t>
<t tx="leo.20170331152739.1"></t>
<t tx="leo.20170331152739.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20170331152739.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20170331153122.1">先用 @auto 代替 @file

存檔後, 再用 @clean 代替  @auto</t>
<t tx="leo.20170331234345.1"></t>
<t tx="leo.20170402112029.1">在 Eric6 與 Leo Editor 各設定專案

Eric6 專門負責 PyQt5 相關程式設計

Leo Editor 則負責留下開發紀錄並協助 debug</t>
<t tx="leo.20170402113716.1">PyQt5 與 PyQt4 差異:

.emit() 不再支援

因此

class DataModel 

insertRow

insertRows

removeRows

setData

中有 .emit() 都必須修改

有 Signal 與 Slot 的部分也必須修改
</t>
<t tx="leo.20170402114140.1">PyQt4’s old-style signals and slots are not supported. Therefore the following are not implemented in PyQt5:

QObject.connect()
QObject.emit()
SIGNAL()
SLOT()

All methods that had arguments that are usually the results of calls to SIGNAL() or SLOT() are no longer supported. There will always be an equivalent that takes a bound signal or callable respectively.

In addition the following methods have differences:

disconnect() takes no arguments and disconnects all connections to the QObject instance.

其他差異

http://pyqt.sourceforge.net/Docs/PyQt5/pyqt4_differences.html
</t>
<t tx="leo.20170402122413.1">http://stackoverflow.com/questions/6888750/pyqt-or-pyside-which-one-to-use</t>
<t tx="leo.20170403085042.1">anaconda3 lib shutil.py 
line 249

_isdir: illegal type for path parameter

Gernic 

application.py 中的錯誤</t>
<t tx="leo.20170404160530.1">存檔案時

_isdir: illegal type for path parameter

與 shutil 導入的存檔案程式段有關

也就是出現在 application.py 中的錯誤

unable to set active the document temp .pdr

</t>
</tnodes>
</leo_file>
